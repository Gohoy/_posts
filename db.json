{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/gov.png","path":"img/gov.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/titleTip.js","path":"js/titleTip.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","path":"css/fonts/iconfont.woff2","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/github.user.css","path":"css/github.user.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/base.user.css","path":"css/base.user.css","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/CentOS安装K8S文档.md","hash":"613530fb186841aa420db901e9e987e02bcc4977","modified":1694439424460},{"_id":"source/_posts/Lemon吉他谱.md","hash":"45efa29d4811c6c00bc13490d4785a5f18b795ad","modified":1693377115052},{"_id":"source/_posts/k8s-web最终文档.md","hash":"1efd835f6264bfc703e2f16f1484fd63a80ea8d7","modified":1694439409849},{"_id":"source/_posts/四子ding 设计.md","hash":"bdc5a9fdcec2c3f8f398ab2be895847efcad44a1","modified":1694439577696},{"_id":"source/_posts/Mydisk项目源码说明文档.md","hash":"a72662c9ff20a30a417ed57e3a177dd9ca4913e3","modified":1694439206266},{"_id":"source/_posts/k8s容器和虚拟机负载均衡方案分析.md","hash":"fe47251da346c5a1cf7ba8eda798d56835f34ba3","modified":1694439180351},{"_id":"source/_posts/小幸运吉他.md","hash":"f9653c7eee7f21db75b364f3e194db13f8c1f204","modified":1693747015952},{"_id":"source/_posts/构建openEuler的docker容器.md","hash":"ba91afc4e928e75ab0d45e6976bb6149218e7a64","modified":1693377353903},{"_id":"source/_posts/未闻花名.md","hash":"31a4518597e7b23480c6cb82b28570dca2703c50","modified":1693377955628},{"_id":"source/_posts/游戏机制中的概率论.md","hash":"6509cd641e50078640ae0c87f5bfed1bdf05c0b1","modified":1694438877238},{"_id":"source/_posts/晴天.md","hash":"c6f634b694862a164b0c6426d2eb6dc6e91c78d0","modified":1693825862864},{"_id":"source/_posts/兰亭序吉他谱.md","hash":"9f9879db7f341c5ec670a0d5ec4d53dcb4cba7f7","modified":1693377765467},{"_id":"source/_posts/爱在西元前.md","hash":"45668a44f6ad42230df90a60a11cf82f3a715709","modified":1693378341634},{"_id":"source/_posts/说好的幸福呢.md","hash":"33d9c9ecc954d0fb9833f6c95ab73f772c710779","modified":1693826204772},{"_id":"source/_posts/花海吉他谱.md","hash":"c293b62112de34a6757c731bc54d14b0fd0ddc32","modified":1693377715810},{"_id":"source/_posts/面经.md","hash":"cd15af03f2c5bdd9b96dabf8bd186bbda88d293e","modified":1694444201421},{"_id":"source/_posts/重装k8s服务器文档.md","hash":"0885ae43c98dc91d35e6aaf2b1f5fb9a86f65c0b","modified":1694439567487},{"_id":"themes/3-hexo/.gitignore","hash":"46eca80fe689a00cbe4d015c094702af54119021","modified":1693359263473},{"_id":"themes/3-hexo/_config.yml","hash":"8a933bf32790183331ae9bba93cec96f1cf16830","modified":1694445937916},{"_id":"themes/3-hexo/languages/en.yml","hash":"616e02c035c86033ab4a97c5ae9e0a9e5f0b8ea3","modified":1693359263474},{"_id":"themes/3-hexo/languages/zh-CN.yml","hash":"83633d45420c96dfac41333aeac3f3616dca5286","modified":1693359263475},{"_id":"themes/3-hexo/README.md","hash":"19b8cfe6690c28427492f342e74dda5ed49a1664","modified":1693359263474},{"_id":"themes/3-hexo/layout/indexs.md","hash":"0e53f5f6365c1d089840bf1a448306ef2faeff1e","modified":1693363959142},{"_id":"themes/3-hexo/layout/index.ejs","hash":"1c185288c2925a652d577965626718e12df07f65","modified":1693359263481},{"_id":"themes/3-hexo/layout/post.ejs","hash":"a0eaba41e7ec9db5843af482470a45531049b457","modified":1693359263481},{"_id":"themes/3-hexo/.DS_Store","hash":"0770f9d42bfdd8d420de48fed463015e001cf579","modified":1693359263472},{"_id":"themes/3-hexo/LICENSE","hash":"b04140c5f682db2b300428f97bb164fd7f5f18bd","modified":1693359263474},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"9e5afcc26f47f93c165072b0a2b5cbf72efb7ef9","modified":1693359263475},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"9e1cdec49d5b9b44399348d96ecd7331f3ee7d85","modified":1693359263476},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"4c09f47e899fe36bfe36d92b12996219c2b5f622","modified":1693359263478},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"d18f94e04ef0cf7abb432a8e707ccb3abc7fe435","modified":1693359263476},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"b2a01cc1f0326965f0a186ce3c9b3c991fd4e2c9","modified":1693359263478},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"3b819f6fbaac7a2a5f06c85872cdb794b2d84451","modified":1693367962651},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"e6dd90be668195016d6e1c51a6baefb50676e6ab","modified":1693359263479},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"60a085fab3165ea1fc6370abac0bd6ab1b2f2510","modified":1693359263479},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"233c7238136b9cc2c30fd4e66b113d8fd1c1726b","modified":1693359263479},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"e2be0e37f3d48e63e65a47d819bfb800b9aa3784","modified":1693359263479},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"ab6329ddd908b0567c18f39ac6a8553c6fec67c5","modified":1693359263480},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"2fbca44ae051bf231c346c66350070c13371fb27","modified":1693359263480},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"8704e6bd833d270cc6a494d4e7cf1dfeddedba40","modified":1693359263480},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"0c693379995b09007727c2889c1a64e3bf98749e","modified":1693359263480},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"33f7a4bfca1bb9835ec8f0d1e73188d1f56cc8b9","modified":1693359263481},{"_id":"themes/3-hexo/source/css/style.styl","hash":"c399c00bf3d9807cc54f3ca358a6ffbcaf717434","modified":1694508826064},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"1c2f8b7d7cf46f219adb3a628bdf380f29ff4a6b","modified":1693359263493},{"_id":"themes/3-hexo/source/.DS_Store","hash":"fdcc907c46e093a14b153c5dc8c038461997ed3c","modified":1693359263482},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"500854fa15b1acc87be56cecd6becb208366881a","modified":1693363633677},{"_id":"themes/3-hexo/.github/ISSUE_TEMPLATE/bug_report.md","hash":"3df61acb19a16f12d8ec60cc5e353147a0a56d39","modified":1693359263473},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1693359263495},{"_id":"themes/3-hexo/source/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1693359263496},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"c8ed7cc29809cf6a5dd54e956b2deeade5a780b4","modified":1694508805054},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1693359263496},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1693359263502},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"8c2a4f10a4da3d9615a3a81542494c6d21479b3d","modified":1693359263503},{"_id":"themes/3-hexo/source/js/script.js","hash":"9bf5f74ecd252545a64b63281322bce9611c2fcd","modified":1693359263503},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1693359263496},{"_id":"themes/3-hexo/source/js/titleTip.js","hash":"7299ac046ddd6e6a4267d435f7b4c8198baaaccc","modified":1693359263504},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"05b09c45b379ffeb4f48c1604044d88829f90799","modified":1693359263476},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"32ce7b48d366b9c888ff2ceb911a3cd82f864537","modified":1693359263476},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"01567e010cf4f2dd141fe2019490d3f0d5aa2529","modified":1693359263477},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"eaf2b6f297282606b630ad55fb9e38af7e2829dc","modified":1693359263477},{"_id":"themes/3-hexo/layout/_partial/comments/utteranc.ejs","hash":"8f2d4f42fbad351677c82e72420224587a5bd666","modified":1693359263478},{"_id":"themes/3-hexo/layout/_partial/comments/livere.ejs","hash":"2d115e79cadedc2d5d8f4b5618559640d986e01f","modified":1693359263477},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f0eac1dc1f5dbed1769d032bb5fd5f002faaee26","modified":1693359263483},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"d5fa333970a2eac66937d42eeb16fdb362e121ed","modified":1693359263482},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"02c7510a26f306e240f23ddbf772a69be2c890dd","modified":1693359263483},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"3db01e603985e6dbcacb6b0f13dbd804f5849e3c","modified":1693359263483},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"9a732af065d0a80c9e420934be0f3582bf0129dc","modified":1693359263483},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"4304a111489d22a97389e0403c51bb4de73f6609","modified":1693359263484},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"b57fbac9d87f93ef88f97f86387ce9f2efa918d0","modified":1693359263484},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"2620a02169a6aeb75137fd368eac2c36423d8498","modified":1693359263484},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"f7ef35459ece22e1da950b86126be1c2bfe97fcf","modified":1693359263484},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"f1251e2a3b5334af3a22b51fc0293c2456568b50","modified":1693359263485},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1693359263485},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1693359263486},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1693359263486},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1693359263486},{"_id":"themes/3-hexo/source/js/search.js","hash":"788c610149a5f9361295f9f0207c8523f37ddb8b","modified":1693359263503},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1693359263486},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1693359263487},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1693359263489},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"3630aabf2f9c0417f483ebd03d9e429dbc2594e0","modified":1693359263487},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1693359263488},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1693359263488},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"b6456a4eabcffd95e822d1d7adce96da524d481a","modified":1693359263488},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1693359263490},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1693359263490},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"553987211d3323a7dfc0b08786b183a3435978c9","modified":1693359263489},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1693359263490},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1693359263490},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1693359263491},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1693359263491},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1693359263491},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1693359263492},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1693359263492},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1693359263492},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1693359263492},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1693359263493},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1693359263493},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"67984b83cd46ff4300d4fd959bf6c17dd66b4136","modified":1693359263502},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"92941a6ae73b74f44ad7c559c5548c44073c644a","modified":1693359263493},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"3e2e0cf9caa6b8d07b9c5e0733a1ccb3e244259f","modified":1693359263501},{"_id":"public/2023/08/30/面经/index.html","hash":"2466a86f6cc8e24604d64d78c50e72ca315e2b95","modified":1694446004113},{"_id":"public/2023/08/30/k8s-web最终文档/index.html","hash":"f746d420a65dce6a9d1dcaa01c861e9674c051ec","modified":1694446004113},{"_id":"public/2023/08/30/重装k8s服务器文档/index.html","hash":"3c55d22891f263ab6d0022c4363d6f087123a0ad","modified":1694446004113},{"_id":"public/2023/08/30/游戏机制中的概率论/index.html","hash":"d039e0709db5f7c6d4a02bd0b0be75157b3f0965","modified":1694446004113},{"_id":"public/2023/08/30/小幸运吉他/index.html","hash":"78f7018a07b7817bcbd034b6ddc42b57914fac4e","modified":1694446004113},{"_id":"public/2023/08/30/未闻花名/index.html","hash":"82a6dd1595e401ee61c8bbe6ec72a2b8c155cd8a","modified":1694446004113},{"_id":"public/2023/08/30/四子ding 设计/index.html","hash":"83600249f4bfb0c3169a76fdb58161828daf66d6","modified":1694446004113},{"_id":"public/2023/08/30/说好的幸福呢/index.html","hash":"b54876ba1bfffec3c17b8a1feb503ffa4eb0cf97","modified":1694446004113},{"_id":"public/2023/08/30/晴天/index.html","hash":"cf9d31f358573f66a3158b2818dc12569247be86","modified":1694446004113},{"_id":"public/2023/08/30/兰亭序吉他谱/index.html","hash":"4e894f8ec87d438e2c9bc64fc9fa68135a2ababb","modified":1694446004113},{"_id":"public/2023/08/30/花海吉他谱/index.html","hash":"4b849554afbb80f2adf653809df322b636f7f24e","modified":1694446004113},{"_id":"public/2023/08/30/构建openEuler的docker容器/index.html","hash":"7ad8e56edc41519fae38ba131d37a9e4a430ffa6","modified":1694446004113},{"_id":"public/2023/08/30/爱在西元前/index.html","hash":"86355ec8c3ebb0b6a862e4cad308ac9b0ef47d6d","modified":1694446004113},{"_id":"public/2023/08/30/Mydisk项目源码说明文档/index.html","hash":"113b8ad88bf393343f816b554787c602f725af44","modified":1694446004113},{"_id":"public/2023/08/30/Lemon吉他谱/index.html","hash":"3720ba61f7c60a2f2ee4a9388c22b9541e0ef244","modified":1694446004113},{"_id":"public/2023/08/30/k8s容器和虚拟机负载均衡方案分析/index.html","hash":"f512f32ddae0c052d530058d02516f692056f29a","modified":1694446004113},{"_id":"public/2023/08/30/CentOS安装K8S文档/index.html","hash":"aab69920b9f198e04b44479ab2144b2ace6c2a84","modified":1694446004113},{"_id":"public/archives/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/archives/page/2/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/archives/2023/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/archives/2023/page/2/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/archives/2023/08/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/archives/2023/08/page/2/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/categories/K8S/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/categories/吉他谱/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/categories/设计文档/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/categories/docker/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/categories/理论/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/categories/Java/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/page/2/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/Centos/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/K8S/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/教程/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/吉他谱/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/设计文档/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/Mydisk/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/负载均衡/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/四子ding/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/docker/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/contianer/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/openEuler/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/概率论/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/掷筛/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/NdS/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/arm64/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/Java/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/面经/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/八股文/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1694446004113},{"_id":"public/img/gov.png","hash":"f31c9f47faedf7f33b9580d6284ab891fb697560","modified":1694446004113},{"_id":"public/img/avatar.jpg","hash":"500854fa15b1acc87be56cecd6becb208366881a","modified":1694446004113},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1694446004113},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1694446004113},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1694446004113},{"_id":"public/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1694446004113},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1694446004113},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1694446004113},{"_id":"public/css/fonts/iconfont.eot","hash":"b14b8624988ff069aff3145f88c0d7ac49052bd3","modified":1694446004113},{"_id":"public/css/fonts/iconfont.svg","hash":"3630aabf2f9c0417f483ebd03d9e429dbc2594e0","modified":1694446004113},{"_id":"public/css/fonts/iconfont.ttf","hash":"140829ecf12d30c6e18d8dc6dc0c188a66addd25","modified":1694446004113},{"_id":"public/css/fonts/iconfont.woff","hash":"0d2d4559f1ac4fa801eb8cc099fa5bf9dcf955ef","modified":1694446004113},{"_id":"public/css/fonts/iconfont.woff2","hash":"b0317a0b2ebb1181a8bf5a97d03556dd54538645","modified":1694446004113},{"_id":"public/css/mobile.css","hash":"5998f6fc27998596beb1e40e4bc3c43be2ed764c","modified":1694446004113},{"_id":"public/js/titleTip.js","hash":"81dca549063e29ba3a4a278f0f4388eba8a2167b","modified":1694446004113},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1694446004113},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1694446004113},{"_id":"public/css/hl_theme/atom-light.css","hash":"d31edb9816dae6b01410028bceb91757a962f780","modified":1694446004113},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1694446004113},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1694446004113},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1694446004113},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1694446004113},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1694446004113},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1694446004113},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1694446004113},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1694446004113},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1694446004113},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1694446004113},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1694446004113},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1694446004113},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1694446004113},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1694446004113},{"_id":"public/css/gitalk.css","hash":"54d4fd686242d4c459a2db0b6fe8aadfc083314b","modified":1694508834087},{"_id":"public/css/style.css","hash":"d5ccd53e4b8d3bf10f0b8a544c06e46bc9528931","modified":1694508834087},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1694446004113},{"_id":"public/js/script.js","hash":"61e8ba1228d8441144fa7a655aa02ec546bd1f02","modified":1694446004113},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1694446004113},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1694446004113},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1694446004113},{"_id":"public/js/gitalk.js","hash":"26ba4841dcb4b178f730f53a8d1f4a7c89442b4f","modified":1694446004113},{"_id":"source/_posts/使用Let's Encrypt给网站添加SSL.md","hash":"f74d8bd68f2a40fcaf43da92bcbafe6428f77d3a","modified":1694438860166},{"_id":"public/2023/09/04/使用Let's Encrypt给网站添加SSL/index.html","hash":"02a39329b98c784acb452928931b86512dd5958e","modified":1694446004113},{"_id":"public/categories/教程/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/archives/2023/09/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/ssl/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"public/tags/https/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"source/_posts/springboot查询数据库字段实践.md","hash":"e74936556aebe1852c85a7c556a68cde22cfef43","modified":1694438978328},{"_id":"public/2023/09/05/springboot查询数据库字段实践/index.html","hash":"8d9a2741d91114ac8a658df55d75170332f8372f","modified":1694446004113},{"_id":"public/tags/springboot/index.html","hash":"9248d7f40b78f64bdef32b545c6103ab12f8bcb5","modified":1694446004113},{"_id":"themes/3-hexo/source/css/github.user.css","hash":"83c181524401adcccb421d1bb2a9c9dd72ce80c8","modified":1694438254437},{"_id":"themes/3-hexo/source/css/base.user.css","hash":"b8338f0fe77347751ae0069b9c2425f42334e507","modified":1694508265334},{"_id":"public/css/github.user.css","hash":"83c181524401adcccb421d1bb2a9c9dd72ce80c8","modified":1694446004113},{"_id":"public/css/base.user.css","hash":"bc724eb0503312cf0052764ef452c6a058f0eacd","modified":1694446004113}],"Category":[{"name":"K8S","_id":"cllyxpksc000214gf5ined7ji"},{"name":"吉他谱","_id":"cllyxpksg000714gfci8aeep1"},{"name":"设计文档","_id":"cllyxpksi000c14gfde3y3qae"},{"name":"docker","_id":"cllyxpksn000q14gf8c6xh074"},{"name":"理论","_id":"cllyxpksp000x14gfgwy55r3v"},{"name":"Java","_id":"cllyxpkt1002c14gfffgngpu5"},{"name":"教程","_id":"clm4spvdc0001ksgfhtj54m8c"}],"Data":[],"Page":[],"Post":[{"title":"Centos7 安装 k8s","_content":"\n# Centos7 安装 k8s 环境\n\n> 安装centos7虚拟机\n\n* Vmware 下载 mini 包[x86_64下载地址](http://mirrors.oit.uci.edu/centos/7.9.2009/isos/x86_64/)\n\n* 硬件至少 2G 2核\n\n> 初始配置虚拟机网络\n\n* 更改hostname\n  \n  * echo 'master' >> /etc/hostname\n\n* 更改静态ip\n  \n  * 打开 /etc/sysconfig/network-scripts/ifcfg-ens33  ，网卡名称有的使eth0 有的是ens33，使用 ip addr查看\n  \n  * 将 BOOTPROTO=dhcp 改为 static\n  \n  * 将ONBOOT=no 改为yes\n  \n  * 末尾加上你的配置\n    \n    ```shell\n    # /etc/sysconfig/network-scripts/ifcfg-ens33\n    IPADDR=192.168.111.201\n    \n    NETMASK=255.255.255.0\n    \n    GATEWAY=192.168.111.2\n    \n    DNS1=8.8.8.8\n    ```\n\n* /etc/hosts 加上 ip ：hostname\n  \n  ```shell\n  # /etc/hosts\n  192.168.111.200 master\n  \n  192.168.111.201 node1\n  \n  192.168.111.202 node2\n  ```\n\n* systemctl restart network \n\n* 使配置生效，此时能ping通外网\n\n> 使用vscode或其他应用连接虚拟机\n\n> 同步时间 补全命令\n\n* ```shell\n  sudo yum -y install ntpdate\n  sudo ntpdate ntp1.aliyun.com\n  sudo systemctl status ntpdate\n  sudo systemctl start ntpdate\n  sudo systemctl status ntpdate\n  sudo systemctl enable ntpdate\n  ```\n\n* ```shell\n  sudo yum -y install bash-completion\n  source /etc/profile\n  ```\n\n> 关闭防火墙 或者 开启防火墙端口\n\n* ```shell\n  sudo systemctl stop firewalld.service \n  sudo systemctl disable firewalld.service\n  ```\n\n* ```shell\n  # 控制面板\n  firewall-cmd --zone=public --add-port=6443/tcp --permanent # Kubernetes API server    所有\n  firewall-cmd --zone=public --add-port=2379/tcp --permanent # etcd server client API    kube-apiserver, etcd\n  firewall-cmd --zone=public --add-port=2380/tcp --permanent # etcd server client API    kube-apiserver, etcd\n  firewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API    自身, 控制面\n  firewall-cmd --zone=public --add-port=10259/tcp --permanent # kube-scheduler    自身\n  firewall-cmd --zone=public --add-port=10257/tcp --permanent # kube-controller-manager    自身\n  firewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各个节点的IP\n  firewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各个节点的IP\n  firewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各个节点的IP\n  firewall-cmd --add-masquerade --permanent # 端口转发\n  firewall-cmd --reload\n  firewall-cmd --list-all\n  firewall-cmd --list-all --zone=trusted\n  \n  # 工作节点\n  firewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API    自身, 控制面\n  firewall-cmd --zone=public --add-port=30000-32767/tcp --permanent # NodePort Services†    所有\n  firewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各个节点的IP\n  firewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各个节点的IP\n  firewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各个节点的IP\n  firewall-cmd --add-masquerade --permanent # 端口转发\n  firewall-cmd --reload\n  firewall-cmd --list-all\n  firewall-cmd --list-all --zone=trusted\n  ```\n\n> 关闭swap 和 selinux\n\n* ```shell\n  free -h  //查看是否关闭\n  sudo swapoff -a  //暂时关闭\n  sudo sed -i 's/.*swap.*/#&/' /etc/fstab //永久关闭\n  free -h\n  ```\n  \n  ```shell\n  getenforce\n  cat /etc/selinux/config\n  sudo setenforce 0\n  sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config\n  cat /etc/selinux/config\n  ```\n\n> 安装docker 和 containerd，1.24.0版本开始，k8s使用containerd代替docker\n\n* cgroup（control group）是 Linux 内核提供的一种机制，用于对进程进行资源限制、统计和控制。通过 cgroup，我们可以对一个或多个进程的 CPU、内存、IO、网络等资源进行限制，从而保证系统资源的合理分配，防止某些进程占用过多的资源导致系统崩溃或变慢。\n\n* ```shell\n  # https://docs.docker.com/engine/install/centos/\n  sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine\n  sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n  sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo \n  # yum --showduplicates list docker-ce\n  sudo yum install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin\n  sudo yum install -y containerd\n  \n  # 启动 docker 时，会启动 containerd\n  # sudo systemctl status containerd.service\n  sudo systemctl stop containerd.service\n  \n  # 设置containerd 的默认配置文件\n  sudo cp /etc/containerd/config.toml /etc/containerd/config.toml.bak\n  sudo containerd config default > $HOME/config.toml\n  sudo cp $HOME/config.toml /etc/containerd/config.toml\n  \n  # 对containerd 换源和设置cgroup的设置\n  sudo sed -i \"s#registry.k8s.io/pause#registry.aliyuncs.com/k8sxio/pause#g\" /etc/containerd/config.toml\n  # https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/#containerd-systemd\n  # 确保 /etc/containerd/config.toml 中的 disabled_plugins 内不存在 cri\n  sudo sed -i \"s#SystemdCgroup = false#SystemdCgroup = true#g\" /etc/containerd/config.toml\n  \n  # containerd 忽略证书验证的配置\n  #      [plugins.\"io.containerd.grpc.v1.cri\".registry.configs]\n  #        [plugins.\"io.containerd.grpc.v1.cri\".registry.configs.\"192.168.0.12:8001\".tls]\n  #          insecure_skip_verify = true\n  sudo systemctl enable --now containerd.service\n  \n  sudo systemctl start docker.service\n  ```\n\n```shell\nsudo systemctl enable docker.service\nsudo systemctl enable docker.socket\nsudo systemctl list-unit-files | grep docker\n\nsudo mkdir -p /etc/docker\n\n# 对docker换源和cgroup设置\ncat<<EOF | sudo tee /etc/docker/daemon.json \n {\n \"registry-mirrors\": [\"https://2u8f97e8.mirror.aliyuncs.com\"],\n \"exec-opts\": [\"native.cgroupdriver=systemd\"]\n }\nEOF\n\nsudo systemctl daemon-reload\nsudo systemctl restart docker\nsudo docker info\n\nsudo systemctl status docker.service\nsudo systemctl status containerd.service\n```\n\n> 安装k8s\n\n* 添加k8s 仓库\n\n```shell\ncat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\n# 是否开启本仓库\nenabled=1\n# 是否检查 gpg 签名文件\ngpgcheck=0\n# 是否检查 gpg 签名文件\nrepo_gpgcheck=0\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\n\nEOF\n```\n\n* 设置内核参数\n\n```shell\n# 设置所需的 sysctl 参数，参数在重新启动后保持不变\ncat <<EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-iptables  = 1 \nnet.bridge.bridge-nf-call-ip6tables = 1  //这两条让网络连接走iptables（禁用可以不设置）\nnet.ipv4.ip_forward  = 1  //是否允许将一个网络接口收到的数据包转发到另一个网络接口\n\nEOF\n\n# 应用 sysctl 参数而不重新启动\nsudo sysctl --system\n```\n\n* 安装1.26.2版本\n\n```shell\nsudo yum install -y kubelet-1.26.2-0 kubeadm-1.26.2-0 kubectl-1.26.2-0 --disableexcludes=kubernetes --nogpgcheck\n\nsystemctl daemon-reload\nsudo systemctl restart kubelet\nsudo systemctl enable kubelet\n```\n\n以上内容需要在节点和master机器全部运行一次\n\n----\n\n> master上执行\n\n```shell\nkubeadm init --image-repository=registry.aliyuncs.com/google_containers\n# 指定集群的IP\n# kubeadm init --image-repository=registry.aliyuncs.com/google_containers --apiserver-advertise-address=192.168.80.60\n\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n\n# 或者在环境变量中添加：export KUBECONFIG=/etc/kubernetes/admin.conf\n# 添加完环境变量后，刷新环境变量：source /etc/profile\n\nkubectl cluster-info\n\n# 初始化失败后，可进行重置，重置命令：kubeadm reset -\n\n# 执行成功后，会出现类似下列内容：\n# kubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n# --discovery-token-ca-cert-hash sha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107     \n\n# 查看join命令 \n# kubeadm token create --print-join-command\n```\n\n如果init失败，查看kubelet的运行日志\n\n```shell\njournalctl -xefu kubelet\n```\n\n> node上执行\n\n```shell\n# 运行的内容来自上方执行结果\nkubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n--discovery-token-ca-cert-hash sha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107 \n\n#\n# kubeadm token create --print-join-command\n\n# kubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n# --discovery-token-unsafe-skip-ca-verification\n```\n\n> 此时node还是not ready  pod 也没有正常运行，需要在master配置网络\n\n```shell\nyum install -y wget\nwget --no-check-certificate https://projectcalico.docs.tigera.io/archive/v3.25/manifests/calico.yaml\n```\n\n```shell\n# 修改 calico.yaml 文件\nvim calico.yaml\n```\n\n```shell\n# 在 - name: CLUSTER_TYPE 下方添加如下内容\n- name: CLUSTER_TYPE\n  value: \"k8s,bgp\"\n  # 下方为新增内容\n- name: IP_AUTODETECTION_METHOD\n  value: \"interface=网卡名称\"\n\n\n# INTERFACE_NAME=ens33\n# sed -i '/k8s,bgp/a \\            - name: IP_AUTODETECTION_METHOD\\n              value: \"interface=INTERFACE_NAME\"' calico.yaml\n# sed -i \"s#INTERFACE_NAME#$INTERFACE_NAME#g\" calico.yaml\n```\n\n```shell\n# 配置网络\nkubectl apply -f calico.yaml\n```\n\n之后等待网络配置完成\n\nk8s搭建成功\n\n---\n\n> kubeadm 有问题访问[对 kubeadm 进行故障排查 | Kubernetes](https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/)\n\n> 网络问题\n\n* node加入master之后get nodes 失败\n\n* ![](http://gohoy.top/i/2023/08/11/rd09c0-1.png)\n\n* master 显示该node notready\n\n* pods 网络问题 sandbox create failed\n  \n  * ![](http://gohoy.top/i/2023/08/11/rd0dze-1.png)\n  \n  * ![](http://gohoy.top/i/2023/08/11/rd0hum-1.png)\n\n* 主要问题：calico镜像pull缓慢或出错\n  \n  * ![](http://gohoy.top/i/2023/08/11/rd0od9-1.png)\n  \n  * ![](http://gohoy.top/i/2023/08/11/rd0n9o-1.png)\n  \n  * ![](http://gohoy.top/i/2023/08/11/rd182i-1.png)\n\n等了非常久 calico pull成功\n\n最后将containerd 源从\n\n`registry.cn-hangzhou.aliyuncs.com/google_containers/pause`\n\n换成\n\n`registry.aliyuncs.com/k8sxio/pause`\n\npull镜像可以成功了\n\n> 实践\n\n* 尝试搭建nginx\n\n* ```shell\n  cat > nginx.yaml << EOF\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    name: nginx-deployment\n    labels:\n      app: nginx\n  spec:\n    replicas: 2\n    selector:\n      matchLabels:\n        app: nginx\n    template:\n      metadata:\n        labels:\n          app: nginx\n      spec:\n        containers:\n        - name: nginx\n          image: nginx:1.23.2\n          ports:\n          - containerPort: 80\n  \n  EOF\n  \n  cat nginx.yaml\n  \n  # 创建deployment\n  kubectl apply -f nginx.yaml\n  ```\n\n* \n\n* pull 结束后\n\n* ```shell\n  # 控制面板：设置服务\n  kubectl expose deployment nginx-deployment --type=NodePort --name=nginx-service\n  # 或者\n  # kubectl create service nodeport nginx-service --tcp=80:80 --node-port=32767 --selector=app=nginx\n  ```\n\n* ```shell\n  # 控制面板：查看pod,svc\n  kubectl get pod,svc -o wide\n  ```\n\n* ![](http://gohoy.top/i/2023/08/11/rd1djq-1.png)\n\n* ![](http://gohoy.top/i/2023/08/11/rd1tb5-1.png)\n\n* 停止pods\n  \n  * 删除deployment\n","source":"_posts/CentOS安装K8S文档.md","raw":"---\ntitle: Centos7 安装 k8s\ncategories:\n - K8S\ntags:\n - Centos\n - K8S\n - 教程\n---\n\n# Centos7 安装 k8s 环境\n\n> 安装centos7虚拟机\n\n* Vmware 下载 mini 包[x86_64下载地址](http://mirrors.oit.uci.edu/centos/7.9.2009/isos/x86_64/)\n\n* 硬件至少 2G 2核\n\n> 初始配置虚拟机网络\n\n* 更改hostname\n  \n  * echo 'master' >> /etc/hostname\n\n* 更改静态ip\n  \n  * 打开 /etc/sysconfig/network-scripts/ifcfg-ens33  ，网卡名称有的使eth0 有的是ens33，使用 ip addr查看\n  \n  * 将 BOOTPROTO=dhcp 改为 static\n  \n  * 将ONBOOT=no 改为yes\n  \n  * 末尾加上你的配置\n    \n    ```shell\n    # /etc/sysconfig/network-scripts/ifcfg-ens33\n    IPADDR=192.168.111.201\n    \n    NETMASK=255.255.255.0\n    \n    GATEWAY=192.168.111.2\n    \n    DNS1=8.8.8.8\n    ```\n\n* /etc/hosts 加上 ip ：hostname\n  \n  ```shell\n  # /etc/hosts\n  192.168.111.200 master\n  \n  192.168.111.201 node1\n  \n  192.168.111.202 node2\n  ```\n\n* systemctl restart network \n\n* 使配置生效，此时能ping通外网\n\n> 使用vscode或其他应用连接虚拟机\n\n> 同步时间 补全命令\n\n* ```shell\n  sudo yum -y install ntpdate\n  sudo ntpdate ntp1.aliyun.com\n  sudo systemctl status ntpdate\n  sudo systemctl start ntpdate\n  sudo systemctl status ntpdate\n  sudo systemctl enable ntpdate\n  ```\n\n* ```shell\n  sudo yum -y install bash-completion\n  source /etc/profile\n  ```\n\n> 关闭防火墙 或者 开启防火墙端口\n\n* ```shell\n  sudo systemctl stop firewalld.service \n  sudo systemctl disable firewalld.service\n  ```\n\n* ```shell\n  # 控制面板\n  firewall-cmd --zone=public --add-port=6443/tcp --permanent # Kubernetes API server    所有\n  firewall-cmd --zone=public --add-port=2379/tcp --permanent # etcd server client API    kube-apiserver, etcd\n  firewall-cmd --zone=public --add-port=2380/tcp --permanent # etcd server client API    kube-apiserver, etcd\n  firewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API    自身, 控制面\n  firewall-cmd --zone=public --add-port=10259/tcp --permanent # kube-scheduler    自身\n  firewall-cmd --zone=public --add-port=10257/tcp --permanent # kube-controller-manager    自身\n  firewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各个节点的IP\n  firewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各个节点的IP\n  firewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各个节点的IP\n  firewall-cmd --add-masquerade --permanent # 端口转发\n  firewall-cmd --reload\n  firewall-cmd --list-all\n  firewall-cmd --list-all --zone=trusted\n  \n  # 工作节点\n  firewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API    自身, 控制面\n  firewall-cmd --zone=public --add-port=30000-32767/tcp --permanent # NodePort Services†    所有\n  firewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各个节点的IP\n  firewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各个节点的IP\n  firewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各个节点的IP\n  firewall-cmd --add-masquerade --permanent # 端口转发\n  firewall-cmd --reload\n  firewall-cmd --list-all\n  firewall-cmd --list-all --zone=trusted\n  ```\n\n> 关闭swap 和 selinux\n\n* ```shell\n  free -h  //查看是否关闭\n  sudo swapoff -a  //暂时关闭\n  sudo sed -i 's/.*swap.*/#&/' /etc/fstab //永久关闭\n  free -h\n  ```\n  \n  ```shell\n  getenforce\n  cat /etc/selinux/config\n  sudo setenforce 0\n  sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config\n  cat /etc/selinux/config\n  ```\n\n> 安装docker 和 containerd，1.24.0版本开始，k8s使用containerd代替docker\n\n* cgroup（control group）是 Linux 内核提供的一种机制，用于对进程进行资源限制、统计和控制。通过 cgroup，我们可以对一个或多个进程的 CPU、内存、IO、网络等资源进行限制，从而保证系统资源的合理分配，防止某些进程占用过多的资源导致系统崩溃或变慢。\n\n* ```shell\n  # https://docs.docker.com/engine/install/centos/\n  sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine\n  sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n  sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo \n  # yum --showduplicates list docker-ce\n  sudo yum install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin\n  sudo yum install -y containerd\n  \n  # 启动 docker 时，会启动 containerd\n  # sudo systemctl status containerd.service\n  sudo systemctl stop containerd.service\n  \n  # 设置containerd 的默认配置文件\n  sudo cp /etc/containerd/config.toml /etc/containerd/config.toml.bak\n  sudo containerd config default > $HOME/config.toml\n  sudo cp $HOME/config.toml /etc/containerd/config.toml\n  \n  # 对containerd 换源和设置cgroup的设置\n  sudo sed -i \"s#registry.k8s.io/pause#registry.aliyuncs.com/k8sxio/pause#g\" /etc/containerd/config.toml\n  # https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/#containerd-systemd\n  # 确保 /etc/containerd/config.toml 中的 disabled_plugins 内不存在 cri\n  sudo sed -i \"s#SystemdCgroup = false#SystemdCgroup = true#g\" /etc/containerd/config.toml\n  \n  # containerd 忽略证书验证的配置\n  #      [plugins.\"io.containerd.grpc.v1.cri\".registry.configs]\n  #        [plugins.\"io.containerd.grpc.v1.cri\".registry.configs.\"192.168.0.12:8001\".tls]\n  #          insecure_skip_verify = true\n  sudo systemctl enable --now containerd.service\n  \n  sudo systemctl start docker.service\n  ```\n\n```shell\nsudo systemctl enable docker.service\nsudo systemctl enable docker.socket\nsudo systemctl list-unit-files | grep docker\n\nsudo mkdir -p /etc/docker\n\n# 对docker换源和cgroup设置\ncat<<EOF | sudo tee /etc/docker/daemon.json \n {\n \"registry-mirrors\": [\"https://2u8f97e8.mirror.aliyuncs.com\"],\n \"exec-opts\": [\"native.cgroupdriver=systemd\"]\n }\nEOF\n\nsudo systemctl daemon-reload\nsudo systemctl restart docker\nsudo docker info\n\nsudo systemctl status docker.service\nsudo systemctl status containerd.service\n```\n\n> 安装k8s\n\n* 添加k8s 仓库\n\n```shell\ncat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\n# 是否开启本仓库\nenabled=1\n# 是否检查 gpg 签名文件\ngpgcheck=0\n# 是否检查 gpg 签名文件\nrepo_gpgcheck=0\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\n\nEOF\n```\n\n* 设置内核参数\n\n```shell\n# 设置所需的 sysctl 参数，参数在重新启动后保持不变\ncat <<EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-iptables  = 1 \nnet.bridge.bridge-nf-call-ip6tables = 1  //这两条让网络连接走iptables（禁用可以不设置）\nnet.ipv4.ip_forward  = 1  //是否允许将一个网络接口收到的数据包转发到另一个网络接口\n\nEOF\n\n# 应用 sysctl 参数而不重新启动\nsudo sysctl --system\n```\n\n* 安装1.26.2版本\n\n```shell\nsudo yum install -y kubelet-1.26.2-0 kubeadm-1.26.2-0 kubectl-1.26.2-0 --disableexcludes=kubernetes --nogpgcheck\n\nsystemctl daemon-reload\nsudo systemctl restart kubelet\nsudo systemctl enable kubelet\n```\n\n以上内容需要在节点和master机器全部运行一次\n\n----\n\n> master上执行\n\n```shell\nkubeadm init --image-repository=registry.aliyuncs.com/google_containers\n# 指定集群的IP\n# kubeadm init --image-repository=registry.aliyuncs.com/google_containers --apiserver-advertise-address=192.168.80.60\n\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n\n# 或者在环境变量中添加：export KUBECONFIG=/etc/kubernetes/admin.conf\n# 添加完环境变量后，刷新环境变量：source /etc/profile\n\nkubectl cluster-info\n\n# 初始化失败后，可进行重置，重置命令：kubeadm reset -\n\n# 执行成功后，会出现类似下列内容：\n# kubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n# --discovery-token-ca-cert-hash sha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107     \n\n# 查看join命令 \n# kubeadm token create --print-join-command\n```\n\n如果init失败，查看kubelet的运行日志\n\n```shell\njournalctl -xefu kubelet\n```\n\n> node上执行\n\n```shell\n# 运行的内容来自上方执行结果\nkubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n--discovery-token-ca-cert-hash sha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107 \n\n#\n# kubeadm token create --print-join-command\n\n# kubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n# --discovery-token-unsafe-skip-ca-verification\n```\n\n> 此时node还是not ready  pod 也没有正常运行，需要在master配置网络\n\n```shell\nyum install -y wget\nwget --no-check-certificate https://projectcalico.docs.tigera.io/archive/v3.25/manifests/calico.yaml\n```\n\n```shell\n# 修改 calico.yaml 文件\nvim calico.yaml\n```\n\n```shell\n# 在 - name: CLUSTER_TYPE 下方添加如下内容\n- name: CLUSTER_TYPE\n  value: \"k8s,bgp\"\n  # 下方为新增内容\n- name: IP_AUTODETECTION_METHOD\n  value: \"interface=网卡名称\"\n\n\n# INTERFACE_NAME=ens33\n# sed -i '/k8s,bgp/a \\            - name: IP_AUTODETECTION_METHOD\\n              value: \"interface=INTERFACE_NAME\"' calico.yaml\n# sed -i \"s#INTERFACE_NAME#$INTERFACE_NAME#g\" calico.yaml\n```\n\n```shell\n# 配置网络\nkubectl apply -f calico.yaml\n```\n\n之后等待网络配置完成\n\nk8s搭建成功\n\n---\n\n> kubeadm 有问题访问[对 kubeadm 进行故障排查 | Kubernetes](https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/)\n\n> 网络问题\n\n* node加入master之后get nodes 失败\n\n* ![](http://gohoy.top/i/2023/08/11/rd09c0-1.png)\n\n* master 显示该node notready\n\n* pods 网络问题 sandbox create failed\n  \n  * ![](http://gohoy.top/i/2023/08/11/rd0dze-1.png)\n  \n  * ![](http://gohoy.top/i/2023/08/11/rd0hum-1.png)\n\n* 主要问题：calico镜像pull缓慢或出错\n  \n  * ![](http://gohoy.top/i/2023/08/11/rd0od9-1.png)\n  \n  * ![](http://gohoy.top/i/2023/08/11/rd0n9o-1.png)\n  \n  * ![](http://gohoy.top/i/2023/08/11/rd182i-1.png)\n\n等了非常久 calico pull成功\n\n最后将containerd 源从\n\n`registry.cn-hangzhou.aliyuncs.com/google_containers/pause`\n\n换成\n\n`registry.aliyuncs.com/k8sxio/pause`\n\npull镜像可以成功了\n\n> 实践\n\n* 尝试搭建nginx\n\n* ```shell\n  cat > nginx.yaml << EOF\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    name: nginx-deployment\n    labels:\n      app: nginx\n  spec:\n    replicas: 2\n    selector:\n      matchLabels:\n        app: nginx\n    template:\n      metadata:\n        labels:\n          app: nginx\n      spec:\n        containers:\n        - name: nginx\n          image: nginx:1.23.2\n          ports:\n          - containerPort: 80\n  \n  EOF\n  \n  cat nginx.yaml\n  \n  # 创建deployment\n  kubectl apply -f nginx.yaml\n  ```\n\n* \n\n* pull 结束后\n\n* ```shell\n  # 控制面板：设置服务\n  kubectl expose deployment nginx-deployment --type=NodePort --name=nginx-service\n  # 或者\n  # kubectl create service nodeport nginx-service --tcp=80:80 --node-port=32767 --selector=app=nginx\n  ```\n\n* ```shell\n  # 控制面板：查看pod,svc\n  kubectl get pod,svc -o wide\n  ```\n\n* ![](http://gohoy.top/i/2023/08/11/rd1djq-1.png)\n\n* ![](http://gohoy.top/i/2023/08/11/rd1tb5-1.png)\n\n* 停止pods\n  \n  * 删除deployment\n","slug":"CentOS安装K8S文档","published":1,"date":"2023-08-30T06:25:32.720Z","updated":"2023-09-11T13:37:04.460Z","_id":"cllyxpks5000014gf6j1b5r6j","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Centos7-安装-k8s-环境\"><a href=\"#Centos7-安装-k8s-环境\" class=\"headerlink\" title=\"Centos7 安装 k8s 环境\"></a>Centos7 安装 k8s 环境</h1><blockquote>\n<p>安装centos7虚拟机</p>\n</blockquote>\n<ul>\n<li><p>Vmware 下载 mini 包<a href=\"http://mirrors.oit.uci.edu/centos/7.9.2009/isos/x86_64/\">x86_64下载地址</a></p>\n</li>\n<li><p>硬件至少 2G 2核</p>\n</li>\n</ul>\n<blockquote>\n<p>初始配置虚拟机网络</p>\n</blockquote>\n<ul>\n<li><p>更改hostname</p>\n<ul>\n<li>echo ‘master’ &gt;&gt; &#x2F;etc&#x2F;hostname</li>\n</ul>\n</li>\n<li><p>更改静态ip</p>\n<ul>\n<li><p>打开 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33  ，网卡名称有的使eth0 有的是ens33，使用 ip addr查看</p>\n</li>\n<li><p>将 BOOTPROTO&#x3D;dhcp 改为 static</p>\n</li>\n<li><p>将ONBOOT&#x3D;no 改为yes</p>\n</li>\n<li><p>末尾加上你的配置</p>\n<pre><code class=\"shell\"># /etc/sysconfig/network-scripts/ifcfg-ens33\nIPADDR=192.168.111.201\n\nNETMASK=255.255.255.0\n\nGATEWAY=192.168.111.2\n\nDNS1=8.8.8.8\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>&#x2F;etc&#x2F;hosts 加上 ip ：hostname</p>\n<pre><code class=\"shell\"># /etc/hosts\n192.168.111.200 master\n\n192.168.111.201 node1\n\n192.168.111.202 node2\n</code></pre>\n</li>\n<li><p>systemctl restart network </p>\n</li>\n<li><p>使配置生效，此时能ping通外网</p>\n</li>\n</ul>\n<blockquote>\n<p>使用vscode或其他应用连接虚拟机</p>\n</blockquote>\n<blockquote>\n<p>同步时间 补全命令</p>\n</blockquote>\n<ul>\n<li><pre><code class=\"shell\">sudo yum -y install ntpdate\nsudo ntpdate ntp1.aliyun.com\nsudo systemctl status ntpdate\nsudo systemctl start ntpdate\nsudo systemctl status ntpdate\nsudo systemctl enable ntpdate\n</code></pre>\n</li>\n<li><pre><code class=\"shell\">sudo yum -y install bash-completion\nsource /etc/profile\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>关闭防火墙 或者 开启防火墙端口</p>\n</blockquote>\n<ul>\n<li><pre><code class=\"shell\">sudo systemctl stop firewalld.service \nsudo systemctl disable firewalld.service\n</code></pre>\n</li>\n<li><pre><code class=\"shell\"># 控制面板\nfirewall-cmd --zone=public --add-port=6443/tcp --permanent # Kubernetes API server    所有\nfirewall-cmd --zone=public --add-port=2379/tcp --permanent # etcd server client API    kube-apiserver, etcd\nfirewall-cmd --zone=public --add-port=2380/tcp --permanent # etcd server client API    kube-apiserver, etcd\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API    自身, 控制面\nfirewall-cmd --zone=public --add-port=10259/tcp --permanent # kube-scheduler    自身\nfirewall-cmd --zone=public --add-port=10257/tcp --permanent # kube-controller-manager    自身\nfirewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各个节点的IP\nfirewall-cmd --add-masquerade --permanent # 端口转发\nfirewall-cmd --reload\nfirewall-cmd --list-all\nfirewall-cmd --list-all --zone=trusted\n\n# 工作节点\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API    自身, 控制面\nfirewall-cmd --zone=public --add-port=30000-32767/tcp --permanent # NodePort Services†    所有\nfirewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各个节点的IP\nfirewall-cmd --add-masquerade --permanent # 端口转发\nfirewall-cmd --reload\nfirewall-cmd --list-all\nfirewall-cmd --list-all --zone=trusted\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>关闭swap 和 selinux</p>\n</blockquote>\n<ul>\n<li><pre><code class=\"shell\">free -h  //查看是否关闭\nsudo swapoff -a  //暂时关闭\nsudo sed -i &#39;s/.*swap.*/#&amp;/&#39; /etc/fstab //永久关闭\nfree -h\n</code></pre>\n<pre><code class=\"shell\">getenforce\ncat /etc/selinux/config\nsudo setenforce 0\nsudo sed -i &#39;s/^SELINUX=enforcing$/SELINUX=permissive/&#39; /etc/selinux/config\ncat /etc/selinux/config\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>安装docker 和 containerd，1.24.0版本开始，k8s使用containerd代替docker</p>\n</blockquote>\n<ul>\n<li><p>cgroup（control group）是 Linux 内核提供的一种机制，用于对进程进行资源限制、统计和控制。通过 cgroup，我们可以对一个或多个进程的 CPU、内存、IO、网络等资源进行限制，从而保证系统资源的合理分配，防止某些进程占用过多的资源导致系统崩溃或变慢。</p>\n</li>\n<li><pre><code class=\"shell\"># https://docs.docker.com/engine/install/centos/\nsudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine\nsudo yum install -y yum-utils device-mapper-persistent-data lvm2\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo \n# yum --showduplicates list docker-ce\nsudo yum install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin\nsudo yum install -y containerd\n\n# 启动 docker 时，会启动 containerd\n# sudo systemctl status containerd.service\nsudo systemctl stop containerd.service\n\n# 设置containerd 的默认配置文件\nsudo cp /etc/containerd/config.toml /etc/containerd/config.toml.bak\nsudo containerd config default &gt; $HOME/config.toml\nsudo cp $HOME/config.toml /etc/containerd/config.toml\n\n# 对containerd 换源和设置cgroup的设置\nsudo sed -i &quot;s#registry.k8s.io/pause#registry.aliyuncs.com/k8sxio/pause#g&quot; /etc/containerd/config.toml\n# https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/#containerd-systemd\n# 确保 /etc/containerd/config.toml 中的 disabled_plugins 内不存在 cri\nsudo sed -i &quot;s#SystemdCgroup = false#SystemdCgroup = true#g&quot; /etc/containerd/config.toml\n\n# containerd 忽略证书验证的配置\n#      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs]\n#        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs.&quot;192.168.0.12:8001&quot;.tls]\n#          insecure_skip_verify = true\nsudo systemctl enable --now containerd.service\n\nsudo systemctl start docker.service\n</code></pre>\n</li>\n</ul>\n<pre><code class=\"shell\">sudo systemctl enable docker.service\nsudo systemctl enable docker.socket\nsudo systemctl list-unit-files | grep docker\n\nsudo mkdir -p /etc/docker\n\n# 对docker换源和cgroup设置\ncat&lt;&lt;EOF | sudo tee /etc/docker/daemon.json \n &#123;\n &quot;registry-mirrors&quot;: [&quot;https://2u8f97e8.mirror.aliyuncs.com&quot;],\n &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]\n &#125;\nEOF\n\nsudo systemctl daemon-reload\nsudo systemctl restart docker\nsudo docker info\n\nsudo systemctl status docker.service\nsudo systemctl status containerd.service\n</code></pre>\n<blockquote>\n<p>安装k8s</p>\n</blockquote>\n<ul>\n<li>添加k8s 仓库</li>\n</ul>\n<pre><code class=\"shell\">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\n# 是否开启本仓库\nenabled=1\n# 是否检查 gpg 签名文件\ngpgcheck=0\n# 是否检查 gpg 签名文件\nrepo_gpgcheck=0\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\n\nEOF\n</code></pre>\n<ul>\n<li>设置内核参数</li>\n</ul>\n<pre><code class=\"shell\"># 设置所需的 sysctl 参数，参数在重新启动后保持不变\ncat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-iptables  = 1 \nnet.bridge.bridge-nf-call-ip6tables = 1  //这两条让网络连接走iptables（禁用可以不设置）\nnet.ipv4.ip_forward  = 1  //是否允许将一个网络接口收到的数据包转发到另一个网络接口\n\nEOF\n\n# 应用 sysctl 参数而不重新启动\nsudo sysctl --system\n</code></pre>\n<ul>\n<li>安装1.26.2版本</li>\n</ul>\n<pre><code class=\"shell\">sudo yum install -y kubelet-1.26.2-0 kubeadm-1.26.2-0 kubectl-1.26.2-0 --disableexcludes=kubernetes --nogpgcheck\n\nsystemctl daemon-reload\nsudo systemctl restart kubelet\nsudo systemctl enable kubelet\n</code></pre>\n<p>以上内容需要在节点和master机器全部运行一次</p>\n<hr>\n<blockquote>\n<p>master上执行</p>\n</blockquote>\n<pre><code class=\"shell\">kubeadm init --image-repository=registry.aliyuncs.com/google_containers\n# 指定集群的IP\n# kubeadm init --image-repository=registry.aliyuncs.com/google_containers --apiserver-advertise-address=192.168.80.60\n\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n\n# 或者在环境变量中添加：export KUBECONFIG=/etc/kubernetes/admin.conf\n# 添加完环境变量后，刷新环境变量：source /etc/profile\n\nkubectl cluster-info\n\n# 初始化失败后，可进行重置，重置命令：kubeadm reset -\n\n# 执行成功后，会出现类似下列内容：\n# kubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n# --discovery-token-ca-cert-hash sha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107     \n\n# 查看join命令 \n# kubeadm token create --print-join-command\n</code></pre>\n<p>如果init失败，查看kubelet的运行日志</p>\n<pre><code class=\"shell\">journalctl -xefu kubelet\n</code></pre>\n<blockquote>\n<p>node上执行</p>\n</blockquote>\n<pre><code class=\"shell\"># 运行的内容来自上方执行结果\nkubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n--discovery-token-ca-cert-hash sha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107 \n\n#\n# kubeadm token create --print-join-command\n\n# kubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n# --discovery-token-unsafe-skip-ca-verification\n</code></pre>\n<blockquote>\n<p>此时node还是not ready  pod 也没有正常运行，需要在master配置网络</p>\n</blockquote>\n<pre><code class=\"shell\">yum install -y wget\nwget --no-check-certificate https://projectcalico.docs.tigera.io/archive/v3.25/manifests/calico.yaml\n</code></pre>\n<pre><code class=\"shell\"># 修改 calico.yaml 文件\nvim calico.yaml\n</code></pre>\n<pre><code class=\"shell\"># 在 - name: CLUSTER_TYPE 下方添加如下内容\n- name: CLUSTER_TYPE\n  value: &quot;k8s,bgp&quot;\n  # 下方为新增内容\n- name: IP_AUTODETECTION_METHOD\n  value: &quot;interface=网卡名称&quot;\n\n\n# INTERFACE_NAME=ens33\n# sed -i &#39;/k8s,bgp/a \\            - name: IP_AUTODETECTION_METHOD\\n              value: &quot;interface=INTERFACE_NAME&quot;&#39; calico.yaml\n# sed -i &quot;s#INTERFACE_NAME#$INTERFACE_NAME#g&quot; calico.yaml\n</code></pre>\n<pre><code class=\"shell\"># 配置网络\nkubectl apply -f calico.yaml\n</code></pre>\n<p>之后等待网络配置完成</p>\n<p>k8s搭建成功</p>\n<hr>\n<blockquote>\n<p>kubeadm 有问题访问<a href=\"https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/\">对 kubeadm 进行故障排查 | Kubernetes</a></p>\n</blockquote>\n<blockquote>\n<p>网络问题</p>\n</blockquote>\n<ul>\n<li><p>node加入master之后get nodes 失败</p>\n</li>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd09c0-1.png\"></p>\n</li>\n<li><p>master 显示该node notready</p>\n</li>\n<li><p>pods 网络问题 sandbox create failed</p>\n<ul>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd0dze-1.png\"></p>\n</li>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd0hum-1.png\"></p>\n</li>\n</ul>\n</li>\n<li><p>主要问题：calico镜像pull缓慢或出错</p>\n<ul>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd0od9-1.png\"></p>\n</li>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd0n9o-1.png\"></p>\n</li>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd182i-1.png\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>等了非常久 calico pull成功</p>\n<p>最后将containerd 源从</p>\n<p><code>registry.cn-hangzhou.aliyuncs.com/google_containers/pause</code></p>\n<p>换成</p>\n<p><code>registry.aliyuncs.com/k8sxio/pause</code></p>\n<p>pull镜像可以成功了</p>\n<blockquote>\n<p>实践</p>\n</blockquote>\n<ul>\n<li><p>尝试搭建nginx</p>\n</li>\n<li><pre><code class=\"shell\">cat &gt; nginx.yaml &lt;&lt; EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  labels:\n    app: nginx\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.23.2\n        ports:\n        - containerPort: 80\n\nEOF\n\ncat nginx.yaml\n\n# 创建deployment\nkubectl apply -f nginx.yaml\n</code></pre>\n</li>\n<li></li>\n<li><p>pull 结束后</p>\n</li>\n<li><pre><code class=\"shell\"># 控制面板：设置服务\nkubectl expose deployment nginx-deployment --type=NodePort --name=nginx-service\n# 或者\n# kubectl create service nodeport nginx-service --tcp=80:80 --node-port=32767 --selector=app=nginx\n</code></pre>\n</li>\n<li><pre><code class=\"shell\"># 控制面板：查看pod,svc\nkubectl get pod,svc -o wide\n</code></pre>\n</li>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd1djq-1.png\"></p>\n</li>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd1tb5-1.png\"></p>\n</li>\n<li><p>停止pods</p>\n<ul>\n<li>删除deployment</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Centos7-安装-k8s-环境\"><a href=\"#Centos7-安装-k8s-环境\" class=\"headerlink\" title=\"Centos7 安装 k8s 环境\"></a>Centos7 安装 k8s 环境</h1><blockquote>\n<p>安装centos7虚拟机</p>\n</blockquote>\n<ul>\n<li><p>Vmware 下载 mini 包<a href=\"http://mirrors.oit.uci.edu/centos/7.9.2009/isos/x86_64/\">x86_64下载地址</a></p>\n</li>\n<li><p>硬件至少 2G 2核</p>\n</li>\n</ul>\n<blockquote>\n<p>初始配置虚拟机网络</p>\n</blockquote>\n<ul>\n<li><p>更改hostname</p>\n<ul>\n<li>echo ‘master’ &gt;&gt; &#x2F;etc&#x2F;hostname</li>\n</ul>\n</li>\n<li><p>更改静态ip</p>\n<ul>\n<li><p>打开 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33  ，网卡名称有的使eth0 有的是ens33，使用 ip addr查看</p>\n</li>\n<li><p>将 BOOTPROTO&#x3D;dhcp 改为 static</p>\n</li>\n<li><p>将ONBOOT&#x3D;no 改为yes</p>\n</li>\n<li><p>末尾加上你的配置</p>\n<pre><code class=\"shell\"># /etc/sysconfig/network-scripts/ifcfg-ens33\nIPADDR=192.168.111.201\n\nNETMASK=255.255.255.0\n\nGATEWAY=192.168.111.2\n\nDNS1=8.8.8.8\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>&#x2F;etc&#x2F;hosts 加上 ip ：hostname</p>\n<pre><code class=\"shell\"># /etc/hosts\n192.168.111.200 master\n\n192.168.111.201 node1\n\n192.168.111.202 node2\n</code></pre>\n</li>\n<li><p>systemctl restart network </p>\n</li>\n<li><p>使配置生效，此时能ping通外网</p>\n</li>\n</ul>\n<blockquote>\n<p>使用vscode或其他应用连接虚拟机</p>\n</blockquote>\n<blockquote>\n<p>同步时间 补全命令</p>\n</blockquote>\n<ul>\n<li><pre><code class=\"shell\">sudo yum -y install ntpdate\nsudo ntpdate ntp1.aliyun.com\nsudo systemctl status ntpdate\nsudo systemctl start ntpdate\nsudo systemctl status ntpdate\nsudo systemctl enable ntpdate\n</code></pre>\n</li>\n<li><pre><code class=\"shell\">sudo yum -y install bash-completion\nsource /etc/profile\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>关闭防火墙 或者 开启防火墙端口</p>\n</blockquote>\n<ul>\n<li><pre><code class=\"shell\">sudo systemctl stop firewalld.service \nsudo systemctl disable firewalld.service\n</code></pre>\n</li>\n<li><pre><code class=\"shell\"># 控制面板\nfirewall-cmd --zone=public --add-port=6443/tcp --permanent # Kubernetes API server    所有\nfirewall-cmd --zone=public --add-port=2379/tcp --permanent # etcd server client API    kube-apiserver, etcd\nfirewall-cmd --zone=public --add-port=2380/tcp --permanent # etcd server client API    kube-apiserver, etcd\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API    自身, 控制面\nfirewall-cmd --zone=public --add-port=10259/tcp --permanent # kube-scheduler    自身\nfirewall-cmd --zone=public --add-port=10257/tcp --permanent # kube-controller-manager    自身\nfirewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各个节点的IP\nfirewall-cmd --add-masquerade --permanent # 端口转发\nfirewall-cmd --reload\nfirewall-cmd --list-all\nfirewall-cmd --list-all --zone=trusted\n\n# 工作节点\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API    自身, 控制面\nfirewall-cmd --zone=public --add-port=30000-32767/tcp --permanent # NodePort Services†    所有\nfirewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各个节点的IP\nfirewall-cmd --add-masquerade --permanent # 端口转发\nfirewall-cmd --reload\nfirewall-cmd --list-all\nfirewall-cmd --list-all --zone=trusted\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>关闭swap 和 selinux</p>\n</blockquote>\n<ul>\n<li><pre><code class=\"shell\">free -h  //查看是否关闭\nsudo swapoff -a  //暂时关闭\nsudo sed -i &#39;s/.*swap.*/#&amp;/&#39; /etc/fstab //永久关闭\nfree -h\n</code></pre>\n<pre><code class=\"shell\">getenforce\ncat /etc/selinux/config\nsudo setenforce 0\nsudo sed -i &#39;s/^SELINUX=enforcing$/SELINUX=permissive/&#39; /etc/selinux/config\ncat /etc/selinux/config\n</code></pre>\n</li>\n</ul>\n<blockquote>\n<p>安装docker 和 containerd，1.24.0版本开始，k8s使用containerd代替docker</p>\n</blockquote>\n<ul>\n<li><p>cgroup（control group）是 Linux 内核提供的一种机制，用于对进程进行资源限制、统计和控制。通过 cgroup，我们可以对一个或多个进程的 CPU、内存、IO、网络等资源进行限制，从而保证系统资源的合理分配，防止某些进程占用过多的资源导致系统崩溃或变慢。</p>\n</li>\n<li><pre><code class=\"shell\"># https://docs.docker.com/engine/install/centos/\nsudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine\nsudo yum install -y yum-utils device-mapper-persistent-data lvm2\nsudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo \n# yum --showduplicates list docker-ce\nsudo yum install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin\nsudo yum install -y containerd\n\n# 启动 docker 时，会启动 containerd\n# sudo systemctl status containerd.service\nsudo systemctl stop containerd.service\n\n# 设置containerd 的默认配置文件\nsudo cp /etc/containerd/config.toml /etc/containerd/config.toml.bak\nsudo containerd config default &gt; $HOME/config.toml\nsudo cp $HOME/config.toml /etc/containerd/config.toml\n\n# 对containerd 换源和设置cgroup的设置\nsudo sed -i &quot;s#registry.k8s.io/pause#registry.aliyuncs.com/k8sxio/pause#g&quot; /etc/containerd/config.toml\n# https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/#containerd-systemd\n# 确保 /etc/containerd/config.toml 中的 disabled_plugins 内不存在 cri\nsudo sed -i &quot;s#SystemdCgroup = false#SystemdCgroup = true#g&quot; /etc/containerd/config.toml\n\n# containerd 忽略证书验证的配置\n#      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs]\n#        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.configs.&quot;192.168.0.12:8001&quot;.tls]\n#          insecure_skip_verify = true\nsudo systemctl enable --now containerd.service\n\nsudo systemctl start docker.service\n</code></pre>\n</li>\n</ul>\n<pre><code class=\"shell\">sudo systemctl enable docker.service\nsudo systemctl enable docker.socket\nsudo systemctl list-unit-files | grep docker\n\nsudo mkdir -p /etc/docker\n\n# 对docker换源和cgroup设置\ncat&lt;&lt;EOF | sudo tee /etc/docker/daemon.json \n &#123;\n &quot;registry-mirrors&quot;: [&quot;https://2u8f97e8.mirror.aliyuncs.com&quot;],\n &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]\n &#125;\nEOF\n\nsudo systemctl daemon-reload\nsudo systemctl restart docker\nsudo docker info\n\nsudo systemctl status docker.service\nsudo systemctl status containerd.service\n</code></pre>\n<blockquote>\n<p>安装k8s</p>\n</blockquote>\n<ul>\n<li>添加k8s 仓库</li>\n</ul>\n<pre><code class=\"shell\">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\n# 是否开启本仓库\nenabled=1\n# 是否检查 gpg 签名文件\ngpgcheck=0\n# 是否检查 gpg 签名文件\nrepo_gpgcheck=0\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\n\nEOF\n</code></pre>\n<ul>\n<li>设置内核参数</li>\n</ul>\n<pre><code class=\"shell\"># 设置所需的 sysctl 参数，参数在重新启动后保持不变\ncat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-iptables  = 1 \nnet.bridge.bridge-nf-call-ip6tables = 1  //这两条让网络连接走iptables（禁用可以不设置）\nnet.ipv4.ip_forward  = 1  //是否允许将一个网络接口收到的数据包转发到另一个网络接口\n\nEOF\n\n# 应用 sysctl 参数而不重新启动\nsudo sysctl --system\n</code></pre>\n<ul>\n<li>安装1.26.2版本</li>\n</ul>\n<pre><code class=\"shell\">sudo yum install -y kubelet-1.26.2-0 kubeadm-1.26.2-0 kubectl-1.26.2-0 --disableexcludes=kubernetes --nogpgcheck\n\nsystemctl daemon-reload\nsudo systemctl restart kubelet\nsudo systemctl enable kubelet\n</code></pre>\n<p>以上内容需要在节点和master机器全部运行一次</p>\n<hr>\n<blockquote>\n<p>master上执行</p>\n</blockquote>\n<pre><code class=\"shell\">kubeadm init --image-repository=registry.aliyuncs.com/google_containers\n# 指定集群的IP\n# kubeadm init --image-repository=registry.aliyuncs.com/google_containers --apiserver-advertise-address=192.168.80.60\n\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n\n# 或者在环境变量中添加：export KUBECONFIG=/etc/kubernetes/admin.conf\n# 添加完环境变量后，刷新环境变量：source /etc/profile\n\nkubectl cluster-info\n\n# 初始化失败后，可进行重置，重置命令：kubeadm reset -\n\n# 执行成功后，会出现类似下列内容：\n# kubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n# --discovery-token-ca-cert-hash sha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107     \n\n# 查看join命令 \n# kubeadm token create --print-join-command\n</code></pre>\n<p>如果init失败，查看kubelet的运行日志</p>\n<pre><code class=\"shell\">journalctl -xefu kubelet\n</code></pre>\n<blockquote>\n<p>node上执行</p>\n</blockquote>\n<pre><code class=\"shell\"># 运行的内容来自上方执行结果\nkubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n--discovery-token-ca-cert-hash sha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107 \n\n#\n# kubeadm token create --print-join-command\n\n# kubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n# --discovery-token-unsafe-skip-ca-verification\n</code></pre>\n<blockquote>\n<p>此时node还是not ready  pod 也没有正常运行，需要在master配置网络</p>\n</blockquote>\n<pre><code class=\"shell\">yum install -y wget\nwget --no-check-certificate https://projectcalico.docs.tigera.io/archive/v3.25/manifests/calico.yaml\n</code></pre>\n<pre><code class=\"shell\"># 修改 calico.yaml 文件\nvim calico.yaml\n</code></pre>\n<pre><code class=\"shell\"># 在 - name: CLUSTER_TYPE 下方添加如下内容\n- name: CLUSTER_TYPE\n  value: &quot;k8s,bgp&quot;\n  # 下方为新增内容\n- name: IP_AUTODETECTION_METHOD\n  value: &quot;interface=网卡名称&quot;\n\n\n# INTERFACE_NAME=ens33\n# sed -i &#39;/k8s,bgp/a \\            - name: IP_AUTODETECTION_METHOD\\n              value: &quot;interface=INTERFACE_NAME&quot;&#39; calico.yaml\n# sed -i &quot;s#INTERFACE_NAME#$INTERFACE_NAME#g&quot; calico.yaml\n</code></pre>\n<pre><code class=\"shell\"># 配置网络\nkubectl apply -f calico.yaml\n</code></pre>\n<p>之后等待网络配置完成</p>\n<p>k8s搭建成功</p>\n<hr>\n<blockquote>\n<p>kubeadm 有问题访问<a href=\"https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/\">对 kubeadm 进行故障排查 | Kubernetes</a></p>\n</blockquote>\n<blockquote>\n<p>网络问题</p>\n</blockquote>\n<ul>\n<li><p>node加入master之后get nodes 失败</p>\n</li>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd09c0-1.png\"></p>\n</li>\n<li><p>master 显示该node notready</p>\n</li>\n<li><p>pods 网络问题 sandbox create failed</p>\n<ul>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd0dze-1.png\"></p>\n</li>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd0hum-1.png\"></p>\n</li>\n</ul>\n</li>\n<li><p>主要问题：calico镜像pull缓慢或出错</p>\n<ul>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd0od9-1.png\"></p>\n</li>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd0n9o-1.png\"></p>\n</li>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd182i-1.png\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>等了非常久 calico pull成功</p>\n<p>最后将containerd 源从</p>\n<p><code>registry.cn-hangzhou.aliyuncs.com/google_containers/pause</code></p>\n<p>换成</p>\n<p><code>registry.aliyuncs.com/k8sxio/pause</code></p>\n<p>pull镜像可以成功了</p>\n<blockquote>\n<p>实践</p>\n</blockquote>\n<ul>\n<li><p>尝试搭建nginx</p>\n</li>\n<li><pre><code class=\"shell\">cat &gt; nginx.yaml &lt;&lt; EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  labels:\n    app: nginx\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.23.2\n        ports:\n        - containerPort: 80\n\nEOF\n\ncat nginx.yaml\n\n# 创建deployment\nkubectl apply -f nginx.yaml\n</code></pre>\n</li>\n<li></li>\n<li><p>pull 结束后</p>\n</li>\n<li><pre><code class=\"shell\"># 控制面板：设置服务\nkubectl expose deployment nginx-deployment --type=NodePort --name=nginx-service\n# 或者\n# kubectl create service nodeport nginx-service --tcp=80:80 --node-port=32767 --selector=app=nginx\n</code></pre>\n</li>\n<li><pre><code class=\"shell\"># 控制面板：查看pod,svc\nkubectl get pod,svc -o wide\n</code></pre>\n</li>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd1djq-1.png\"></p>\n</li>\n<li><p><img src=\"http://gohoy.top/i/2023/08/11/rd1tb5-1.png\"></p>\n</li>\n<li><p>停止pods</p>\n<ul>\n<li>删除deployment</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Lemon吉他谱","_content":"\n![](http://gohoy.top/i/2023/08/11/rg1mao-1.png)\n\n![](http://gohoy.top/i/2023/08/11/rg1u4q-1.png)\n\n![](http://gohoy.top/i/2023/08/11/rg2c1u-1.png)\n\n![](http://gohoy.top/i/2023/08/11/rg2dne-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s4504d-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s45lra-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s45vxo-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s46ii9-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s46oqe-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s473op-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s47b68-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s481z7-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s48870-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s48ftk-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s48yg2-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s493cp-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s49c6n-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s49oq9-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s4a0zu-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s4an4w-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s4aul9-1.png)\n","source":"_posts/Lemon吉他谱.md","raw":"---\ntitle: Lemon吉他谱\ncategory: 吉他谱\ntag: \n - 吉他谱\n---\n\n![](http://gohoy.top/i/2023/08/11/rg1mao-1.png)\n\n![](http://gohoy.top/i/2023/08/11/rg1u4q-1.png)\n\n![](http://gohoy.top/i/2023/08/11/rg2c1u-1.png)\n\n![](http://gohoy.top/i/2023/08/11/rg2dne-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s4504d-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s45lra-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s45vxo-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s46ii9-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s46oqe-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s473op-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s47b68-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s481z7-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s48870-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s48ftk-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s48yg2-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s493cp-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s49c6n-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s49oq9-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s4a0zu-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s4an4w-1.png)\n\n![](http://gohoy.top/i/2023/08/11/s4aul9-1.png)\n","slug":"Lemon吉他谱","published":1,"date":"2023-08-30T06:28:51.559Z","updated":"2023-08-30T06:31:55.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllyxpksb000114gf2axi19fe","content":"<p><img src=\"http://gohoy.top/i/2023/08/11/rg1mao-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/rg1u4q-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/rg2c1u-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/rg2dne-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s4504d-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s45lra-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s45vxo-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s46ii9-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s46oqe-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s473op-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s47b68-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s481z7-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s48870-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s48ftk-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s48yg2-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s493cp-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s49c6n-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s49oq9-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s4a0zu-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s4an4w-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s4aul9-1.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://gohoy.top/i/2023/08/11/rg1mao-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/rg1u4q-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/rg2c1u-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/rg2dne-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s4504d-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s45lra-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s45vxo-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s46ii9-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s46oqe-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s473op-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s47b68-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s481z7-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s48870-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s48ftk-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s48yg2-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s493cp-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s49c6n-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s49oq9-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s4a0zu-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s4an4w-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/s4aul9-1.png\"></p>\n"},{"title":"Mydisk项目说明","_content":"\n# Mydisk项目说明\n\n## 前台方法（controller）\n\n### minioController：文件的上传、下载、获取等\n\n* 上传文件：uploadFile: public ResultType uploadFile(@RequestParam String fileName, @RequestParam(\"file\") MultipartFile file)\n  \n  * fileName 文件名称\n  \n  * MultipartFile file 文件本身\n  \n  * 思路：根据文件的分类存在不同的bucket和不同路径下。 \n\n* 获取全部文件：getFiles：public ResultType getFiles(@PathVariable(value = \"prefix\", required = false) String prefix)\n  \n  * prefix：前缀，可以使用这个来获取某一文件夹下的文件，但是目前这个功能是由前端直接实现的。\n  \n  * 思路：提供给前端所有存在的文件，支持根据prefix来分类获取。且使用 redis进行缓存。\n  \n  * getBucketFiles(MinioClient minioClient, String bucketName, String prefix)\n    \n    * 这是工具函数，用于把文件名进行递归拼接，可以直接返回给前端构建好的列表\n\n* 获取预览/下载链接：public ResultType getFileUrl(@PathVariable(\"fileName\")String fileName)\n  \n  * fileName：文件名称，需要包含其路径。\n  \n  * 思路：在后端返回一个可以直接被get的链接，前端模拟点击，可以被预览的文件，如图片视频将在浏览器上直接预览，其他文件将下载。\n\n### TypeController：文件分类的管理\n\n","source":"_posts/Mydisk项目源码说明文档.md","raw":"---\ntitle: Mydisk项目说明\ncategory: 设计文档\ntag: \n - 设计文档\n - Mydisk\n---\n\n# Mydisk项目说明\n\n## 前台方法（controller）\n\n### minioController：文件的上传、下载、获取等\n\n* 上传文件：uploadFile: public ResultType uploadFile(@RequestParam String fileName, @RequestParam(\"file\") MultipartFile file)\n  \n  * fileName 文件名称\n  \n  * MultipartFile file 文件本身\n  \n  * 思路：根据文件的分类存在不同的bucket和不同路径下。 \n\n* 获取全部文件：getFiles：public ResultType getFiles(@PathVariable(value = \"prefix\", required = false) String prefix)\n  \n  * prefix：前缀，可以使用这个来获取某一文件夹下的文件，但是目前这个功能是由前端直接实现的。\n  \n  * 思路：提供给前端所有存在的文件，支持根据prefix来分类获取。且使用 redis进行缓存。\n  \n  * getBucketFiles(MinioClient minioClient, String bucketName, String prefix)\n    \n    * 这是工具函数，用于把文件名进行递归拼接，可以直接返回给前端构建好的列表\n\n* 获取预览/下载链接：public ResultType getFileUrl(@PathVariable(\"fileName\")String fileName)\n  \n  * fileName：文件名称，需要包含其路径。\n  \n  * 思路：在后端返回一个可以直接被get的链接，前端模拟点击，可以被预览的文件，如图片视频将在浏览器上直接预览，其他文件将下载。\n\n### TypeController：文件分类的管理\n\n","slug":"Mydisk项目源码说明文档","published":1,"date":"2023-08-30T06:28:51.561Z","updated":"2023-09-11T13:33:26.266Z","_id":"cllyxpkse000414gf745vd6my","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Mydisk项目说明\"><a href=\"#Mydisk项目说明\" class=\"headerlink\" title=\"Mydisk项目说明\"></a>Mydisk项目说明</h1><h2 id=\"前台方法（controller）\"><a href=\"#前台方法（controller）\" class=\"headerlink\" title=\"前台方法（controller）\"></a>前台方法（controller）</h2><h3 id=\"minioController：文件的上传、下载、获取等\"><a href=\"#minioController：文件的上传、下载、获取等\" class=\"headerlink\" title=\"minioController：文件的上传、下载、获取等\"></a>minioController：文件的上传、下载、获取等</h3><ul>\n<li><p>上传文件：uploadFile: public ResultType uploadFile(@RequestParam String fileName, @RequestParam(“file”) MultipartFile file)</p>\n<ul>\n<li><p>fileName 文件名称</p>\n</li>\n<li><p>MultipartFile file 文件本身</p>\n</li>\n<li><p>思路：根据文件的分类存在不同的bucket和不同路径下。</p>\n</li>\n</ul>\n</li>\n<li><p>获取全部文件：getFiles：public ResultType getFiles(@PathVariable(value &#x3D; “prefix”, required &#x3D; false) String prefix)</p>\n<ul>\n<li><p>prefix：前缀，可以使用这个来获取某一文件夹下的文件，但是目前这个功能是由前端直接实现的。</p>\n</li>\n<li><p>思路：提供给前端所有存在的文件，支持根据prefix来分类获取。且使用 redis进行缓存。</p>\n</li>\n<li><p>getBucketFiles(MinioClient minioClient, String bucketName, String prefix)</p>\n<ul>\n<li>这是工具函数，用于把文件名进行递归拼接，可以直接返回给前端构建好的列表</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>获取预览&#x2F;下载链接：public ResultType getFileUrl(@PathVariable(“fileName”)String fileName)</p>\n<ul>\n<li><p>fileName：文件名称，需要包含其路径。</p>\n</li>\n<li><p>思路：在后端返回一个可以直接被get的链接，前端模拟点击，可以被预览的文件，如图片视频将在浏览器上直接预览，其他文件将下载。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TypeController：文件分类的管理\"><a href=\"#TypeController：文件分类的管理\" class=\"headerlink\" title=\"TypeController：文件分类的管理\"></a>TypeController：文件分类的管理</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Mydisk项目说明\"><a href=\"#Mydisk项目说明\" class=\"headerlink\" title=\"Mydisk项目说明\"></a>Mydisk项目说明</h1><h2 id=\"前台方法（controller）\"><a href=\"#前台方法（controller）\" class=\"headerlink\" title=\"前台方法（controller）\"></a>前台方法（controller）</h2><h3 id=\"minioController：文件的上传、下载、获取等\"><a href=\"#minioController：文件的上传、下载、获取等\" class=\"headerlink\" title=\"minioController：文件的上传、下载、获取等\"></a>minioController：文件的上传、下载、获取等</h3><ul>\n<li><p>上传文件：uploadFile: public ResultType uploadFile(@RequestParam String fileName, @RequestParam(“file”) MultipartFile file)</p>\n<ul>\n<li><p>fileName 文件名称</p>\n</li>\n<li><p>MultipartFile file 文件本身</p>\n</li>\n<li><p>思路：根据文件的分类存在不同的bucket和不同路径下。</p>\n</li>\n</ul>\n</li>\n<li><p>获取全部文件：getFiles：public ResultType getFiles(@PathVariable(value &#x3D; “prefix”, required &#x3D; false) String prefix)</p>\n<ul>\n<li><p>prefix：前缀，可以使用这个来获取某一文件夹下的文件，但是目前这个功能是由前端直接实现的。</p>\n</li>\n<li><p>思路：提供给前端所有存在的文件，支持根据prefix来分类获取。且使用 redis进行缓存。</p>\n</li>\n<li><p>getBucketFiles(MinioClient minioClient, String bucketName, String prefix)</p>\n<ul>\n<li>这是工具函数，用于把文件名进行递归拼接，可以直接返回给前端构建好的列表</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>获取预览&#x2F;下载链接：public ResultType getFileUrl(@PathVariable(“fileName”)String fileName)</p>\n<ul>\n<li><p>fileName：文件名称，需要包含其路径。</p>\n</li>\n<li><p>思路：在后端返回一个可以直接被get的链接，前端模拟点击，可以被预览的文件，如图片视频将在浏览器上直接预览，其他文件将下载。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TypeController：文件分类的管理\"><a href=\"#TypeController：文件分类的管理\" class=\"headerlink\" title=\"TypeController：文件分类的管理\"></a>TypeController：文件分类的管理</h3>"},{"title":"K8S-WEB最终文档","_content":"\n# K8S-WEB项目文档\n\n## 需要了解的前置术语\n\n* 前端：进行数据渲染和展示的部分。通常使用HTML CSS JavaScript实现\n* 后端：对数据进行增删改查，提供服务的部分\n* VUE：前端框架，将HTML CSS JavaScript 整合到一个页面，便于开发\n* VueRouter：Vue的组件，用来快速配置页面跳转\n* Axios：Vue的组件，用来发起和配置Http请求。\n* NPM：包管理工具，用来管理Vue项目的依赖包\n* ElementPlus：Vue3的组件库，用来快速开发，美化页面。\n* tomcat：web服务器，监听端口。SpringBoot使用tomcat来开启服务。\n* SpringBoot：后端框架，用来快速开发服务端\n* Maven：包管理工具，用来管理后端项目\n* MyBatisPlus：用来快速开发服务端对数据库增删改查操作的框架\n* MySQL：数据库\n* SpringCloud：SpringBoot的微服务生态，包含多种框架\n* SpringCloudKubernetes：SpringCloud的k8s组件。由官方维护\n* JWT：JavaWebToken，是SpringBoot的组件，用来进行鉴权\n* Lombok：是SpringBoot的组件，用来一键设置类的get，set方法\n* HttpClient：是SpringBoot的组件，用来发起http请求。\n* Swagger：是SpringBoot组件，用来统一api。\n* token：用来鉴权的序列\n* Cookie：是浏览器中暂时存储数据的一个数据结构。项目中在这里存储token和username\n* Interceptor：拦截器，在后端处理请求前拦截请求，并进行操作\n* Nginx：用来分发http请求，将请求根据端口分配到不同资源\n* Docker\n* Kubernetes\n* Kubevirt\n\n## 后端\n\n### 整体代码包类型解读\n\n<img src=\"http://gohoy.top/i/2023/08/04/p6aqbg-1.png\" alt=\"image-20230804152221174\" style=\"zoom:80%;\" />\n\n**可以很粗略的认为：所有其他的类都是为controller文件服务的**\n\n* `com.example.home.gohoy.k8s_backend`：此目录下的是所有代码\n  * assets：静态文件\n  * config：配置文件\n  * controller：核心提供服务的文件，这里一般只调用service接口实现需求\n  * dao：数据库交互的核心文件，这里都实现了MyBatisPlus\n  * dto：用于前后端传输的类\n  * entities：实体类（实体对象）\n  * service：业务实现层\n  * utils：工具类\n  * K8sWebMainApplication.class：springBoot的启动类，整个项目由此进入\n* resource：存放springBoot配置文件\n  * application.yml：spring boot配置文件。\n  * k8s-user.sql：sql表文件，与项目逻辑无关。\n* pom.xml：图中没有展示，这个文件是maven管理工具的配置文件，使用maven来控制依赖版本\n\n### 后端代码的api框架\n\n<img src=\"http://gohoy.top/i/2023/08/01/qoznsh-1.png\" alt=\"系统结构功能图\"  />\n\n分别对应了代码的controller部分\n\n![image-20230804163908243](http://gohoy.top/i/2023/08/04/r3vqkm-1.png)\n\n### 数据库表\n\n数据库名称为：k8s\n\n只有一张表：users，文件见resource/k8s-users.mysql\n\n#### 表user字段说明\n\n| ColumName    | id   | username         | password | ctr_occupied            | ctr_name                  | ctr_max                     | vm_occupied            | vm_name                | vm_max                     | is_admin     | token               | last_login   |\n| ------------ | ---- | ---------------- | -------- | ----------------------- | ------------------------- | --------------------------- | ---------------------- | ---------------------- | -------------------------- | ------------ | ------------------- | ------------ |\n| describe     | 主键 | 用户名，不可重复 | 密码     | 已经申请的container数量 | 已经申请的container的名称 | 最多可以申请的container数量 | 已经申请的虚拟机的数量 | 已经申请的虚拟机的名称 | 最多可以申请的虚拟机的数量 | 是否是管理员 | 用于验证身份的token | 上次登录时间 |\n| notNull      | yes  | yes              | yes      |                         |                           |                             |                        |                        |                            | yes          | yes                 |              |\n| default      |      |                  |          | 0                       | null                      | 1                           | 0                      | null                   | 1                          | 0            |                     | null         |\n| autoIncrease | yes  |                  |          |                         |                           |                             |                        |                        |                            |              |                     |              |\n\n### 处理请求的逻辑\n\n<img src=\"http://gohoy.top/i/2023/08/04/r5tcvh-1.png\" alt=\"image-20230804152329594\" style=\"zoom: 67%;\" />\n\n#### tomcat服务器如何把请求转发到对应的controller方法？\n\n接下来以用户登录方法为例\n\n我们假设后端服务器的BASE_URL是http://localhost:8080/\n\n* 前端使用POST请求访问了http://localhost:8080/user/login，并且携带了用户的基本信息\n\n* tomcat检测到请求，将请求转发给Springboot框架\n\n* SpringBoot框架通过你的注解找到对应这个url对应的方法\n\n  * 这个方法位于controller/user/UserController.class下\n\n  * UserController.class这个文件需要注解\n\n    * <img src=\"http://gohoy.top/i/2023/08/04/r5tald-1.png\" alt=\"image-20230804152933250\" style=\"zoom: 67%;\" />\n\n    * `@CrossOrigin(\"*\")`\n\n      允许跨域访问到这个方法\n\n    * `@ApiResponses`\n\n      插件Swagger的注解，用来整合所有api的信息，对于这个服务，可以在http://localhost:8080/swagger-ui.html查看所有注册的api，并测试\n\n    * `@RestController()`\n\n      这个注解将这个类作为Restful风格的controller注册到SpringBoot框架中，\n\n    * `@RequestMapping(\"/user/\")`\n\n      这个注解表示这个类接收url为http://localhost:8080/user/的任意方法请求\n\n  * 然后查看login的方法\n\n    * <img src=\"http://gohoy.top/i/2023/08/04/r5t8ma-1.png\" alt=\"image-20230804153323097\" style=\"zoom:80%;\" />\n\n    * `@PostMapping(\"/login\")`\n\n      表示这个方法处理http://localhost:8080/user/login的请求\n\n    * `@ApiResponse(description = \"用户登录\")`\n\n      注册这个方法到swagger管理页面中，这个api的描述为“用户登录”\n\n    * `@RequestBody User user`\n\n      这是需要传入这个函数的参数，对应前端携带的用户信息。并把这个用户信息生成一个User类的对象\n\n    * 接下来就是对user对象进行操作。\n\n#### controller具体逻辑的实现流程\n\n以根据用户名获取用户数据这个api为例\n\n![image-20230804164347717](http://gohoy.top/i/2023/08/04/r6hzsn-1.png)\n\n* 它的返回值是CommonResult，这是我自定义的类（utils/CommonResult.class），用于规范像前端返回的数据格式。\n* 调用了UserService的getUserByName方法\n  * **![image-20230804164546919](http://gohoy.top/i/2023/08/04/r7oqsr-1.png)**\n  * UserService这里只定义了一个接口，没有进行实现\n* UserServiceImpl.class文件实现了UserService接口的方法\n  * <img src=\"http://gohoy.top/i/2023/08/04/r8urkd-1.png\" style=\"zoom:67%;\" />\n* UserServiceImpl中又调用了UserDao中的方法来从数据库查询用户\n  * ![](http://gohoy.top/i/2023/08/04/r9dp3f-1.png)\n  * 这里面什么都没写，因为它继承了BaseMapper类，BaseMapper是MyBatisPlus框架实现的类，其中已经有最基本的对数据库进行增删改查的方法。\n\n##### 为什么要有这么多流程呢？直接把在controller文件中调用UserDao实现查询可以吗\n\n分出controller service dao三层是后端开发的规范，在比较复杂的后端逻辑时可以理清思路，便于实现。\n\n所以简单的业务逻辑是可以直接在controller实现的。\n\n###  controller文件中实现api\n\n####  一般的api，简单的增删改查\n\n##### `AdminPodController`：管理员Pod管理api\n\n* `/getAllPods/{type})`：获取所有pod信息\n  * 使用kubernetesClient获取所有pod，将pod进行筛选，除去系统pod\n  * 将剩下的pod每一个都构建成PodInfo的对象，返回List<PodInfo>\n* `/setCtrDefaultResource/`：设置默认的pod资源，需要传入PodResourceDTO对象\n  * 这个api实现的方法是：将podResourceDTO对象的属性存放在k8s集群中的configMap中。\n* `/setVMDefaultResource/`：与`/setCtrDefaultResource/`同理\n* `/getDefaultConfig/{type}`：根据字符串type获取不同的configMap\n\n##### `AdminUserController`：管理员用户管理api：\n\n* `/getUserByName/{username}`：通过用户名从数据库查询该用户的信息\n* `/getUsersByPage/{pageNum}/{pageSize}`：分页获取全部用户，使用了MyBatisPlus内置的分页方法。\n* `/updateUser`：更新用户信息\n* `/deleteUser/{id}`：通过id删除用户\n\n##### `PodController`：用户对pod的功能需求\n\n* `/selectPodByUserName/{username}`：通过用户名查询该用户所拥有的pod。因为pod创建的时候的名称都是username-type-job-random的形式，这里通过把所有的pod导出，遍历筛选的方法获得目标。\n* `/deletePod/{podName}`：通过pod名称来删除pod\n\n##### `UserController`：用户登录注册和其他对自己信息的管理\n\n* `/register`：传入用户名，密码，只要数据库中没有这个用户就进行插入。\n* `/getUserDTO/{username}`：通过用户名，获取除了密码以外的所有信息。\n* `/getIndex`：前端主页显示的内容，通过此处获取index.md进行展示\n\n####  较为复杂的api逻辑分析\n\n#####  `PodController`：用户对pod的功能需求\n\n* `/createCtr/{username}`：用户开启一个pod\n  * 使用username获取用户信息，判断用户是否还有可用的pod数量。\n  * 从configmap中获取该类型pod的资源数量\n  * 按照资源限制依次创建PV，PVC，Service，Job。PV和PVC用来持久化用户信息，Service用来暴露pod的ssh端口，Job用来控制pod的属性（比如存活时间等）\n  * 创建成功之后将clusterIp，sshPort，rootPassword返回。\n* `/createVm/{username}`：TODO\n\n##### `UserController`：用户登录注册和其他对自己信息的管理\n\n* `/login`：用户登录，传入username和password\n  * 首先验证用户名密码是否正确\n  * 然后按照用户的username，isAdmin属性来使用jwt生成一个token。过期时间默认一周\n  * 然后纠正用户可用的pod数量，因为当pod的job自然结束后，没有钩子函数能够通知我们去修改用户可用pod数量。所以这里在登录的时候进行扫描纠正。\n  * 返回给前端token，前端在访问其他api的时候都需要在cookie中携带username和token\n\n###  kubevirt相关api实现的步骤\n\n#### ~~ 走通使用kubevirt进行创建虚拟机的过程，并选取一个最终实现的方案~~\n\n##### ~~将虚拟机镜像传给pvc，然后使用这个pvc创建一个vm（已完成）~~\n\n##### ~~使用数据类型datavolume来创建虚拟机~~\n\n~~优势：可以通过一个模板来clone虚拟机。通过快照来保存虚拟机的数据~~\n\n~~但是从来没有用过这种方法。可行性待验证~~\n\n#### ~~ 通过kubevirt提供的api，实现这个方案~~\n\n##### ~~ 首先要对请求进行鉴权配置（已完成）~~\n\n~~k8s默认api需要进行证书验证。所以如果直接访问api地址会被拦截。~~\n\n~~我仿照kubernetesClient进行了证书验证的操作。此项已完成~~\n\n##### ~~ 验证将pod配置序列化为请求体正常发送请求的方法~~\n\n~~因为在api中，pod的配置全部都被放在请求体中，而Java存储这些配置的方法是生成一个类。~~\n\n~~这里需要去验证如何把类中的数据正确传递给k8s~~\n\n#### kubevirt最终方案\n\n使用脚本监听文件修改，通过监听文件修改来执行kubectl命令来进行虚拟机操作（当前使用的方案）\n\n```sh\n#!/bin/bash\n\n# 目标目录\n\ntarget_directory=\"/data/upload_pvc_commands\"\n\n# 启动监听\n\ninotifywait -m -e create -e moved_to \"$target_directory\" |\n    while read path action file; do\n        if [[ \"$file\" == *.vm ]]; then\n            vm_name=\"${file%.vm}\"\n            echo $vm_name\n            IMAGE_PATH=\"/home/gohoy/iso/ubuntu-20.04.qcow2\"\n            PV_NAME=\"$vm_name-pv\"\n            PVC_NAME=\"$vm_name-pvc\"\n            PVC_SIZE=\"45Gi\"\n            UPLOADPROXY_URL=$(kubectl -n cdi get svc -l cdi.kubevirt.io=cdi-uploadproxy | awk '/cdi-uploadproxy/ {print $3}')\n            WAIT_SECS=\"240\"\n            echo \"upload images to $PVC_NAME\"\n            sed -e \"4s/pv/$PV_NAME/; 14s/pv/$PV_NAME/; 19s/pv/$PV_NAME/; 29s/pv/$PV_NAME/\" /data/upload_pvc_commands/pv.yaml >/data/upload_pvc_commands/tmppv.yaml\n            kubectl apply -f /data/upload_pvc_commands/tmppv.yaml\n            # sed -e \"4s/pvc/$PVC_NAME/; 11s/45Gi/$PVC_SIZE/ \" /data/upload_pvc_commands/pvc.yaml >/data/upload_pvc_commands/tmppvc.yaml\n            chmod -R 777 /data/*\n            virtctl image-upload --image-path=\"$IMAGE_PATH\" --pvc-name=\"$PVC_NAME\" \\\n                --pvc-size=\"$PVC_SIZE\" --uploadproxy-url=\"$UPLOADPROXY_URL\" \\\n                --insecure --wait-secs=\"$WAIT_SECS\"\n\n             chmod -R 777 /data/*\n             virtctl image-upload --image-path=\"$IMAGE_PATH\" --pvc-name=\"$PVC_NAME\" \\\n                --pvc-size=\"$PVC_SIZE\" --uploadproxy-url=\"$UPLOADPROXY_URL\" \\\n                --insecure --wait-secs=\"$WAIT_SECS\"\n\n            echo \"upload images done\"\n            sed -e \"4s/vm/$vm_name/; 11s/vm/$vm_name/; 33s/pvc/$vm_name-pvc/\" /data/upload_pvc_commands/vm.yaml >/data/upload_pvc_commands/tmpvm.yaml\n\n            kubectl apply -f /data/upload_pvc_commands/tmpvm.yaml\n            rm -f /data/upload_pvc_commands/$vm_name.vm\n\n        elif [[ \"$file\" == *.delete ]]; then\n            vm_name=\"${file%.delete}\"\n            echo \"Deleting VM: $vm_name\"\n            kubectl delete vm \"$vm_name\"\n            kubectl delete pvc \"$vm_name-pvc\"\n            kubectl delete pv \"$vm_name-pv\"\n\n            rm -f \"$target_directory/$vm_name.delete\"\n\n        fi\n\n    done\n```\n\n\n\n## 前端\n\n### 前端代码包\n\n![image-20230814160921521](http://gohoy.top/i/2023/08/14/qm6mnh-1.png)\n\n* node_modules：所有前端组件的目录。由npm管理\n* public：放一些公共文件，比如网站的头像，index.html\n* src：主要代码的存放处\n  * assets：静态资源\n  * components：组件，需要重复使用的部分\n  * router：路由，管理页面的跳转\n  * views：主要的页面存放处\n  * App.vue：整个项目的入口\n  * main.js：整个项目的配置文件\n\n### 前端文件的架构\n\n<img src=\"http://gohoy.top/i/2023/08/14/qqtpor-1.png\" alt=\"image-20230814161708391\" style=\"zoom:67%;\" />\n\n页面的入口是App.vue\n\nApp.vue中的`   <router-view></router-view>`是这个页面被渲染的地方。\n\n## 框架的使用说明\n\n### NPM\n\nNodeJs提供的包管理工具\n\nnpm install <packageName> 安装某个包\n\nnpm install 按照npm的配置文件package.json来安装所有依赖\n\n在前端项目中，需要Node注意版本。\n\nnpm run <option> 将项目运行，一般会有 serve 和build 选项。前者用于开发。后者将项目打包，用于部署\n\n### Vue\n\nvue ui：开启一个webCli来进行vue项目管理\n\nvue init <packageName> 创建一个vue项目（可以在web页面进行）\n\n### VueRouter\n\n```sh\nnpm install vue-router\n//在创建vue项目的时候可以选择直接安装\n```\n\n用于页面跳转，整合在整个vue项目中。\n\n```js\n//   router/index.js示例\nimport { createRouter, createWebHashHistory } from 'vue-router'\nimport IndexView from '@/views/indexView.vue'\nconst routes = [\n  {\n    path: '/index',\n    name: 'home',\n    component: IndexView\n  }\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes\n})\n\nexport default router\n```\n\n```js\n// main.js中需要配置如下\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport router from './router'\n\nconst app = createApp(App);\napp.use(router).mount('#app')\n\n```\n\n这样之后，就可以访问项目地址/index进入页面IndexView\n\n### axios\n\n```sh\nnpm insatll axios\n```\n\n用于发送http请求\n\n```js\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport axios from 'axios'\naxios.defaults.baseURL = \"http://localhost:8080/\"\n//设置基本路径，在之后的请求中不需要重复输入这段url\naxios.interceptors.request.use((config) => {\n    const token = Cookies.get('token');\n    const username = Cookies.get('username');\n    if (token) {\n        config.headers['Authorization'] = token;\n    }\n\n    if (username) {\n        config.headers['X-Username'] = username;\n    }\n\n    config.headers['Referrer-Policy'] = 'no-referrer'\n    return config;\n});\n//这个interceptor用来解决跨域问题\nconst app = createApp(App);\napp.config.globalProperties.$axios = axios\napp.config.globalProperties.$http = axios\n// 将axios的别名设置为$axios或者$http\napp.use(router).mount('#app')\n\n```\n\n示例使用\n\n```js\n        async handleLogin() {\n            const response = await this.$axios.post('/user/login', this.userData).then(response => {\n                if (response.data.code == \"200\") {\n                    Cookies.set('token', response.data.data);\n                    Cookies.set('username', this.userData.username);\n                    ElMessage.info(response.data.message)\n                    location.reload();\n                } else {\n                    ElMessage.error(response.data.message)\n                }\n            })\n\n        },\n```\n\n这里使用post请求访问http://localhost:8080/user/login，并在requestBody中携带了用户登录信息。并将得到的返回值放在response中。之后进行操作\n\n### ElementPlus\n\n[查看官方使用文档](https://element-plus.org/zh-CN/guide/quickstart.html#%E7%94%A8%E6%B3%95)\n\n### Maven\n\n包配置文件在项目根目录的pom.xml中\n\n基本示例\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>3.1.2</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.example</groupId>\n\t<artifactId>home-gohoy-k8s_backend</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>demo</name>\n\t<description>Demo project for Spring Boot</description>\n\t<properties>\n\t\t<java.version>17</java.version>\n\t</properties>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-kubernetes-fabric8-all</artifactId>\n\t\t\t<version>3.0.3</version>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n主要需要添加依赖的是dependency标签。\n\n修改完成后，使用mvn install 进行安装依赖\n\nmvn package 按照build标签把项目进行打包，用于部署\n\n配置文件：一般是根目录的.m2/setting.xml\n\nmaven换源：\n\n```xml\n\t<mirror>\n  \t    <id>nexus-aliyun</id>\n  \t\t<name>Nexus aliyun</name>\n        <mirrorOf>external:*</mirrorOf>\n  \t\t<url>http://maven.aliyun.com/nexus/content/groups/public</url>\n  \t</mirror>\n```\n\n在mirrors标签中加入这些即可\n\n### SpringBoot\n\nMaven包设置：\n\n```xml\n\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t\t<version>3.1.2</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-actuator</artifactId>\n\t\t\t<version>3.1.0</version>\n\t\t\t<scope>compile</scope>\n\t\t</dependency>\n```\n\n配置：\n\n```yaml\nspring:\n  application:\n    name:k8s-web\nserver:\n  port: 8080\n```\n\n\n\n主启动类的格式：\n\n```java\n@SpringBootApplication\npublic class K8sWebMainApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(K8sWebMainApplication.class, args);\n\t}\n}\n```\n\n这些是最基本的，且不变的。\n\n可能会需要其他配置。在类名前加上不同的注解。\n\n运行这个类，SpringBoot就会在指定端口开启一个tomcat服务器用来接收http请求。（默认8080）\n\n配置文件默认在项目根目录/resources/application.yaml（或者application.application）\n\n### MyBatisPlus\n\nMaven包引用\n\n```xml\n\t<dependency>\n\t\t\t<groupId>com.baomidou</groupId>\n\t\t\t<artifactId>mybatis-plus-boot-starter</artifactId>\n\t\t\t<version>3.5.3.1</version>\n\t\t</dependency>\n```\n\n\n\n用来简化SpringBoot和数据库的操作\n\n配置：\n\n```yaml\n# applicaiton.yaml\nmybatis-plus:\n  mapper-locations: classpath:mapper/*.xml\n```\n\n这里配置了mapper的路径，让SpringBoot能够找到Mybatis的系列配置，但是基础的crud用不到这些mapper文件\n\n基础使用：\n\n```java\n// dao文件需要继承BaseMapper<entity>，里面实现的基础的crud\n@Table(name = \"users\")\npublic interface UserDao extends BaseMapper<User> {\n}\n```\n\n```java\n// service文件需要继承Iservice<entity>，里面定义了基本的crud接口\npublic interface UserService extends IService<User> {\n}\n```\n\n```java\n// 在serviceImpl文件中继承 ServiceImpl<Dao文件 , entity> ，里面实现了Iservice<entity>的接口\n@Service\npublic class UserServiceImpl extends ServiceImpl<UserDao , User> implements UserService {\n}\n\n```\n\n### MySQL\n\n这里准备使用docker来启动\n\n``docker run --name mysql  --restart=always -p 3306:3306 \\\n-e \"MYSQL_ROOT_PASSWORD=040424\" mysql ``\n\n修改远程连接：``update user set host='*' where user='root'&& host='localhost';\nflush privileges;``\n\n然后使用可视化工具比如MySQLWorkBrench来进行表的设计和操作。\n\nMaven包配置\n\n```xml\n<dependency>\n\t<groupId>mysql</groupId>\n\t<artifactId>mysql-connector-java</artifactId>\n\t<version>8.0.33</version>\n</dependency>\n```\n\nSpringBoot配置\n\n```yam\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/k8s?user=root&password=040424&useUnicode=true&characterEncoding=utf-8&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=Asia/Shanghai\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n这里主要要配置url。\n\n在这里配置之后，MyBatisPlus的curd操作就能够找到数据源\n\n### SpringCloudKubernetes\n\nMaven 配置\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-kubernetes-fabric8-all</artifactId>\n\t\t\t<version>3.0.3</version>\n\t\t</dependency>\n```\n\nSpringBoot 配置\n\n```yaml\nspring:\n  cloud:\n    kubernetes:\n      discovery:\n        enabled: true\n```\n\n基本使用：首先要把k8s的配置文件默认在/etc/kubernetes/admin.conf  复制到用户根目录的 .kube/config\n\n然后开始编码：\n\n```java\npackage com.example.home.gohoy.k8s_backend.config;\n\nimport io.fabric8.kubernetes.client.*;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class KubernetesConfig {\n\n    @Bean\n    public KubernetesClient kubernetesClient() {\n        Config config = new ConfigBuilder().withMasterUrl(\"https://192.168.111.140:6443\").build();\n        return new KubernetesClientBuilder().withConfig(config).build();\n    }\n}\n\n```\n\n这段代码将kubernetesClient注入到SpringBoot容器中，生成一个实例。\n\n然后使用的时候直接调用它提供的api\n\n```java\n   config = new Namespace();\n   ObjectMeta metadata = new ObjectMeta();\n   metadata.setName(\"default\");\n   config.setMetadata(metadata);\n   kubernetesClient.resource(config).createOrReplace();\n```\n\n这段代码使用kubernetesClient创建了一个namespace config\n\n### JWT\n\n用来生成token，来进行鉴权\n\nMaven配置\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>io.jsonwebtoken</groupId>\n\t\t\t<artifactId>jjwt-api</artifactId>\n\t\t\t<version>0.11.5</version> <!-- Replace with the latest version -->\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>io.jsonwebtoken</groupId>\n\t\t\t<artifactId>jjwt-impl</artifactId>\n\t\t\t<version>0.11.5</version> <!-- Replace with the latest version -->\n\t\t\t<scope>runtime</scope>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>io.jsonwebtoken</groupId>\n\t\t\t<artifactId>jjwt-jackson</artifactId>\n\t\t\t<version>0.11.5</version> <!-- Replace with the latest version -->\n\t\t\t<scope>runtime</scope>\n\t\t</dependency>\n```\n\n\n\n自定义一个JWTUtil.java\n\n```java\npackage com.example.home.gohoy.k8s_backend.utils;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\n\nimport javax.crypto.spec.SecretKeySpec;\nimport java.nio.charset.StandardCharsets;\nimport java.security.Key;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class JWTUtils {\n    private static final String SECRET_KEY = \"TheFurthestDistanceInTheWorldIsNotBetweenLifeAndDeathButWhenIStandInFrontOfYouYetYouDonNotKnowThatILoveYou\";\n    // 生成JWT令牌\n    public static String generateToken(String username,byte isAdmin, long expirationMillis) {\n        Date now = new Date();\n        Date expiration = new Date(now.getTime() + expirationMillis);\n        Map<String, Object> claims = new HashMap<>();\n        // 在claims中添加用户信息或其他声明\n        claims.put(\"username\", username);\n        claims.put(\"isAdmin\",isAdmin);\n        // 可以添加更多的声明，比如用户角色等\n        byte[] apiKeySecretBytes = SECRET_KEY.getBytes(StandardCharsets.UTF_8);\n        Key signingKey = new SecretKeySpec(apiKeySecretBytes, SignatureAlgorithm.HS256.getJcaName());\n        return Jwts.builder()\n                .setClaims(claims)\n                .setIssuedAt(now)\n                .setExpiration(expiration)\n                .signWith(signingKey)\n                .compact();\n    }\n    // 验证JWT令牌，如果验证失败将抛出异常，否则返回声明（claims）\n    public static Claims verifyToken(String token) {\n        byte[] apiKeySecretBytes = SECRET_KEY.getBytes(StandardCharsets.UTF_8);\n        Key signingKey = new SecretKeySpec(apiKeySecretBytes, SignatureAlgorithm.HS256.getJcaName());\n        return Jwts.parserBuilder()\n                .setSigningKey(signingKey)\n                .build()\n                .parseClaimsJws(token)\n                .getBody();\n    }\n}\n\n```\n\n提供两个方法\n\n* generateToken：使用用户的username和isAdmin字段和过期时间和自定义的Sercert_Key来混淆生成一个token\n* verifyToken：将token进行解码，并返回\n\n基本使用：\n\n在登录成功后生成一个token，在接收到前端的请求时，使用token进行鉴权。\n\n### Lombok\n\n用来快速生成类的get set方法，快速标记链式编程等\n\nMaven配置：\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.projectlombok</groupId>\n\t\t\t<artifactId>lombok</artifactId>\n\t\t\t<version>1.18.26</version>\n\t\t\t<scope>compile</scope>\n\t\t</dependency>\n```\n\n基本使用：\n\n```java\npackage com.example.home.gohoy.k8s_backend.entities;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.example.home.gohoy.k8s_backend.dto.UserDTO;\nimport jakarta.persistence.*;\nimport lombok.Data;\nimport java.sql.Timestamp;\nimport java.util.Objects;\n@Data\n@Entity\n@TableName(\"users\")\n@Table(name = \"users\", schema = \"k8s\")\npublic class User  extends UserDTO{\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Id\n    @Column(name = \"id\")\n    private int id;\n    @Basic\n    @Column(name = \"password\")\n    private String password;\n}\n```\n\n直接注解@Data\n\n自动为下面的属性id 和password生成get set方法\n\n### Swagger\n\nMaven配置\n\n```xm\n\t\t<dependency>\n\t\t\t<groupId>org.springdoc</groupId>\n\t\t\t<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>\n\t\t\t<version>2.0.4</version>\n\t\t</dependency>\n```\n\n基本使用：\n\n```java\npackage com.example.home.gohoy.k8s_backend.controller.admin;\n\nimport com.example.home.gohoy.k8s_backend.dao.UserDao;\nimport com.example.home.gohoy.k8s_backend.dto.UserDTO;\nimport com.example.home.gohoy.k8s_backend.entities.User;\nimport com.example.home.gohoy.k8s_backend.service.user.UserService;\nimport com.example.home.gohoy.k8s_backend.utils.CommonResult;\nimport io.swagger.v3.oas.annotations.responses.ApiResponse;\nimport jakarta.annotation.Resource;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@CrossOrigin(\"*\")\n@ApiResponse\n@RequestMapping(\"/admin/\")\npublic class AdminUserController {\n    @Resource\n    private UserService userService;\n    @Resource\n    private UserDao userDao;\n    @GetMapping(\"/getUserByName/{username}\")\n    @ApiResponse(description = \"通过参数userName获取user数据\")\n    private CommonResult getUserByName(@PathVariable(\"username\") String userName){\n  }\n    @GetMapping(\"/getUsersByPage/{pageNum}/{pageSize}\")\n    @ApiResponse(description = \"分页获取所有用户\")\n    private CommonResult getUsers(@PathVariable(\"pageNum\") int pageNum,@PathVariable(\"pageSize\")int pageSize){\n    }\n    @PostMapping(\"/updateUser\")\n    @ApiResponse(description = \"更新用户信息\")\n    public CommonResult updateUser(@RequestBody User user ){\n\n    }\n}\n\n```\n\n@ApiResponses：标记这个类是定义了很多api\n\n@ApiResponse（description=\"这里是api的描述\"）：标记这个方法是一个api\n\n然后在项目运行的url，例如：localhost:8080/swagger-ui.html可以查看这些api，并且可以进行测试\n\n### Interceptor\n\nMaven配置\n\n```xml\n<!--\t\tservlet-->\n\t\t<dependency>\n\t\t\t<groupId>javax.servlet</groupId>\n\t\t\t<artifactId>javax.servlet-api</artifactId>\n\t\t\t<version>4.0.1</version> <!-- Replace with the appropriate version -->\n\t\t\t<scope>provided</scope>\n\t\t</dependency>\n```\n\n\n\nInterceptor主要实现接口HandlerInterceptor的方法preHandle\n\n这个方法是在controller处理请求前执行的。\n\n```java\npackage com.example.home.gohoy.k8s_backend.utils.interceptors;\n\nimport com.example.home.gohoy.k8s_backend.utils.JWTUtils;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport javax.servlet.http.HttpServletResponse;\n@Component\npublic class AdminInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(jakarta.servlet.http.HttpServletRequest request, jakarta.servlet.http.HttpServletResponse response, Object handler) throws Exception {\n        if(request.getMethod().equals(\"OPTIONS\")){\n            return true;\n        }\n        System.out.println(\"AdminInterceptor\");\n        // 从请求头部获取 Authorization Cookie\n        String token = request.getHeader(\"Authorization\");\n\n        if  (JWTUtils.verifyToken(token).get(\"isAdmin\").equals(1)){\n            return true;\n        }else {\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            return false;\n        }\n    }\n}\n\n```\n\n这段代码的逻辑，就在拦截请求，通过token来获取用户的username，然后从数据库查询是否存在admin权限。\n\n拦截器SpringBoot注入文件\n\n```java\npackage com.example.home.gohoy.k8s_backend.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class InterceptorConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new AdminInterceptor())\n                .addPathPatterns(\"/admin/**\");\n        registry.addInterceptor(new LoginInterceptor())\n                .addPathPatterns(\"/**\")\n                .excludePathPatterns(\"/user/login\", \"/user/register\", \"/swagger-ui.html\", \"/swagger-ui/**\",\n                        \"/webjars/swagger-ui/**\", \"/v3/api-docs/**\");\n    }\n}\n\n```\n\n这里exludePathPatterns是排除的路径，防止登录注册和swagger页面不能进入。\n\n### HttpClient（当前项目弃用）\n\n用来发送http请求。\n\n使用的原因：Kubevirt的Api没有整合好的Java包，需要自己进行http请求\n\nMaven配置：\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.apache.httpcomponents</groupId>\n\t\t\t<artifactId>httpclient</artifactId>\n\t\t\t<version>4.5.14</version>\n\t\t</dependency>\n```\n\n进行kubevirt编程：\n\n1.鉴权：（是从kubernetesClient调试的来的）\n\n```java\npackage com.example.home.gohoy.k8s_backend.utils;\n\nimport com.example.home.gohoy.k8s_backend.entities.kubevirt.*;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport io.fabric8.kubernetes.client.KubernetesClientException;\nimport jakarta.validation.constraints.NotNull;\nimport okhttp3.*;\nimport okhttp3.HttpUrl;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport org.springframework.stereotype.Component;\n\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.security.*;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.RSAPrivateCrtKeySpec;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.stream.Collectors;\n\n@Component\npublic class KubevirtUtil {\n\n\n    private final String clientCertResource = \"\";\n    private String caCertResource = \"\";\nprivate TrustManager[] trustManagers;\n\n    public SSLContext preLoad() throws Exception {\n//        System.out.println(caCertResource);\n//        System.out.println(clientCertResource);\n        String clientKeyResource = \"\";\n//        System.out.println(clientKeyResource);\n        InputStream caCert = createInputStreamFromBase64EncodedString(caCertResource);\n        InputStream clientCert = createInputStreamFromBase64EncodedString(clientCertResource);\n        InputStream clientKey = createInputStreamFromBase64EncodedString(clientKeyResource);\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        KeyStore trustStore = KeyStore.getInstance(\"pkcs12\");\n        char[] trustStorePassphrase = \"changeit\".toCharArray();\n        trustStore.load(null);\n        while (caCert.available() > 0) {\n            CertificateFactory certFactory = CertificateFactory.getInstance(\"X509\");\n            X509Certificate cert = (X509Certificate) certFactory.generateCertificate(caCert);\n            String alias = cert.getSubjectX500Principal().getName() + \"_\" + cert.getSerialNumber().toString(16);\n            trustStore.setCertificateEntry(alias, cert);\n        }\n        tmf.init(trustStore);\n         trustManagers = tmf.getTrustManagers();\n      // clientKey clientCrt\n        CertificateFactory certFactory = CertificateFactory.getInstance(\"X509\");\n        Collection<? extends Certificate> certificates = certFactory.generateCertificates(clientCert);\n        PrivateKey privateKey ;\n        byte[] keyBytes = decodePem(clientKey);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        try {\n            // First let's try PKCS8\n            privateKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(keyBytes));\n        } catch (InvalidKeySpecException e) {\n            // Otherwise try PKCS8\n            RSAPrivateCrtKeySpec keySpec = PKCS1Util.decodePKCS1(keyBytes);\n            privateKey= keyFactory.generatePrivate(keySpec);\n        }\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keyStore.load(null);\n        String alias = certificates.stream().map(cert->((X509Certificate)cert).getIssuerX500Principal().getName()).collect(Collectors.joining(\"_\"));\n        keyStore.setKeyEntry(alias, privateKey, trustStorePassphrase, certificates.toArray(new Certificate[0]));\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        kmf.init(keyStore, trustStorePassphrase);\n        KeyManager[] keyManagers = kmf.getKeyManagers();\n\n        //sslContext\n        SSLContext sslContext ;\n        try {\n             sslContext = SSLContext.getInstance(\"TLSv1.2\");\n            sslContext.init(keyManagers, trustManagers, new SecureRandom());\n        } catch (KeyManagementException | NoSuchAlgorithmException e) {\n            throw KubernetesClientException.launderThrowable(e);\n        }\n        return sslContext;\n    }\n\n    public String sendHttpRequest(@NotNull String method,@NotNull String path, Headers headers, RequestBody requestBody) throws Exception {\n        SSLContext sslContext = preLoad();\n\n        OkHttpClient httpClient = new OkHttpClient.Builder()\n                .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])\n                .hostnameVerifier((hostname, session) -> true)\n                .build();\n\n        HttpUrl url = HttpUrl.parse(\"https://192.168.111.140:6443\" + path);\n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url)\n                .method(method, requestBody);\n        System.out.println(url);\n\n        if (headers != null) {\n            requestBuilder.headers(headers);\n        }\n\n        Request request = requestBuilder.build();\n\n        try (Response response = httpClient.newCall(request).execute()) {\n            ResponseBody responseBody = response.body();\n            if (responseBody != null) {\n                String result = responseBody.string();\n                System.out.println(result);\n                return result;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n\n\n    private static ByteArrayInputStream createInputStreamFromBase64EncodedString(String data) {\n        byte[] bytes;\n        try {\n            bytes = Base64.getDecoder().decode(data);\n        } catch (IllegalArgumentException illegalArgumentException) {\n            bytes = data.getBytes();\n        }\n\n        return new ByteArrayInputStream(bytes);\n    }\n\n    private static byte[] decodePem(InputStream keyInputStream) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(keyInputStream))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.contains(\"-----BEGIN \")) {\n                    return readBytes(reader, line.trim().replace(\"BEGIN\", \"END\"));\n                }\n            }\n            throw new IOException(\"PEM is invalid: no begin marker\");\n        }\n    }\n    private static byte[] readBytes(BufferedReader reader, String endMarker) throws IOException {\n        String line;\n        StringBuilder buf = new StringBuilder();\n\n        while ((line = reader.readLine()) != null) {\n            if (line.contains(endMarker)) {\n                return Base64.getDecoder().decode(buf.toString());\n            }\n            buf.append(line.trim());\n        }\n        throw new IOException(\"PEM is invalid : No end marker\");\n    }\n\n\n\n    public String getRequestBody() throws JsonProcessingException {\n        HashMap<String, String> labels = new HashMap<>();\n        labels.put(\"slt\", \"vm-test-1\");\n\n        ArrayList<Disk> disks = new ArrayList<>();\n        disks.add(new Disk().setName(\"containerinit\").setBootOrder(1)\n                .setDisk(new DiskTarget().setBus(\"virtio\"))\n        );\n        ArrayList<Interface> interfaces = new ArrayList<>();\n        interfaces.add(new Interface().setName(\"default\").setMasquerade(\"{}\"));\n\n        ArrayList<Network> networks = new ArrayList<>();\n        networks.add(new Network().setName(\"default\").setPod(new PodNetwork()));\n\n        ArrayList<Volume> volumes = new ArrayList<>();\n        volumes.add(new Volume()\n                .setName(\"containerinit\")\n                .setPersistentVolumeClaim(\n                        new PersistentVolumeClaimVolumeSource()\n                                .setClaimName(\"euler-test-1\")\n                )\n        );\n\n        VirtualMachine virtualMachine = new VirtualMachine();\n        virtualMachine.setApiVersion(\"kubevirt.io/v1\")\n                .setKind(\"VirtualMachine\")\n                .setMetadata(new ObjectMeta().setName(\"vm-test-1\"))\n                .setSpec(new VirtualMachineSpec().setRunning(true)\n                        .setTemplate(new VirtualMachineInstanceTemplateSpec()\n                                .setMetadata(new ObjectMeta()\n                                        .setNamespace(\"default\")\n                                        .setLabels(labels)\n                                ).setSpec(\n                                        new VirtualMachineInstanceSpec()\n                                                .setDomain(\n                                                        new DomainSpec().setDevices(new Devices()\n                                                                .setAutoattachGraphicsDevice(true)\n                                                                .setDisks(disks)\n                                                                .setInterfaces(interfaces)\n                                                        ).setResources(new ResourceRequirements()\n                                                                .setRequests(new Requests()\n                                                                        .setCpu(\"2\")\n                                                                        .setMemory(\"1G\")\n                                                                )\n                                                        )\n                                                ).setNetworks(networks)\n                                                .setVolumes(volumes)\n                                )\n                        )\n                );\n        ObjectMapper objectMapper = new ObjectMapper();\n        String requestBody = objectMapper.writeValueAsString(virtualMachine);\n        System.out.println(requestBody);\n        return  requestBody;\n    }\n\n    public String sendHttpRequest(String method, String path) throws Exception {\n        return sendHttpRequest(method,path,null,null);\n    }\n}\n```\n\n这里的密钥是从k8s的config中复制得到\n\n鉴权操作主要是进行了证书的配置。\n\n2.调用kubevirt Api（弃用）\n\n遇到的困难：缺少一个完整kubevirt环境进行测试。\n\n3.实现kubevirt的方案：使用脚本监听文件修改来执行sh命令。\n\n### Nginx\n\n在部署的环境使用，可以查看[这篇教程](https://www.runoob.com/w3cnote/nginx-setup-intro.html)\n\n### docker\n\nDocker用于作为k8s的container runtime\n\n以及最终项目的打包部署\n\n## 部署\n\n可以参考一些文章。[vue+springboot docker部署](https://blog.csdn.net/qq_52030824/article/details/127982206)\n\n基本步骤：\n\n前端vue 使用npm run build，得到打包后的文件dist，将这个文件放在docker内部nginx的指定目录下。\n\n后端springboot需要使用maven打包成jar包。打包过程参考[教程](https://www.cnblogs.com/sanjay/p/11828081.html)\n\n得到这些包之后，编写dockerfile 文件，将这些容器整合运行。\n\n* 打包得到前端和后端的最终文件\n* docker Java17环境\n  * 将jar包放入这个镜像，使用Java -jar xxx.jar来运行后台包\n* docker MySQL8.0.32环境\n  * 将数据库文件写入容器中\n* docker Nginx环境\n  * 将前端打包文件放入此容器，然后编写nginx配置文件。\n\n### 实操步骤\n\n1. 后端配置好端口后使用maven的package命令打包，得到jar包\n\n   1. 修改端口，MySQL的url：把localhost修改成服务器ip\n\n2. 前端配置好端口后，使用npm build得到dist文件夹\n\n   1. 修改端口和后端的base_url：把base_url修改成服务器ip\n\n3. 然后docker拉取镜像openjdk:17  mysql:8.0.32  nginx:latest\n\n4. 然后写dockerfile文件，将jar包引入为镜像\n\n   1. ```dockerfile\n      # 使用合适的 JDK 17 基础镜像\n      FROM openjdk:17\n      \n      # 复制 jar 包到容器\n      COPY home-gohoy-k8s_backend-0.0.1-SNAPSHOT.jar k8s_web.jar\n      \n      # 运行 jar 包\n      CMD [\"java\", \"-jar\", \"/k8s_web.jar\"]\n      \n      # 暴露端口\n      EXPOSE 8088\n      ```\n\n   2. ``docker build -t k8s-web-server:1.0 .``\n\n   3. 使用docker compose 配置项目需要的镜像的环境\n\n      1. ```yaml\n         version: \"3\"\n         services:\n           k8s-web:\n             image: k8s-web-server:1.0\n             ports:\n               - \"8088:8088\"\n             volumes:\n               - /data/upload_pvc_commands/:/data/upload_pvc_commands/\n               - /root/.kube/:/root/.kube/\n               - /home/gohoy/k8s_web_docker/assets/:/data/assets/\n           mysql:\n             image: mysql:8.0.32\n             container_name: mysql\n             environment:\n               MYSQL_ROOT_PASSWORD: '040424'\n               MYSQL_ALLOW_EMPTY_PASSWORD: 'no'\n               MYSQL_DATABASE: 'k8s'\n             ports:\n                - \"3306:3306\"\n             networks:\n               - k8s_web_network\n         \n         \n           nginx:\n             image: nginx:latest\n             container_name: nginx\n             ports:\n               - \"80:80\"\n             volumes:\n               - /home/gohoy/k8s_web_docker/nginx/html:/usr/share/nginx/html\n               - /home/gohoy/k8s_web_docker/nginx/logs:/var/log/nginx\n               - /home/gohoy/k8s_web_docker/nginx/conf:/etc/nginx\n             networks:\n               - k8s_web_network\n         \n         # 创建自定义网络\n         networks:\n            k8s_web_network:\n         ```\n\n      2. docker-compose up -d启动环境\n\n   4. 配置nginx\n\n      1. 在/home/gohoy/k8s_web_docker/nginx/conf下配置nginx 的配置文件，nginx.conf 和 mime.types 是从容器里面copy出来的默认配置，如何在conf.d中放入 k8s_web.conf文件\n\n      2. ```conf\n         server {\n             listen 80;\n             location / {\n                 root /usr/share/nginx/html/dist; # 根据您的目录配置\n                 index index.html;\n             }\n             access_log /var/log/nginx/access.log;\n             error_log /var/log/nginx/error.log;\n         }\n         ```\n\n      3. 把前端vue打包好的dist文件放在/usr/share/nginx/html/下面\n\n   5. 配置MySQL\n\n      1. 直接在自己电脑使用MySQL work branch（或者同类工具如navicat）连接\n      2. 刷入sql脚本文件\n\n   6. 启动主机上 `/home/gohoy/k8s_web_docker/watch_and_execute.sh`，这个脚本来监听/data/upload_pvc_commands/文件夹，通过监听文件修改来执行kubevirt相关的命令\n\n      1. ```sh\n         #!/bin/bash\n         \n         # 目标目录\n         \n         target_directory=\"/data/upload_pvc_commands\"\n         \n         # 启动监听\n         \n         inotifywait -m -e create -e moved_to \"$target_directory\" |\n             while read path action file; do\n                 if [[ \"$file\" == *.vm ]]; then\n                     vm_name=\"${file%.vm}\"\n                     echo $vm_name\n                     IMAGE_PATH=\"/home/gohoy/iso/ubuntu-20.04.qcow2\"\n                     PV_NAME=\"$vm_name-pv\"\n                     PVC_NAME=\"$vm_name-pvc\"\n                     PVC_SIZE=\"45Gi\"\n                     UPLOADPROXY_URL=$(kubectl -n cdi get svc -l cdi.kubevirt.io=cdi-uploadproxy | awk '/cdi-uploadproxy/ {print $3}')\n                     WAIT_SECS=\"240\"\n                     echo \"upload images to $PVC_NAME\"\n                     sed -e \"4s/pv/$PV_NAME/; 14s/pv/$PV_NAME/; 19s/pv/$PV_NAME/; 29s/pv/$PV_NAME/\" /data/upload_pvc_commands/pv.yaml >/data/upload_pvc_commands/tmppv.yaml\n                     kubectl apply -f /data/upload_pvc_commands/tmppv.yaml\n                     # sed -e \"4s/pvc/$PVC_NAME/; 11s/45Gi/$PVC_SIZE/ \" /data/upload_pvc_commands/pvc.yaml >/data/upload_pvc_commands/tmppvc.yaml\n                     chmod -R 777 /data/*\n                     virtctl image-upload --image-path=\"$IMAGE_PATH\" --pvc-name=\"$PVC_NAME\" \\\n                         --pvc-size=\"$PVC_SIZE\" --uploadproxy-url=\"$UPLOADPROXY_URL\" \\\n                         --insecure --wait-secs=\"$WAIT_SECS\"\n         \n                      chmod -R 777 /data/*\n                      virtctl image-upload --image-path=\"$IMAGE_PATH\" --pvc-name=\"$PVC_NAME\" \\\n                         --pvc-size=\"$PVC_SIZE\" --uploadproxy-url=\"$UPLOADPROXY_URL\" \\\n                         --insecure --wait-secs=\"$WAIT_SECS\"\n         \n                     echo \"upload images done\"\n                     sed -e \"4s/vm/$vm_name/; 11s/vm/$vm_name/; 33s/pvc/$vm_name-pvc/\" /data/upload_pvc_commands/vm.yaml >/data/upload_pvc_commands/tmpvm.yaml\n         \n                     kubectl apply -f /data/upload_pvc_commands/tmpvm.yaml\n                     rm -f /data/upload_pvc_commands/$vm_name.vm\n         \n                 elif [[ \"$file\" == *.delete ]]; then\n                     vm_name=\"${file%.delete}\"\n                     echo \"Deleting VM: $vm_name\"\n                     kubectl delete vm \"$vm_name\"\n                     kubectl delete pvc \"$vm_name-pvc\"\n                     kubectl delete pv \"$vm_name-pv\"\n         \n                     rm -f \"$target_directory/$vm_name.delete\"\n         \n                 fi\n         \n             done\n         ```\n\n         \n","source":"_posts/k8s-web最终文档.md","raw":"---\ntitle: K8S-WEB最终文档\ncategory: K8S\ntag: \n - K8S\n---\n\n# K8S-WEB项目文档\n\n## 需要了解的前置术语\n\n* 前端：进行数据渲染和展示的部分。通常使用HTML CSS JavaScript实现\n* 后端：对数据进行增删改查，提供服务的部分\n* VUE：前端框架，将HTML CSS JavaScript 整合到一个页面，便于开发\n* VueRouter：Vue的组件，用来快速配置页面跳转\n* Axios：Vue的组件，用来发起和配置Http请求。\n* NPM：包管理工具，用来管理Vue项目的依赖包\n* ElementPlus：Vue3的组件库，用来快速开发，美化页面。\n* tomcat：web服务器，监听端口。SpringBoot使用tomcat来开启服务。\n* SpringBoot：后端框架，用来快速开发服务端\n* Maven：包管理工具，用来管理后端项目\n* MyBatisPlus：用来快速开发服务端对数据库增删改查操作的框架\n* MySQL：数据库\n* SpringCloud：SpringBoot的微服务生态，包含多种框架\n* SpringCloudKubernetes：SpringCloud的k8s组件。由官方维护\n* JWT：JavaWebToken，是SpringBoot的组件，用来进行鉴权\n* Lombok：是SpringBoot的组件，用来一键设置类的get，set方法\n* HttpClient：是SpringBoot的组件，用来发起http请求。\n* Swagger：是SpringBoot组件，用来统一api。\n* token：用来鉴权的序列\n* Cookie：是浏览器中暂时存储数据的一个数据结构。项目中在这里存储token和username\n* Interceptor：拦截器，在后端处理请求前拦截请求，并进行操作\n* Nginx：用来分发http请求，将请求根据端口分配到不同资源\n* Docker\n* Kubernetes\n* Kubevirt\n\n## 后端\n\n### 整体代码包类型解读\n\n<img src=\"http://gohoy.top/i/2023/08/04/p6aqbg-1.png\" alt=\"image-20230804152221174\" style=\"zoom:80%;\" />\n\n**可以很粗略的认为：所有其他的类都是为controller文件服务的**\n\n* `com.example.home.gohoy.k8s_backend`：此目录下的是所有代码\n  * assets：静态文件\n  * config：配置文件\n  * controller：核心提供服务的文件，这里一般只调用service接口实现需求\n  * dao：数据库交互的核心文件，这里都实现了MyBatisPlus\n  * dto：用于前后端传输的类\n  * entities：实体类（实体对象）\n  * service：业务实现层\n  * utils：工具类\n  * K8sWebMainApplication.class：springBoot的启动类，整个项目由此进入\n* resource：存放springBoot配置文件\n  * application.yml：spring boot配置文件。\n  * k8s-user.sql：sql表文件，与项目逻辑无关。\n* pom.xml：图中没有展示，这个文件是maven管理工具的配置文件，使用maven来控制依赖版本\n\n### 后端代码的api框架\n\n<img src=\"http://gohoy.top/i/2023/08/01/qoznsh-1.png\" alt=\"系统结构功能图\"  />\n\n分别对应了代码的controller部分\n\n![image-20230804163908243](http://gohoy.top/i/2023/08/04/r3vqkm-1.png)\n\n### 数据库表\n\n数据库名称为：k8s\n\n只有一张表：users，文件见resource/k8s-users.mysql\n\n#### 表user字段说明\n\n| ColumName    | id   | username         | password | ctr_occupied            | ctr_name                  | ctr_max                     | vm_occupied            | vm_name                | vm_max                     | is_admin     | token               | last_login   |\n| ------------ | ---- | ---------------- | -------- | ----------------------- | ------------------------- | --------------------------- | ---------------------- | ---------------------- | -------------------------- | ------------ | ------------------- | ------------ |\n| describe     | 主键 | 用户名，不可重复 | 密码     | 已经申请的container数量 | 已经申请的container的名称 | 最多可以申请的container数量 | 已经申请的虚拟机的数量 | 已经申请的虚拟机的名称 | 最多可以申请的虚拟机的数量 | 是否是管理员 | 用于验证身份的token | 上次登录时间 |\n| notNull      | yes  | yes              | yes      |                         |                           |                             |                        |                        |                            | yes          | yes                 |              |\n| default      |      |                  |          | 0                       | null                      | 1                           | 0                      | null                   | 1                          | 0            |                     | null         |\n| autoIncrease | yes  |                  |          |                         |                           |                             |                        |                        |                            |              |                     |              |\n\n### 处理请求的逻辑\n\n<img src=\"http://gohoy.top/i/2023/08/04/r5tcvh-1.png\" alt=\"image-20230804152329594\" style=\"zoom: 67%;\" />\n\n#### tomcat服务器如何把请求转发到对应的controller方法？\n\n接下来以用户登录方法为例\n\n我们假设后端服务器的BASE_URL是http://localhost:8080/\n\n* 前端使用POST请求访问了http://localhost:8080/user/login，并且携带了用户的基本信息\n\n* tomcat检测到请求，将请求转发给Springboot框架\n\n* SpringBoot框架通过你的注解找到对应这个url对应的方法\n\n  * 这个方法位于controller/user/UserController.class下\n\n  * UserController.class这个文件需要注解\n\n    * <img src=\"http://gohoy.top/i/2023/08/04/r5tald-1.png\" alt=\"image-20230804152933250\" style=\"zoom: 67%;\" />\n\n    * `@CrossOrigin(\"*\")`\n\n      允许跨域访问到这个方法\n\n    * `@ApiResponses`\n\n      插件Swagger的注解，用来整合所有api的信息，对于这个服务，可以在http://localhost:8080/swagger-ui.html查看所有注册的api，并测试\n\n    * `@RestController()`\n\n      这个注解将这个类作为Restful风格的controller注册到SpringBoot框架中，\n\n    * `@RequestMapping(\"/user/\")`\n\n      这个注解表示这个类接收url为http://localhost:8080/user/的任意方法请求\n\n  * 然后查看login的方法\n\n    * <img src=\"http://gohoy.top/i/2023/08/04/r5t8ma-1.png\" alt=\"image-20230804153323097\" style=\"zoom:80%;\" />\n\n    * `@PostMapping(\"/login\")`\n\n      表示这个方法处理http://localhost:8080/user/login的请求\n\n    * `@ApiResponse(description = \"用户登录\")`\n\n      注册这个方法到swagger管理页面中，这个api的描述为“用户登录”\n\n    * `@RequestBody User user`\n\n      这是需要传入这个函数的参数，对应前端携带的用户信息。并把这个用户信息生成一个User类的对象\n\n    * 接下来就是对user对象进行操作。\n\n#### controller具体逻辑的实现流程\n\n以根据用户名获取用户数据这个api为例\n\n![image-20230804164347717](http://gohoy.top/i/2023/08/04/r6hzsn-1.png)\n\n* 它的返回值是CommonResult，这是我自定义的类（utils/CommonResult.class），用于规范像前端返回的数据格式。\n* 调用了UserService的getUserByName方法\n  * **![image-20230804164546919](http://gohoy.top/i/2023/08/04/r7oqsr-1.png)**\n  * UserService这里只定义了一个接口，没有进行实现\n* UserServiceImpl.class文件实现了UserService接口的方法\n  * <img src=\"http://gohoy.top/i/2023/08/04/r8urkd-1.png\" style=\"zoom:67%;\" />\n* UserServiceImpl中又调用了UserDao中的方法来从数据库查询用户\n  * ![](http://gohoy.top/i/2023/08/04/r9dp3f-1.png)\n  * 这里面什么都没写，因为它继承了BaseMapper类，BaseMapper是MyBatisPlus框架实现的类，其中已经有最基本的对数据库进行增删改查的方法。\n\n##### 为什么要有这么多流程呢？直接把在controller文件中调用UserDao实现查询可以吗\n\n分出controller service dao三层是后端开发的规范，在比较复杂的后端逻辑时可以理清思路，便于实现。\n\n所以简单的业务逻辑是可以直接在controller实现的。\n\n###  controller文件中实现api\n\n####  一般的api，简单的增删改查\n\n##### `AdminPodController`：管理员Pod管理api\n\n* `/getAllPods/{type})`：获取所有pod信息\n  * 使用kubernetesClient获取所有pod，将pod进行筛选，除去系统pod\n  * 将剩下的pod每一个都构建成PodInfo的对象，返回List<PodInfo>\n* `/setCtrDefaultResource/`：设置默认的pod资源，需要传入PodResourceDTO对象\n  * 这个api实现的方法是：将podResourceDTO对象的属性存放在k8s集群中的configMap中。\n* `/setVMDefaultResource/`：与`/setCtrDefaultResource/`同理\n* `/getDefaultConfig/{type}`：根据字符串type获取不同的configMap\n\n##### `AdminUserController`：管理员用户管理api：\n\n* `/getUserByName/{username}`：通过用户名从数据库查询该用户的信息\n* `/getUsersByPage/{pageNum}/{pageSize}`：分页获取全部用户，使用了MyBatisPlus内置的分页方法。\n* `/updateUser`：更新用户信息\n* `/deleteUser/{id}`：通过id删除用户\n\n##### `PodController`：用户对pod的功能需求\n\n* `/selectPodByUserName/{username}`：通过用户名查询该用户所拥有的pod。因为pod创建的时候的名称都是username-type-job-random的形式，这里通过把所有的pod导出，遍历筛选的方法获得目标。\n* `/deletePod/{podName}`：通过pod名称来删除pod\n\n##### `UserController`：用户登录注册和其他对自己信息的管理\n\n* `/register`：传入用户名，密码，只要数据库中没有这个用户就进行插入。\n* `/getUserDTO/{username}`：通过用户名，获取除了密码以外的所有信息。\n* `/getIndex`：前端主页显示的内容，通过此处获取index.md进行展示\n\n####  较为复杂的api逻辑分析\n\n#####  `PodController`：用户对pod的功能需求\n\n* `/createCtr/{username}`：用户开启一个pod\n  * 使用username获取用户信息，判断用户是否还有可用的pod数量。\n  * 从configmap中获取该类型pod的资源数量\n  * 按照资源限制依次创建PV，PVC，Service，Job。PV和PVC用来持久化用户信息，Service用来暴露pod的ssh端口，Job用来控制pod的属性（比如存活时间等）\n  * 创建成功之后将clusterIp，sshPort，rootPassword返回。\n* `/createVm/{username}`：TODO\n\n##### `UserController`：用户登录注册和其他对自己信息的管理\n\n* `/login`：用户登录，传入username和password\n  * 首先验证用户名密码是否正确\n  * 然后按照用户的username，isAdmin属性来使用jwt生成一个token。过期时间默认一周\n  * 然后纠正用户可用的pod数量，因为当pod的job自然结束后，没有钩子函数能够通知我们去修改用户可用pod数量。所以这里在登录的时候进行扫描纠正。\n  * 返回给前端token，前端在访问其他api的时候都需要在cookie中携带username和token\n\n###  kubevirt相关api实现的步骤\n\n#### ~~ 走通使用kubevirt进行创建虚拟机的过程，并选取一个最终实现的方案~~\n\n##### ~~将虚拟机镜像传给pvc，然后使用这个pvc创建一个vm（已完成）~~\n\n##### ~~使用数据类型datavolume来创建虚拟机~~\n\n~~优势：可以通过一个模板来clone虚拟机。通过快照来保存虚拟机的数据~~\n\n~~但是从来没有用过这种方法。可行性待验证~~\n\n#### ~~ 通过kubevirt提供的api，实现这个方案~~\n\n##### ~~ 首先要对请求进行鉴权配置（已完成）~~\n\n~~k8s默认api需要进行证书验证。所以如果直接访问api地址会被拦截。~~\n\n~~我仿照kubernetesClient进行了证书验证的操作。此项已完成~~\n\n##### ~~ 验证将pod配置序列化为请求体正常发送请求的方法~~\n\n~~因为在api中，pod的配置全部都被放在请求体中，而Java存储这些配置的方法是生成一个类。~~\n\n~~这里需要去验证如何把类中的数据正确传递给k8s~~\n\n#### kubevirt最终方案\n\n使用脚本监听文件修改，通过监听文件修改来执行kubectl命令来进行虚拟机操作（当前使用的方案）\n\n```sh\n#!/bin/bash\n\n# 目标目录\n\ntarget_directory=\"/data/upload_pvc_commands\"\n\n# 启动监听\n\ninotifywait -m -e create -e moved_to \"$target_directory\" |\n    while read path action file; do\n        if [[ \"$file\" == *.vm ]]; then\n            vm_name=\"${file%.vm}\"\n            echo $vm_name\n            IMAGE_PATH=\"/home/gohoy/iso/ubuntu-20.04.qcow2\"\n            PV_NAME=\"$vm_name-pv\"\n            PVC_NAME=\"$vm_name-pvc\"\n            PVC_SIZE=\"45Gi\"\n            UPLOADPROXY_URL=$(kubectl -n cdi get svc -l cdi.kubevirt.io=cdi-uploadproxy | awk '/cdi-uploadproxy/ {print $3}')\n            WAIT_SECS=\"240\"\n            echo \"upload images to $PVC_NAME\"\n            sed -e \"4s/pv/$PV_NAME/; 14s/pv/$PV_NAME/; 19s/pv/$PV_NAME/; 29s/pv/$PV_NAME/\" /data/upload_pvc_commands/pv.yaml >/data/upload_pvc_commands/tmppv.yaml\n            kubectl apply -f /data/upload_pvc_commands/tmppv.yaml\n            # sed -e \"4s/pvc/$PVC_NAME/; 11s/45Gi/$PVC_SIZE/ \" /data/upload_pvc_commands/pvc.yaml >/data/upload_pvc_commands/tmppvc.yaml\n            chmod -R 777 /data/*\n            virtctl image-upload --image-path=\"$IMAGE_PATH\" --pvc-name=\"$PVC_NAME\" \\\n                --pvc-size=\"$PVC_SIZE\" --uploadproxy-url=\"$UPLOADPROXY_URL\" \\\n                --insecure --wait-secs=\"$WAIT_SECS\"\n\n             chmod -R 777 /data/*\n             virtctl image-upload --image-path=\"$IMAGE_PATH\" --pvc-name=\"$PVC_NAME\" \\\n                --pvc-size=\"$PVC_SIZE\" --uploadproxy-url=\"$UPLOADPROXY_URL\" \\\n                --insecure --wait-secs=\"$WAIT_SECS\"\n\n            echo \"upload images done\"\n            sed -e \"4s/vm/$vm_name/; 11s/vm/$vm_name/; 33s/pvc/$vm_name-pvc/\" /data/upload_pvc_commands/vm.yaml >/data/upload_pvc_commands/tmpvm.yaml\n\n            kubectl apply -f /data/upload_pvc_commands/tmpvm.yaml\n            rm -f /data/upload_pvc_commands/$vm_name.vm\n\n        elif [[ \"$file\" == *.delete ]]; then\n            vm_name=\"${file%.delete}\"\n            echo \"Deleting VM: $vm_name\"\n            kubectl delete vm \"$vm_name\"\n            kubectl delete pvc \"$vm_name-pvc\"\n            kubectl delete pv \"$vm_name-pv\"\n\n            rm -f \"$target_directory/$vm_name.delete\"\n\n        fi\n\n    done\n```\n\n\n\n## 前端\n\n### 前端代码包\n\n![image-20230814160921521](http://gohoy.top/i/2023/08/14/qm6mnh-1.png)\n\n* node_modules：所有前端组件的目录。由npm管理\n* public：放一些公共文件，比如网站的头像，index.html\n* src：主要代码的存放处\n  * assets：静态资源\n  * components：组件，需要重复使用的部分\n  * router：路由，管理页面的跳转\n  * views：主要的页面存放处\n  * App.vue：整个项目的入口\n  * main.js：整个项目的配置文件\n\n### 前端文件的架构\n\n<img src=\"http://gohoy.top/i/2023/08/14/qqtpor-1.png\" alt=\"image-20230814161708391\" style=\"zoom:67%;\" />\n\n页面的入口是App.vue\n\nApp.vue中的`   <router-view></router-view>`是这个页面被渲染的地方。\n\n## 框架的使用说明\n\n### NPM\n\nNodeJs提供的包管理工具\n\nnpm install <packageName> 安装某个包\n\nnpm install 按照npm的配置文件package.json来安装所有依赖\n\n在前端项目中，需要Node注意版本。\n\nnpm run <option> 将项目运行，一般会有 serve 和build 选项。前者用于开发。后者将项目打包，用于部署\n\n### Vue\n\nvue ui：开启一个webCli来进行vue项目管理\n\nvue init <packageName> 创建一个vue项目（可以在web页面进行）\n\n### VueRouter\n\n```sh\nnpm install vue-router\n//在创建vue项目的时候可以选择直接安装\n```\n\n用于页面跳转，整合在整个vue项目中。\n\n```js\n//   router/index.js示例\nimport { createRouter, createWebHashHistory } from 'vue-router'\nimport IndexView from '@/views/indexView.vue'\nconst routes = [\n  {\n    path: '/index',\n    name: 'home',\n    component: IndexView\n  }\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes\n})\n\nexport default router\n```\n\n```js\n// main.js中需要配置如下\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport router from './router'\n\nconst app = createApp(App);\napp.use(router).mount('#app')\n\n```\n\n这样之后，就可以访问项目地址/index进入页面IndexView\n\n### axios\n\n```sh\nnpm insatll axios\n```\n\n用于发送http请求\n\n```js\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport router from './router'\nimport axios from 'axios'\naxios.defaults.baseURL = \"http://localhost:8080/\"\n//设置基本路径，在之后的请求中不需要重复输入这段url\naxios.interceptors.request.use((config) => {\n    const token = Cookies.get('token');\n    const username = Cookies.get('username');\n    if (token) {\n        config.headers['Authorization'] = token;\n    }\n\n    if (username) {\n        config.headers['X-Username'] = username;\n    }\n\n    config.headers['Referrer-Policy'] = 'no-referrer'\n    return config;\n});\n//这个interceptor用来解决跨域问题\nconst app = createApp(App);\napp.config.globalProperties.$axios = axios\napp.config.globalProperties.$http = axios\n// 将axios的别名设置为$axios或者$http\napp.use(router).mount('#app')\n\n```\n\n示例使用\n\n```js\n        async handleLogin() {\n            const response = await this.$axios.post('/user/login', this.userData).then(response => {\n                if (response.data.code == \"200\") {\n                    Cookies.set('token', response.data.data);\n                    Cookies.set('username', this.userData.username);\n                    ElMessage.info(response.data.message)\n                    location.reload();\n                } else {\n                    ElMessage.error(response.data.message)\n                }\n            })\n\n        },\n```\n\n这里使用post请求访问http://localhost:8080/user/login，并在requestBody中携带了用户登录信息。并将得到的返回值放在response中。之后进行操作\n\n### ElementPlus\n\n[查看官方使用文档](https://element-plus.org/zh-CN/guide/quickstart.html#%E7%94%A8%E6%B3%95)\n\n### Maven\n\n包配置文件在项目根目录的pom.xml中\n\n基本示例\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>3.1.2</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>com.example</groupId>\n\t<artifactId>home-gohoy-k8s_backend</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>demo</name>\n\t<description>Demo project for Spring Boot</description>\n\t<properties>\n\t\t<java.version>17</java.version>\n\t</properties>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-kubernetes-fabric8-all</artifactId>\n\t\t\t<version>3.0.3</version>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n主要需要添加依赖的是dependency标签。\n\n修改完成后，使用mvn install 进行安装依赖\n\nmvn package 按照build标签把项目进行打包，用于部署\n\n配置文件：一般是根目录的.m2/setting.xml\n\nmaven换源：\n\n```xml\n\t<mirror>\n  \t    <id>nexus-aliyun</id>\n  \t\t<name>Nexus aliyun</name>\n        <mirrorOf>external:*</mirrorOf>\n  \t\t<url>http://maven.aliyun.com/nexus/content/groups/public</url>\n  \t</mirror>\n```\n\n在mirrors标签中加入这些即可\n\n### SpringBoot\n\nMaven包设置：\n\n```xml\n\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t\t<version>3.1.2</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-actuator</artifactId>\n\t\t\t<version>3.1.0</version>\n\t\t\t<scope>compile</scope>\n\t\t</dependency>\n```\n\n配置：\n\n```yaml\nspring:\n  application:\n    name:k8s-web\nserver:\n  port: 8080\n```\n\n\n\n主启动类的格式：\n\n```java\n@SpringBootApplication\npublic class K8sWebMainApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(K8sWebMainApplication.class, args);\n\t}\n}\n```\n\n这些是最基本的，且不变的。\n\n可能会需要其他配置。在类名前加上不同的注解。\n\n运行这个类，SpringBoot就会在指定端口开启一个tomcat服务器用来接收http请求。（默认8080）\n\n配置文件默认在项目根目录/resources/application.yaml（或者application.application）\n\n### MyBatisPlus\n\nMaven包引用\n\n```xml\n\t<dependency>\n\t\t\t<groupId>com.baomidou</groupId>\n\t\t\t<artifactId>mybatis-plus-boot-starter</artifactId>\n\t\t\t<version>3.5.3.1</version>\n\t\t</dependency>\n```\n\n\n\n用来简化SpringBoot和数据库的操作\n\n配置：\n\n```yaml\n# applicaiton.yaml\nmybatis-plus:\n  mapper-locations: classpath:mapper/*.xml\n```\n\n这里配置了mapper的路径，让SpringBoot能够找到Mybatis的系列配置，但是基础的crud用不到这些mapper文件\n\n基础使用：\n\n```java\n// dao文件需要继承BaseMapper<entity>，里面实现的基础的crud\n@Table(name = \"users\")\npublic interface UserDao extends BaseMapper<User> {\n}\n```\n\n```java\n// service文件需要继承Iservice<entity>，里面定义了基本的crud接口\npublic interface UserService extends IService<User> {\n}\n```\n\n```java\n// 在serviceImpl文件中继承 ServiceImpl<Dao文件 , entity> ，里面实现了Iservice<entity>的接口\n@Service\npublic class UserServiceImpl extends ServiceImpl<UserDao , User> implements UserService {\n}\n\n```\n\n### MySQL\n\n这里准备使用docker来启动\n\n``docker run --name mysql  --restart=always -p 3306:3306 \\\n-e \"MYSQL_ROOT_PASSWORD=040424\" mysql ``\n\n修改远程连接：``update user set host='*' where user='root'&& host='localhost';\nflush privileges;``\n\n然后使用可视化工具比如MySQLWorkBrench来进行表的设计和操作。\n\nMaven包配置\n\n```xml\n<dependency>\n\t<groupId>mysql</groupId>\n\t<artifactId>mysql-connector-java</artifactId>\n\t<version>8.0.33</version>\n</dependency>\n```\n\nSpringBoot配置\n\n```yam\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/k8s?user=root&password=040424&useUnicode=true&characterEncoding=utf-8&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=Asia/Shanghai\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n这里主要要配置url。\n\n在这里配置之后，MyBatisPlus的curd操作就能够找到数据源\n\n### SpringCloudKubernetes\n\nMaven 配置\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-kubernetes-fabric8-all</artifactId>\n\t\t\t<version>3.0.3</version>\n\t\t</dependency>\n```\n\nSpringBoot 配置\n\n```yaml\nspring:\n  cloud:\n    kubernetes:\n      discovery:\n        enabled: true\n```\n\n基本使用：首先要把k8s的配置文件默认在/etc/kubernetes/admin.conf  复制到用户根目录的 .kube/config\n\n然后开始编码：\n\n```java\npackage com.example.home.gohoy.k8s_backend.config;\n\nimport io.fabric8.kubernetes.client.*;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class KubernetesConfig {\n\n    @Bean\n    public KubernetesClient kubernetesClient() {\n        Config config = new ConfigBuilder().withMasterUrl(\"https://192.168.111.140:6443\").build();\n        return new KubernetesClientBuilder().withConfig(config).build();\n    }\n}\n\n```\n\n这段代码将kubernetesClient注入到SpringBoot容器中，生成一个实例。\n\n然后使用的时候直接调用它提供的api\n\n```java\n   config = new Namespace();\n   ObjectMeta metadata = new ObjectMeta();\n   metadata.setName(\"default\");\n   config.setMetadata(metadata);\n   kubernetesClient.resource(config).createOrReplace();\n```\n\n这段代码使用kubernetesClient创建了一个namespace config\n\n### JWT\n\n用来生成token，来进行鉴权\n\nMaven配置\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>io.jsonwebtoken</groupId>\n\t\t\t<artifactId>jjwt-api</artifactId>\n\t\t\t<version>0.11.5</version> <!-- Replace with the latest version -->\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>io.jsonwebtoken</groupId>\n\t\t\t<artifactId>jjwt-impl</artifactId>\n\t\t\t<version>0.11.5</version> <!-- Replace with the latest version -->\n\t\t\t<scope>runtime</scope>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>io.jsonwebtoken</groupId>\n\t\t\t<artifactId>jjwt-jackson</artifactId>\n\t\t\t<version>0.11.5</version> <!-- Replace with the latest version -->\n\t\t\t<scope>runtime</scope>\n\t\t</dependency>\n```\n\n\n\n自定义一个JWTUtil.java\n\n```java\npackage com.example.home.gohoy.k8s_backend.utils;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\n\nimport javax.crypto.spec.SecretKeySpec;\nimport java.nio.charset.StandardCharsets;\nimport java.security.Key;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class JWTUtils {\n    private static final String SECRET_KEY = \"TheFurthestDistanceInTheWorldIsNotBetweenLifeAndDeathButWhenIStandInFrontOfYouYetYouDonNotKnowThatILoveYou\";\n    // 生成JWT令牌\n    public static String generateToken(String username,byte isAdmin, long expirationMillis) {\n        Date now = new Date();\n        Date expiration = new Date(now.getTime() + expirationMillis);\n        Map<String, Object> claims = new HashMap<>();\n        // 在claims中添加用户信息或其他声明\n        claims.put(\"username\", username);\n        claims.put(\"isAdmin\",isAdmin);\n        // 可以添加更多的声明，比如用户角色等\n        byte[] apiKeySecretBytes = SECRET_KEY.getBytes(StandardCharsets.UTF_8);\n        Key signingKey = new SecretKeySpec(apiKeySecretBytes, SignatureAlgorithm.HS256.getJcaName());\n        return Jwts.builder()\n                .setClaims(claims)\n                .setIssuedAt(now)\n                .setExpiration(expiration)\n                .signWith(signingKey)\n                .compact();\n    }\n    // 验证JWT令牌，如果验证失败将抛出异常，否则返回声明（claims）\n    public static Claims verifyToken(String token) {\n        byte[] apiKeySecretBytes = SECRET_KEY.getBytes(StandardCharsets.UTF_8);\n        Key signingKey = new SecretKeySpec(apiKeySecretBytes, SignatureAlgorithm.HS256.getJcaName());\n        return Jwts.parserBuilder()\n                .setSigningKey(signingKey)\n                .build()\n                .parseClaimsJws(token)\n                .getBody();\n    }\n}\n\n```\n\n提供两个方法\n\n* generateToken：使用用户的username和isAdmin字段和过期时间和自定义的Sercert_Key来混淆生成一个token\n* verifyToken：将token进行解码，并返回\n\n基本使用：\n\n在登录成功后生成一个token，在接收到前端的请求时，使用token进行鉴权。\n\n### Lombok\n\n用来快速生成类的get set方法，快速标记链式编程等\n\nMaven配置：\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.projectlombok</groupId>\n\t\t\t<artifactId>lombok</artifactId>\n\t\t\t<version>1.18.26</version>\n\t\t\t<scope>compile</scope>\n\t\t</dependency>\n```\n\n基本使用：\n\n```java\npackage com.example.home.gohoy.k8s_backend.entities;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.example.home.gohoy.k8s_backend.dto.UserDTO;\nimport jakarta.persistence.*;\nimport lombok.Data;\nimport java.sql.Timestamp;\nimport java.util.Objects;\n@Data\n@Entity\n@TableName(\"users\")\n@Table(name = \"users\", schema = \"k8s\")\npublic class User  extends UserDTO{\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Id\n    @Column(name = \"id\")\n    private int id;\n    @Basic\n    @Column(name = \"password\")\n    private String password;\n}\n```\n\n直接注解@Data\n\n自动为下面的属性id 和password生成get set方法\n\n### Swagger\n\nMaven配置\n\n```xm\n\t\t<dependency>\n\t\t\t<groupId>org.springdoc</groupId>\n\t\t\t<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>\n\t\t\t<version>2.0.4</version>\n\t\t</dependency>\n```\n\n基本使用：\n\n```java\npackage com.example.home.gohoy.k8s_backend.controller.admin;\n\nimport com.example.home.gohoy.k8s_backend.dao.UserDao;\nimport com.example.home.gohoy.k8s_backend.dto.UserDTO;\nimport com.example.home.gohoy.k8s_backend.entities.User;\nimport com.example.home.gohoy.k8s_backend.service.user.UserService;\nimport com.example.home.gohoy.k8s_backend.utils.CommonResult;\nimport io.swagger.v3.oas.annotations.responses.ApiResponse;\nimport jakarta.annotation.Resource;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@CrossOrigin(\"*\")\n@ApiResponse\n@RequestMapping(\"/admin/\")\npublic class AdminUserController {\n    @Resource\n    private UserService userService;\n    @Resource\n    private UserDao userDao;\n    @GetMapping(\"/getUserByName/{username}\")\n    @ApiResponse(description = \"通过参数userName获取user数据\")\n    private CommonResult getUserByName(@PathVariable(\"username\") String userName){\n  }\n    @GetMapping(\"/getUsersByPage/{pageNum}/{pageSize}\")\n    @ApiResponse(description = \"分页获取所有用户\")\n    private CommonResult getUsers(@PathVariable(\"pageNum\") int pageNum,@PathVariable(\"pageSize\")int pageSize){\n    }\n    @PostMapping(\"/updateUser\")\n    @ApiResponse(description = \"更新用户信息\")\n    public CommonResult updateUser(@RequestBody User user ){\n\n    }\n}\n\n```\n\n@ApiResponses：标记这个类是定义了很多api\n\n@ApiResponse（description=\"这里是api的描述\"）：标记这个方法是一个api\n\n然后在项目运行的url，例如：localhost:8080/swagger-ui.html可以查看这些api，并且可以进行测试\n\n### Interceptor\n\nMaven配置\n\n```xml\n<!--\t\tservlet-->\n\t\t<dependency>\n\t\t\t<groupId>javax.servlet</groupId>\n\t\t\t<artifactId>javax.servlet-api</artifactId>\n\t\t\t<version>4.0.1</version> <!-- Replace with the appropriate version -->\n\t\t\t<scope>provided</scope>\n\t\t</dependency>\n```\n\n\n\nInterceptor主要实现接口HandlerInterceptor的方法preHandle\n\n这个方法是在controller处理请求前执行的。\n\n```java\npackage com.example.home.gohoy.k8s_backend.utils.interceptors;\n\nimport com.example.home.gohoy.k8s_backend.utils.JWTUtils;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport javax.servlet.http.HttpServletResponse;\n@Component\npublic class AdminInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(jakarta.servlet.http.HttpServletRequest request, jakarta.servlet.http.HttpServletResponse response, Object handler) throws Exception {\n        if(request.getMethod().equals(\"OPTIONS\")){\n            return true;\n        }\n        System.out.println(\"AdminInterceptor\");\n        // 从请求头部获取 Authorization Cookie\n        String token = request.getHeader(\"Authorization\");\n\n        if  (JWTUtils.verifyToken(token).get(\"isAdmin\").equals(1)){\n            return true;\n        }else {\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            return false;\n        }\n    }\n}\n\n```\n\n这段代码的逻辑，就在拦截请求，通过token来获取用户的username，然后从数据库查询是否存在admin权限。\n\n拦截器SpringBoot注入文件\n\n```java\npackage com.example.home.gohoy.k8s_backend.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class InterceptorConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new AdminInterceptor())\n                .addPathPatterns(\"/admin/**\");\n        registry.addInterceptor(new LoginInterceptor())\n                .addPathPatterns(\"/**\")\n                .excludePathPatterns(\"/user/login\", \"/user/register\", \"/swagger-ui.html\", \"/swagger-ui/**\",\n                        \"/webjars/swagger-ui/**\", \"/v3/api-docs/**\");\n    }\n}\n\n```\n\n这里exludePathPatterns是排除的路径，防止登录注册和swagger页面不能进入。\n\n### HttpClient（当前项目弃用）\n\n用来发送http请求。\n\n使用的原因：Kubevirt的Api没有整合好的Java包，需要自己进行http请求\n\nMaven配置：\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.apache.httpcomponents</groupId>\n\t\t\t<artifactId>httpclient</artifactId>\n\t\t\t<version>4.5.14</version>\n\t\t</dependency>\n```\n\n进行kubevirt编程：\n\n1.鉴权：（是从kubernetesClient调试的来的）\n\n```java\npackage com.example.home.gohoy.k8s_backend.utils;\n\nimport com.example.home.gohoy.k8s_backend.entities.kubevirt.*;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport io.fabric8.kubernetes.client.KubernetesClientException;\nimport jakarta.validation.constraints.NotNull;\nimport okhttp3.*;\nimport okhttp3.HttpUrl;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport org.springframework.stereotype.Component;\n\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.security.*;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.RSAPrivateCrtKeySpec;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.stream.Collectors;\n\n@Component\npublic class KubevirtUtil {\n\n\n    private final String clientCertResource = \"\";\n    private String caCertResource = \"\";\nprivate TrustManager[] trustManagers;\n\n    public SSLContext preLoad() throws Exception {\n//        System.out.println(caCertResource);\n//        System.out.println(clientCertResource);\n        String clientKeyResource = \"\";\n//        System.out.println(clientKeyResource);\n        InputStream caCert = createInputStreamFromBase64EncodedString(caCertResource);\n        InputStream clientCert = createInputStreamFromBase64EncodedString(clientCertResource);\n        InputStream clientKey = createInputStreamFromBase64EncodedString(clientKeyResource);\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        KeyStore trustStore = KeyStore.getInstance(\"pkcs12\");\n        char[] trustStorePassphrase = \"changeit\".toCharArray();\n        trustStore.load(null);\n        while (caCert.available() > 0) {\n            CertificateFactory certFactory = CertificateFactory.getInstance(\"X509\");\n            X509Certificate cert = (X509Certificate) certFactory.generateCertificate(caCert);\n            String alias = cert.getSubjectX500Principal().getName() + \"_\" + cert.getSerialNumber().toString(16);\n            trustStore.setCertificateEntry(alias, cert);\n        }\n        tmf.init(trustStore);\n         trustManagers = tmf.getTrustManagers();\n      // clientKey clientCrt\n        CertificateFactory certFactory = CertificateFactory.getInstance(\"X509\");\n        Collection<? extends Certificate> certificates = certFactory.generateCertificates(clientCert);\n        PrivateKey privateKey ;\n        byte[] keyBytes = decodePem(clientKey);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        try {\n            // First let's try PKCS8\n            privateKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(keyBytes));\n        } catch (InvalidKeySpecException e) {\n            // Otherwise try PKCS8\n            RSAPrivateCrtKeySpec keySpec = PKCS1Util.decodePKCS1(keyBytes);\n            privateKey= keyFactory.generatePrivate(keySpec);\n        }\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keyStore.load(null);\n        String alias = certificates.stream().map(cert->((X509Certificate)cert).getIssuerX500Principal().getName()).collect(Collectors.joining(\"_\"));\n        keyStore.setKeyEntry(alias, privateKey, trustStorePassphrase, certificates.toArray(new Certificate[0]));\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        kmf.init(keyStore, trustStorePassphrase);\n        KeyManager[] keyManagers = kmf.getKeyManagers();\n\n        //sslContext\n        SSLContext sslContext ;\n        try {\n             sslContext = SSLContext.getInstance(\"TLSv1.2\");\n            sslContext.init(keyManagers, trustManagers, new SecureRandom());\n        } catch (KeyManagementException | NoSuchAlgorithmException e) {\n            throw KubernetesClientException.launderThrowable(e);\n        }\n        return sslContext;\n    }\n\n    public String sendHttpRequest(@NotNull String method,@NotNull String path, Headers headers, RequestBody requestBody) throws Exception {\n        SSLContext sslContext = preLoad();\n\n        OkHttpClient httpClient = new OkHttpClient.Builder()\n                .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])\n                .hostnameVerifier((hostname, session) -> true)\n                .build();\n\n        HttpUrl url = HttpUrl.parse(\"https://192.168.111.140:6443\" + path);\n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url)\n                .method(method, requestBody);\n        System.out.println(url);\n\n        if (headers != null) {\n            requestBuilder.headers(headers);\n        }\n\n        Request request = requestBuilder.build();\n\n        try (Response response = httpClient.newCall(request).execute()) {\n            ResponseBody responseBody = response.body();\n            if (responseBody != null) {\n                String result = responseBody.string();\n                System.out.println(result);\n                return result;\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n\n\n    private static ByteArrayInputStream createInputStreamFromBase64EncodedString(String data) {\n        byte[] bytes;\n        try {\n            bytes = Base64.getDecoder().decode(data);\n        } catch (IllegalArgumentException illegalArgumentException) {\n            bytes = data.getBytes();\n        }\n\n        return new ByteArrayInputStream(bytes);\n    }\n\n    private static byte[] decodePem(InputStream keyInputStream) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(keyInputStream))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.contains(\"-----BEGIN \")) {\n                    return readBytes(reader, line.trim().replace(\"BEGIN\", \"END\"));\n                }\n            }\n            throw new IOException(\"PEM is invalid: no begin marker\");\n        }\n    }\n    private static byte[] readBytes(BufferedReader reader, String endMarker) throws IOException {\n        String line;\n        StringBuilder buf = new StringBuilder();\n\n        while ((line = reader.readLine()) != null) {\n            if (line.contains(endMarker)) {\n                return Base64.getDecoder().decode(buf.toString());\n            }\n            buf.append(line.trim());\n        }\n        throw new IOException(\"PEM is invalid : No end marker\");\n    }\n\n\n\n    public String getRequestBody() throws JsonProcessingException {\n        HashMap<String, String> labels = new HashMap<>();\n        labels.put(\"slt\", \"vm-test-1\");\n\n        ArrayList<Disk> disks = new ArrayList<>();\n        disks.add(new Disk().setName(\"containerinit\").setBootOrder(1)\n                .setDisk(new DiskTarget().setBus(\"virtio\"))\n        );\n        ArrayList<Interface> interfaces = new ArrayList<>();\n        interfaces.add(new Interface().setName(\"default\").setMasquerade(\"{}\"));\n\n        ArrayList<Network> networks = new ArrayList<>();\n        networks.add(new Network().setName(\"default\").setPod(new PodNetwork()));\n\n        ArrayList<Volume> volumes = new ArrayList<>();\n        volumes.add(new Volume()\n                .setName(\"containerinit\")\n                .setPersistentVolumeClaim(\n                        new PersistentVolumeClaimVolumeSource()\n                                .setClaimName(\"euler-test-1\")\n                )\n        );\n\n        VirtualMachine virtualMachine = new VirtualMachine();\n        virtualMachine.setApiVersion(\"kubevirt.io/v1\")\n                .setKind(\"VirtualMachine\")\n                .setMetadata(new ObjectMeta().setName(\"vm-test-1\"))\n                .setSpec(new VirtualMachineSpec().setRunning(true)\n                        .setTemplate(new VirtualMachineInstanceTemplateSpec()\n                                .setMetadata(new ObjectMeta()\n                                        .setNamespace(\"default\")\n                                        .setLabels(labels)\n                                ).setSpec(\n                                        new VirtualMachineInstanceSpec()\n                                                .setDomain(\n                                                        new DomainSpec().setDevices(new Devices()\n                                                                .setAutoattachGraphicsDevice(true)\n                                                                .setDisks(disks)\n                                                                .setInterfaces(interfaces)\n                                                        ).setResources(new ResourceRequirements()\n                                                                .setRequests(new Requests()\n                                                                        .setCpu(\"2\")\n                                                                        .setMemory(\"1G\")\n                                                                )\n                                                        )\n                                                ).setNetworks(networks)\n                                                .setVolumes(volumes)\n                                )\n                        )\n                );\n        ObjectMapper objectMapper = new ObjectMapper();\n        String requestBody = objectMapper.writeValueAsString(virtualMachine);\n        System.out.println(requestBody);\n        return  requestBody;\n    }\n\n    public String sendHttpRequest(String method, String path) throws Exception {\n        return sendHttpRequest(method,path,null,null);\n    }\n}\n```\n\n这里的密钥是从k8s的config中复制得到\n\n鉴权操作主要是进行了证书的配置。\n\n2.调用kubevirt Api（弃用）\n\n遇到的困难：缺少一个完整kubevirt环境进行测试。\n\n3.实现kubevirt的方案：使用脚本监听文件修改来执行sh命令。\n\n### Nginx\n\n在部署的环境使用，可以查看[这篇教程](https://www.runoob.com/w3cnote/nginx-setup-intro.html)\n\n### docker\n\nDocker用于作为k8s的container runtime\n\n以及最终项目的打包部署\n\n## 部署\n\n可以参考一些文章。[vue+springboot docker部署](https://blog.csdn.net/qq_52030824/article/details/127982206)\n\n基本步骤：\n\n前端vue 使用npm run build，得到打包后的文件dist，将这个文件放在docker内部nginx的指定目录下。\n\n后端springboot需要使用maven打包成jar包。打包过程参考[教程](https://www.cnblogs.com/sanjay/p/11828081.html)\n\n得到这些包之后，编写dockerfile 文件，将这些容器整合运行。\n\n* 打包得到前端和后端的最终文件\n* docker Java17环境\n  * 将jar包放入这个镜像，使用Java -jar xxx.jar来运行后台包\n* docker MySQL8.0.32环境\n  * 将数据库文件写入容器中\n* docker Nginx环境\n  * 将前端打包文件放入此容器，然后编写nginx配置文件。\n\n### 实操步骤\n\n1. 后端配置好端口后使用maven的package命令打包，得到jar包\n\n   1. 修改端口，MySQL的url：把localhost修改成服务器ip\n\n2. 前端配置好端口后，使用npm build得到dist文件夹\n\n   1. 修改端口和后端的base_url：把base_url修改成服务器ip\n\n3. 然后docker拉取镜像openjdk:17  mysql:8.0.32  nginx:latest\n\n4. 然后写dockerfile文件，将jar包引入为镜像\n\n   1. ```dockerfile\n      # 使用合适的 JDK 17 基础镜像\n      FROM openjdk:17\n      \n      # 复制 jar 包到容器\n      COPY home-gohoy-k8s_backend-0.0.1-SNAPSHOT.jar k8s_web.jar\n      \n      # 运行 jar 包\n      CMD [\"java\", \"-jar\", \"/k8s_web.jar\"]\n      \n      # 暴露端口\n      EXPOSE 8088\n      ```\n\n   2. ``docker build -t k8s-web-server:1.0 .``\n\n   3. 使用docker compose 配置项目需要的镜像的环境\n\n      1. ```yaml\n         version: \"3\"\n         services:\n           k8s-web:\n             image: k8s-web-server:1.0\n             ports:\n               - \"8088:8088\"\n             volumes:\n               - /data/upload_pvc_commands/:/data/upload_pvc_commands/\n               - /root/.kube/:/root/.kube/\n               - /home/gohoy/k8s_web_docker/assets/:/data/assets/\n           mysql:\n             image: mysql:8.0.32\n             container_name: mysql\n             environment:\n               MYSQL_ROOT_PASSWORD: '040424'\n               MYSQL_ALLOW_EMPTY_PASSWORD: 'no'\n               MYSQL_DATABASE: 'k8s'\n             ports:\n                - \"3306:3306\"\n             networks:\n               - k8s_web_network\n         \n         \n           nginx:\n             image: nginx:latest\n             container_name: nginx\n             ports:\n               - \"80:80\"\n             volumes:\n               - /home/gohoy/k8s_web_docker/nginx/html:/usr/share/nginx/html\n               - /home/gohoy/k8s_web_docker/nginx/logs:/var/log/nginx\n               - /home/gohoy/k8s_web_docker/nginx/conf:/etc/nginx\n             networks:\n               - k8s_web_network\n         \n         # 创建自定义网络\n         networks:\n            k8s_web_network:\n         ```\n\n      2. docker-compose up -d启动环境\n\n   4. 配置nginx\n\n      1. 在/home/gohoy/k8s_web_docker/nginx/conf下配置nginx 的配置文件，nginx.conf 和 mime.types 是从容器里面copy出来的默认配置，如何在conf.d中放入 k8s_web.conf文件\n\n      2. ```conf\n         server {\n             listen 80;\n             location / {\n                 root /usr/share/nginx/html/dist; # 根据您的目录配置\n                 index index.html;\n             }\n             access_log /var/log/nginx/access.log;\n             error_log /var/log/nginx/error.log;\n         }\n         ```\n\n      3. 把前端vue打包好的dist文件放在/usr/share/nginx/html/下面\n\n   5. 配置MySQL\n\n      1. 直接在自己电脑使用MySQL work branch（或者同类工具如navicat）连接\n      2. 刷入sql脚本文件\n\n   6. 启动主机上 `/home/gohoy/k8s_web_docker/watch_and_execute.sh`，这个脚本来监听/data/upload_pvc_commands/文件夹，通过监听文件修改来执行kubevirt相关的命令\n\n      1. ```sh\n         #!/bin/bash\n         \n         # 目标目录\n         \n         target_directory=\"/data/upload_pvc_commands\"\n         \n         # 启动监听\n         \n         inotifywait -m -e create -e moved_to \"$target_directory\" |\n             while read path action file; do\n                 if [[ \"$file\" == *.vm ]]; then\n                     vm_name=\"${file%.vm}\"\n                     echo $vm_name\n                     IMAGE_PATH=\"/home/gohoy/iso/ubuntu-20.04.qcow2\"\n                     PV_NAME=\"$vm_name-pv\"\n                     PVC_NAME=\"$vm_name-pvc\"\n                     PVC_SIZE=\"45Gi\"\n                     UPLOADPROXY_URL=$(kubectl -n cdi get svc -l cdi.kubevirt.io=cdi-uploadproxy | awk '/cdi-uploadproxy/ {print $3}')\n                     WAIT_SECS=\"240\"\n                     echo \"upload images to $PVC_NAME\"\n                     sed -e \"4s/pv/$PV_NAME/; 14s/pv/$PV_NAME/; 19s/pv/$PV_NAME/; 29s/pv/$PV_NAME/\" /data/upload_pvc_commands/pv.yaml >/data/upload_pvc_commands/tmppv.yaml\n                     kubectl apply -f /data/upload_pvc_commands/tmppv.yaml\n                     # sed -e \"4s/pvc/$PVC_NAME/; 11s/45Gi/$PVC_SIZE/ \" /data/upload_pvc_commands/pvc.yaml >/data/upload_pvc_commands/tmppvc.yaml\n                     chmod -R 777 /data/*\n                     virtctl image-upload --image-path=\"$IMAGE_PATH\" --pvc-name=\"$PVC_NAME\" \\\n                         --pvc-size=\"$PVC_SIZE\" --uploadproxy-url=\"$UPLOADPROXY_URL\" \\\n                         --insecure --wait-secs=\"$WAIT_SECS\"\n         \n                      chmod -R 777 /data/*\n                      virtctl image-upload --image-path=\"$IMAGE_PATH\" --pvc-name=\"$PVC_NAME\" \\\n                         --pvc-size=\"$PVC_SIZE\" --uploadproxy-url=\"$UPLOADPROXY_URL\" \\\n                         --insecure --wait-secs=\"$WAIT_SECS\"\n         \n                     echo \"upload images done\"\n                     sed -e \"4s/vm/$vm_name/; 11s/vm/$vm_name/; 33s/pvc/$vm_name-pvc/\" /data/upload_pvc_commands/vm.yaml >/data/upload_pvc_commands/tmpvm.yaml\n         \n                     kubectl apply -f /data/upload_pvc_commands/tmpvm.yaml\n                     rm -f /data/upload_pvc_commands/$vm_name.vm\n         \n                 elif [[ \"$file\" == *.delete ]]; then\n                     vm_name=\"${file%.delete}\"\n                     echo \"Deleting VM: $vm_name\"\n                     kubectl delete vm \"$vm_name\"\n                     kubectl delete pvc \"$vm_name-pvc\"\n                     kubectl delete pv \"$vm_name-pv\"\n         \n                     rm -f \"$target_directory/$vm_name.delete\"\n         \n                 fi\n         \n             done\n         ```\n\n         \n","slug":"k8s-web最终文档","published":1,"date":"2023-08-30T06:45:47.700Z","updated":"2023-09-11T13:36:49.849Z","_id":"cllyxpksf000514gfg2iygp8q","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"K8S-WEB项目文档\"><a href=\"#K8S-WEB项目文档\" class=\"headerlink\" title=\"K8S-WEB项目文档\"></a>K8S-WEB项目文档</h1><h2 id=\"需要了解的前置术语\"><a href=\"#需要了解的前置术语\" class=\"headerlink\" title=\"需要了解的前置术语\"></a>需要了解的前置术语</h2><ul>\n<li>前端：进行数据渲染和展示的部分。通常使用HTML CSS JavaScript实现</li>\n<li>后端：对数据进行增删改查，提供服务的部分</li>\n<li>VUE：前端框架，将HTML CSS JavaScript 整合到一个页面，便于开发</li>\n<li>VueRouter：Vue的组件，用来快速配置页面跳转</li>\n<li>Axios：Vue的组件，用来发起和配置Http请求。</li>\n<li>NPM：包管理工具，用来管理Vue项目的依赖包</li>\n<li>ElementPlus：Vue3的组件库，用来快速开发，美化页面。</li>\n<li>tomcat：web服务器，监听端口。SpringBoot使用tomcat来开启服务。</li>\n<li>SpringBoot：后端框架，用来快速开发服务端</li>\n<li>Maven：包管理工具，用来管理后端项目</li>\n<li>MyBatisPlus：用来快速开发服务端对数据库增删改查操作的框架</li>\n<li>MySQL：数据库</li>\n<li>SpringCloud：SpringBoot的微服务生态，包含多种框架</li>\n<li>SpringCloudKubernetes：SpringCloud的k8s组件。由官方维护</li>\n<li>JWT：JavaWebToken，是SpringBoot的组件，用来进行鉴权</li>\n<li>Lombok：是SpringBoot的组件，用来一键设置类的get，set方法</li>\n<li>HttpClient：是SpringBoot的组件，用来发起http请求。</li>\n<li>Swagger：是SpringBoot组件，用来统一api。</li>\n<li>token：用来鉴权的序列</li>\n<li>Cookie：是浏览器中暂时存储数据的一个数据结构。项目中在这里存储token和username</li>\n<li>Interceptor：拦截器，在后端处理请求前拦截请求，并进行操作</li>\n<li>Nginx：用来分发http请求，将请求根据端口分配到不同资源</li>\n<li>Docker</li>\n<li>Kubernetes</li>\n<li>Kubevirt</li>\n</ul>\n<h2 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h2><h3 id=\"整体代码包类型解读\"><a href=\"#整体代码包类型解读\" class=\"headerlink\" title=\"整体代码包类型解读\"></a>整体代码包类型解读</h3><img src=\"http://gohoy.top/i/2023/08/04/p6aqbg-1.png\" alt=\"image-20230804152221174\" style=\"zoom:80%;\" />\n\n<p><strong>可以很粗略的认为：所有其他的类都是为controller文件服务的</strong></p>\n<ul>\n<li><code>com.example.home.gohoy.k8s_backend</code>：此目录下的是所有代码<ul>\n<li>assets：静态文件</li>\n<li>config：配置文件</li>\n<li>controller：核心提供服务的文件，这里一般只调用service接口实现需求</li>\n<li>dao：数据库交互的核心文件，这里都实现了MyBatisPlus</li>\n<li>dto：用于前后端传输的类</li>\n<li>entities：实体类（实体对象）</li>\n<li>service：业务实现层</li>\n<li>utils：工具类</li>\n<li>K8sWebMainApplication.class：springBoot的启动类，整个项目由此进入</li>\n</ul>\n</li>\n<li>resource：存放springBoot配置文件<ul>\n<li>application.yml：spring boot配置文件。</li>\n<li>k8s-user.sql：sql表文件，与项目逻辑无关。</li>\n</ul>\n</li>\n<li>pom.xml：图中没有展示，这个文件是maven管理工具的配置文件，使用maven来控制依赖版本</li>\n</ul>\n<h3 id=\"后端代码的api框架\"><a href=\"#后端代码的api框架\" class=\"headerlink\" title=\"后端代码的api框架\"></a>后端代码的api框架</h3><img src=\"http://gohoy.top/i/2023/08/01/qoznsh-1.png\" alt=\"系统结构功能图\"  />\n\n<p>分别对应了代码的controller部分</p>\n<p><img src=\"http://gohoy.top/i/2023/08/04/r3vqkm-1.png\" alt=\"image-20230804163908243\"></p>\n<h3 id=\"数据库表\"><a href=\"#数据库表\" class=\"headerlink\" title=\"数据库表\"></a>数据库表</h3><p>数据库名称为：k8s</p>\n<p>只有一张表：users，文件见resource&#x2F;k8s-users.mysql</p>\n<h4 id=\"表user字段说明\"><a href=\"#表user字段说明\" class=\"headerlink\" title=\"表user字段说明\"></a>表user字段说明</h4><table>\n<thead>\n<tr>\n<th>ColumName</th>\n<th>id</th>\n<th>username</th>\n<th>password</th>\n<th>ctr_occupied</th>\n<th>ctr_name</th>\n<th>ctr_max</th>\n<th>vm_occupied</th>\n<th>vm_name</th>\n<th>vm_max</th>\n<th>is_admin</th>\n<th>token</th>\n<th>last_login</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>describe</td>\n<td>主键</td>\n<td>用户名，不可重复</td>\n<td>密码</td>\n<td>已经申请的container数量</td>\n<td>已经申请的container的名称</td>\n<td>最多可以申请的container数量</td>\n<td>已经申请的虚拟机的数量</td>\n<td>已经申请的虚拟机的名称</td>\n<td>最多可以申请的虚拟机的数量</td>\n<td>是否是管理员</td>\n<td>用于验证身份的token</td>\n<td>上次登录时间</td>\n</tr>\n<tr>\n<td>notNull</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>yes</td>\n<td>yes</td>\n<td></td>\n</tr>\n<tr>\n<td>default</td>\n<td></td>\n<td></td>\n<td></td>\n<td>0</td>\n<td>null</td>\n<td>1</td>\n<td>0</td>\n<td>null</td>\n<td>1</td>\n<td>0</td>\n<td></td>\n<td>null</td>\n</tr>\n<tr>\n<td>autoIncrease</td>\n<td>yes</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"处理请求的逻辑\"><a href=\"#处理请求的逻辑\" class=\"headerlink\" title=\"处理请求的逻辑\"></a>处理请求的逻辑</h3><img src=\"http://gohoy.top/i/2023/08/04/r5tcvh-1.png\" alt=\"image-20230804152329594\" style=\"zoom: 67%;\" />\n\n<h4 id=\"tomcat服务器如何把请求转发到对应的controller方法？\"><a href=\"#tomcat服务器如何把请求转发到对应的controller方法？\" class=\"headerlink\" title=\"tomcat服务器如何把请求转发到对应的controller方法？\"></a>tomcat服务器如何把请求转发到对应的controller方法？</h4><p>接下来以用户登录方法为例</p>\n<p>我们假设后端服务器的BASE_URL是<a href=\"http://localhost:8080/\">http://localhost:8080/</a></p>\n<ul>\n<li><p>前端使用POST请求访问了<a href=\"http://localhost:8080/user/login%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%90%BA%E5%B8%A6%E4%BA%86%E7%94%A8%E6%88%B7%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF\">http://localhost:8080/user/login，并且携带了用户的基本信息</a></p>\n</li>\n<li><p>tomcat检测到请求，将请求转发给Springboot框架</p>\n</li>\n<li><p>SpringBoot框架通过你的注解找到对应这个url对应的方法</p>\n<ul>\n<li><p>这个方法位于controller&#x2F;user&#x2F;UserController.class下</p>\n</li>\n<li><p>UserController.class这个文件需要注解</p>\n<ul>\n<li><img src=\"http://gohoy.top/i/2023/08/04/r5tald-1.png\" alt=\"image-20230804152933250\" style=\"zoom: 67%;\" />\n</li>\n<li><p><code>@CrossOrigin(&quot;*&quot;)</code></p>\n<p>允许跨域访问到这个方法</p>\n</li>\n<li><p><code>@ApiResponses</code></p>\n<p>插件Swagger的注解，用来整合所有api的信息，对于这个服务，可以在<a href=\"http://localhost:8080/swagger-ui.html%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E6%B3%A8%E5%86%8C%E7%9A%84api%EF%BC%8C%E5%B9%B6%E6%B5%8B%E8%AF%95\">http://localhost:8080/swagger-ui.html查看所有注册的api，并测试</a></p>\n</li>\n<li><p><code>@RestController()</code></p>\n<p>这个注解将这个类作为Restful风格的controller注册到SpringBoot框架中，</p>\n</li>\n<li><p><code>@RequestMapping(&quot;/user/&quot;)</code></p>\n<p>这个注解表示这个类接收url为<a href=\"http://localhost:8080/user/%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%B9%E6%B3%95%E8%AF%B7%E6%B1%82\">http://localhost:8080/user/的任意方法请求</a></p>\n</li>\n</ul>\n</li>\n<li><p>然后查看login的方法</p>\n<ul>\n<li><img src=\"http://gohoy.top/i/2023/08/04/r5t8ma-1.png\" alt=\"image-20230804153323097\" style=\"zoom:80%;\" />\n</li>\n<li><p><code>@PostMapping(&quot;/login&quot;)</code></p>\n<p>表示这个方法处理<a href=\"http://localhost:8080/user/login%E7%9A%84%E8%AF%B7%E6%B1%82\">http://localhost:8080/user/login的请求</a></p>\n</li>\n<li><p><code>@ApiResponse(description = &quot;用户登录&quot;)</code></p>\n<p>注册这个方法到swagger管理页面中，这个api的描述为“用户登录”</p>\n</li>\n<li><p><code>@RequestBody User user</code></p>\n<p>这是需要传入这个函数的参数，对应前端携带的用户信息。并把这个用户信息生成一个User类的对象</p>\n</li>\n<li><p>接下来就是对user对象进行操作。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"controller具体逻辑的实现流程\"><a href=\"#controller具体逻辑的实现流程\" class=\"headerlink\" title=\"controller具体逻辑的实现流程\"></a>controller具体逻辑的实现流程</h4><p>以根据用户名获取用户数据这个api为例</p>\n<p><img src=\"http://gohoy.top/i/2023/08/04/r6hzsn-1.png\" alt=\"image-20230804164347717\"></p>\n<ul>\n<li>它的返回值是CommonResult，这是我自定义的类（utils&#x2F;CommonResult.class），用于规范像前端返回的数据格式。</li>\n<li>调用了UserService的getUserByName方法<ul>\n<li><strong><img src=\"http://gohoy.top/i/2023/08/04/r7oqsr-1.png\" alt=\"image-20230804164546919\"></strong></li>\n<li>UserService这里只定义了一个接口，没有进行实现</li>\n</ul>\n</li>\n<li>UserServiceImpl.class文件实现了UserService接口的方法<ul>\n<li><img src=\"http://gohoy.top/i/2023/08/04/r8urkd-1.png\" style=\"zoom:67%;\" /></li>\n</ul>\n</li>\n<li>UserServiceImpl中又调用了UserDao中的方法来从数据库查询用户<ul>\n<li><img src=\"http://gohoy.top/i/2023/08/04/r9dp3f-1.png\"></li>\n<li>这里面什么都没写，因为它继承了BaseMapper类，BaseMapper是MyBatisPlus框架实现的类，其中已经有最基本的对数据库进行增删改查的方法。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"为什么要有这么多流程呢？直接把在controller文件中调用UserDao实现查询可以吗\"><a href=\"#为什么要有这么多流程呢？直接把在controller文件中调用UserDao实现查询可以吗\" class=\"headerlink\" title=\"为什么要有这么多流程呢？直接把在controller文件中调用UserDao实现查询可以吗\"></a>为什么要有这么多流程呢？直接把在controller文件中调用UserDao实现查询可以吗</h5><p>分出controller service dao三层是后端开发的规范，在比较复杂的后端逻辑时可以理清思路，便于实现。</p>\n<p>所以简单的业务逻辑是可以直接在controller实现的。</p>\n<h3 id=\"controller文件中实现api\"><a href=\"#controller文件中实现api\" class=\"headerlink\" title=\"controller文件中实现api\"></a>controller文件中实现api</h3><h4 id=\"一般的api，简单的增删改查\"><a href=\"#一般的api，简单的增删改查\" class=\"headerlink\" title=\"一般的api，简单的增删改查\"></a>一般的api，简单的增删改查</h4><h5 id=\"AdminPodController：管理员Pod管理api\"><a href=\"#AdminPodController：管理员Pod管理api\" class=\"headerlink\" title=\"AdminPodController：管理员Pod管理api\"></a><code>AdminPodController</code>：管理员Pod管理api</h5><ul>\n<li><code>/getAllPods/&#123;type&#125;)</code>：获取所有pod信息<ul>\n<li>使用kubernetesClient获取所有pod，将pod进行筛选，除去系统pod</li>\n<li>将剩下的pod每一个都构建成PodInfo的对象，返回List<PodInfo></li>\n</ul>\n</li>\n<li><code>/setCtrDefaultResource/</code>：设置默认的pod资源，需要传入PodResourceDTO对象<ul>\n<li>这个api实现的方法是：将podResourceDTO对象的属性存放在k8s集群中的configMap中。</li>\n</ul>\n</li>\n<li><code>/setVMDefaultResource/</code>：与<code>/setCtrDefaultResource/</code>同理</li>\n<li><code>/getDefaultConfig/&#123;type&#125;</code>：根据字符串type获取不同的configMap</li>\n</ul>\n<h5 id=\"AdminUserController：管理员用户管理api：\"><a href=\"#AdminUserController：管理员用户管理api：\" class=\"headerlink\" title=\"AdminUserController：管理员用户管理api：\"></a><code>AdminUserController</code>：管理员用户管理api：</h5><ul>\n<li><code>/getUserByName/&#123;username&#125;</code>：通过用户名从数据库查询该用户的信息</li>\n<li><code>/getUsersByPage/&#123;pageNum&#125;/&#123;pageSize&#125;</code>：分页获取全部用户，使用了MyBatisPlus内置的分页方法。</li>\n<li><code>/updateUser</code>：更新用户信息</li>\n<li><code>/deleteUser/&#123;id&#125;</code>：通过id删除用户</li>\n</ul>\n<h5 id=\"PodController：用户对pod的功能需求\"><a href=\"#PodController：用户对pod的功能需求\" class=\"headerlink\" title=\"PodController：用户对pod的功能需求\"></a><code>PodController</code>：用户对pod的功能需求</h5><ul>\n<li><code>/selectPodByUserName/&#123;username&#125;</code>：通过用户名查询该用户所拥有的pod。因为pod创建的时候的名称都是username-type-job-random的形式，这里通过把所有的pod导出，遍历筛选的方法获得目标。</li>\n<li><code>/deletePod/&#123;podName&#125;</code>：通过pod名称来删除pod</li>\n</ul>\n<h5 id=\"UserController：用户登录注册和其他对自己信息的管理\"><a href=\"#UserController：用户登录注册和其他对自己信息的管理\" class=\"headerlink\" title=\"UserController：用户登录注册和其他对自己信息的管理\"></a><code>UserController</code>：用户登录注册和其他对自己信息的管理</h5><ul>\n<li><code>/register</code>：传入用户名，密码，只要数据库中没有这个用户就进行插入。</li>\n<li><code>/getUserDTO/&#123;username&#125;</code>：通过用户名，获取除了密码以外的所有信息。</li>\n<li><code>/getIndex</code>：前端主页显示的内容，通过此处获取index.md进行展示</li>\n</ul>\n<h4 id=\"较为复杂的api逻辑分析\"><a href=\"#较为复杂的api逻辑分析\" class=\"headerlink\" title=\"较为复杂的api逻辑分析\"></a>较为复杂的api逻辑分析</h4><h5 id=\"PodController：用户对pod的功能需求-1\"><a href=\"#PodController：用户对pod的功能需求-1\" class=\"headerlink\" title=\"PodController：用户对pod的功能需求\"></a><code>PodController</code>：用户对pod的功能需求</h5><ul>\n<li><code>/createCtr/&#123;username&#125;</code>：用户开启一个pod<ul>\n<li>使用username获取用户信息，判断用户是否还有可用的pod数量。</li>\n<li>从configmap中获取该类型pod的资源数量</li>\n<li>按照资源限制依次创建PV，PVC，Service，Job。PV和PVC用来持久化用户信息，Service用来暴露pod的ssh端口，Job用来控制pod的属性（比如存活时间等）</li>\n<li>创建成功之后将clusterIp，sshPort，rootPassword返回。</li>\n</ul>\n</li>\n<li><code>/createVm/&#123;username&#125;</code>：TODO</li>\n</ul>\n<h5 id=\"UserController：用户登录注册和其他对自己信息的管理-1\"><a href=\"#UserController：用户登录注册和其他对自己信息的管理-1\" class=\"headerlink\" title=\"UserController：用户登录注册和其他对自己信息的管理\"></a><code>UserController</code>：用户登录注册和其他对自己信息的管理</h5><ul>\n<li><code>/login</code>：用户登录，传入username和password<ul>\n<li>首先验证用户名密码是否正确</li>\n<li>然后按照用户的username，isAdmin属性来使用jwt生成一个token。过期时间默认一周</li>\n<li>然后纠正用户可用的pod数量，因为当pod的job自然结束后，没有钩子函数能够通知我们去修改用户可用pod数量。所以这里在登录的时候进行扫描纠正。</li>\n<li>返回给前端token，前端在访问其他api的时候都需要在cookie中携带username和token</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"kubevirt相关api实现的步骤\"><a href=\"#kubevirt相关api实现的步骤\" class=\"headerlink\" title=\"kubevirt相关api实现的步骤\"></a>kubevirt相关api实现的步骤</h3><h4 id=\"走通使用kubevirt进行创建虚拟机的过程，并选取一个最终实现的方案\"><a href=\"#走通使用kubevirt进行创建虚拟机的过程，并选取一个最终实现的方案\" class=\"headerlink\" title=\"~~ 走通使用kubevirt进行创建虚拟机的过程，并选取一个最终实现的方案~~\"></a>~~ 走通使用kubevirt进行创建虚拟机的过程，并选取一个最终实现的方案~~</h4><h5 id=\"将虚拟机镜像传给pvc，然后使用这个pvc创建一个vm（已完成）\"><a href=\"#将虚拟机镜像传给pvc，然后使用这个pvc创建一个vm（已完成）\" class=\"headerlink\" title=\"将虚拟机镜像传给pvc，然后使用这个pvc创建一个vm（已完成）\"></a><del>将虚拟机镜像传给pvc，然后使用这个pvc创建一个vm（已完成）</del></h5><h5 id=\"使用数据类型datavolume来创建虚拟机\"><a href=\"#使用数据类型datavolume来创建虚拟机\" class=\"headerlink\" title=\"使用数据类型datavolume来创建虚拟机\"></a><del>使用数据类型datavolume来创建虚拟机</del></h5><p><del>优势：可以通过一个模板来clone虚拟机。通过快照来保存虚拟机的数据</del></p>\n<p><del>但是从来没有用过这种方法。可行性待验证</del></p>\n<h4 id=\"通过kubevirt提供的api，实现这个方案\"><a href=\"#通过kubevirt提供的api，实现这个方案\" class=\"headerlink\" title=\"~~ 通过kubevirt提供的api，实现这个方案~~\"></a>~~ 通过kubevirt提供的api，实现这个方案~~</h4><h5 id=\"首先要对请求进行鉴权配置（已完成）\"><a href=\"#首先要对请求进行鉴权配置（已完成）\" class=\"headerlink\" title=\"~~ 首先要对请求进行鉴权配置（已完成）~~\"></a>~~ 首先要对请求进行鉴权配置（已完成）~~</h5><p><del>k8s默认api需要进行证书验证。所以如果直接访问api地址会被拦截。</del></p>\n<p><del>我仿照kubernetesClient进行了证书验证的操作。此项已完成</del></p>\n<h5 id=\"验证将pod配置序列化为请求体正常发送请求的方法\"><a href=\"#验证将pod配置序列化为请求体正常发送请求的方法\" class=\"headerlink\" title=\"~~ 验证将pod配置序列化为请求体正常发送请求的方法~~\"></a>~~ 验证将pod配置序列化为请求体正常发送请求的方法~~</h5><p><del>因为在api中，pod的配置全部都被放在请求体中，而Java存储这些配置的方法是生成一个类。</del></p>\n<p><del>这里需要去验证如何把类中的数据正确传递给k8s</del></p>\n<h4 id=\"kubevirt最终方案\"><a href=\"#kubevirt最终方案\" class=\"headerlink\" title=\"kubevirt最终方案\"></a>kubevirt最终方案</h4><p>使用脚本监听文件修改，通过监听文件修改来执行kubectl命令来进行虚拟机操作（当前使用的方案）</p>\n<pre><code class=\"sh\">#!/bin/bash\n\n# 目标目录\n\ntarget_directory=&quot;/data/upload_pvc_commands&quot;\n\n# 启动监听\n\ninotifywait -m -e create -e moved_to &quot;$target_directory&quot; |\n    while read path action file; do\n        if [[ &quot;$file&quot; == *.vm ]]; then\n            vm_name=&quot;$&#123;file%.vm&#125;&quot;\n            echo $vm_name\n            IMAGE_PATH=&quot;/home/gohoy/iso/ubuntu-20.04.qcow2&quot;\n            PV_NAME=&quot;$vm_name-pv&quot;\n            PVC_NAME=&quot;$vm_name-pvc&quot;\n            PVC_SIZE=&quot;45Gi&quot;\n            UPLOADPROXY_URL=$(kubectl -n cdi get svc -l cdi.kubevirt.io=cdi-uploadproxy | awk &#39;/cdi-uploadproxy/ &#123;print $3&#125;&#39;)\n            WAIT_SECS=&quot;240&quot;\n            echo &quot;upload images to $PVC_NAME&quot;\n            sed -e &quot;4s/pv/$PV_NAME/; 14s/pv/$PV_NAME/; 19s/pv/$PV_NAME/; 29s/pv/$PV_NAME/&quot; /data/upload_pvc_commands/pv.yaml &gt;/data/upload_pvc_commands/tmppv.yaml\n            kubectl apply -f /data/upload_pvc_commands/tmppv.yaml\n            # sed -e &quot;4s/pvc/$PVC_NAME/; 11s/45Gi/$PVC_SIZE/ &quot; /data/upload_pvc_commands/pvc.yaml &gt;/data/upload_pvc_commands/tmppvc.yaml\n            chmod -R 777 /data/*\n            virtctl image-upload --image-path=&quot;$IMAGE_PATH&quot; --pvc-name=&quot;$PVC_NAME&quot; \\\n                --pvc-size=&quot;$PVC_SIZE&quot; --uploadproxy-url=&quot;$UPLOADPROXY_URL&quot; \\\n                --insecure --wait-secs=&quot;$WAIT_SECS&quot;\n\n             chmod -R 777 /data/*\n             virtctl image-upload --image-path=&quot;$IMAGE_PATH&quot; --pvc-name=&quot;$PVC_NAME&quot; \\\n                --pvc-size=&quot;$PVC_SIZE&quot; --uploadproxy-url=&quot;$UPLOADPROXY_URL&quot; \\\n                --insecure --wait-secs=&quot;$WAIT_SECS&quot;\n\n            echo &quot;upload images done&quot;\n            sed -e &quot;4s/vm/$vm_name/; 11s/vm/$vm_name/; 33s/pvc/$vm_name-pvc/&quot; /data/upload_pvc_commands/vm.yaml &gt;/data/upload_pvc_commands/tmpvm.yaml\n\n            kubectl apply -f /data/upload_pvc_commands/tmpvm.yaml\n            rm -f /data/upload_pvc_commands/$vm_name.vm\n\n        elif [[ &quot;$file&quot; == *.delete ]]; then\n            vm_name=&quot;$&#123;file%.delete&#125;&quot;\n            echo &quot;Deleting VM: $vm_name&quot;\n            kubectl delete vm &quot;$vm_name&quot;\n            kubectl delete pvc &quot;$vm_name-pvc&quot;\n            kubectl delete pv &quot;$vm_name-pv&quot;\n\n            rm -f &quot;$target_directory/$vm_name.delete&quot;\n\n        fi\n\n    done\n</code></pre>\n<h2 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h2><h3 id=\"前端代码包\"><a href=\"#前端代码包\" class=\"headerlink\" title=\"前端代码包\"></a>前端代码包</h3><p><img src=\"http://gohoy.top/i/2023/08/14/qm6mnh-1.png\" alt=\"image-20230814160921521\"></p>\n<ul>\n<li>node_modules：所有前端组件的目录。由npm管理</li>\n<li>public：放一些公共文件，比如网站的头像，index.html</li>\n<li>src：主要代码的存放处<ul>\n<li>assets：静态资源</li>\n<li>components：组件，需要重复使用的部分</li>\n<li>router：路由，管理页面的跳转</li>\n<li>views：主要的页面存放处</li>\n<li>App.vue：整个项目的入口</li>\n<li>main.js：整个项目的配置文件</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"前端文件的架构\"><a href=\"#前端文件的架构\" class=\"headerlink\" title=\"前端文件的架构\"></a>前端文件的架构</h3><img src=\"http://gohoy.top/i/2023/08/14/qqtpor-1.png\" alt=\"image-20230814161708391\" style=\"zoom:67%;\" />\n\n<p>页面的入口是App.vue</p>\n<p>App.vue中的<code>   &lt;router-view&gt;&lt;/router-view&gt;</code>是这个页面被渲染的地方。</p>\n<h2 id=\"框架的使用说明\"><a href=\"#框架的使用说明\" class=\"headerlink\" title=\"框架的使用说明\"></a>框架的使用说明</h2><h3 id=\"NPM\"><a href=\"#NPM\" class=\"headerlink\" title=\"NPM\"></a>NPM</h3><p>NodeJs提供的包管理工具</p>\n<p>npm install <packageName> 安装某个包</p>\n<p>npm install 按照npm的配置文件package.json来安装所有依赖</p>\n<p>在前端项目中，需要Node注意版本。</p>\n<p>npm run <option> 将项目运行，一般会有 serve 和build 选项。前者用于开发。后者将项目打包，用于部署</p>\n<h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><p>vue ui：开启一个webCli来进行vue项目管理</p>\n<p>vue init <packageName> 创建一个vue项目（可以在web页面进行）</p>\n<h3 id=\"VueRouter\"><a href=\"#VueRouter\" class=\"headerlink\" title=\"VueRouter\"></a>VueRouter</h3><pre><code class=\"sh\">npm install vue-router\n//在创建vue项目的时候可以选择直接安装\n</code></pre>\n<p>用于页面跳转，整合在整个vue项目中。</p>\n<pre><code class=\"js\">//   router/index.js示例\nimport &#123; createRouter, createWebHashHistory &#125; from &#39;vue-router&#39;\nimport IndexView from &#39;@/views/indexView.vue&#39;\nconst routes = [\n  &#123;\n    path: &#39;/index&#39;,\n    name: &#39;home&#39;,\n    component: IndexView\n  &#125;\n]\n\nconst router = createRouter(&#123;\n  history: createWebHashHistory(),\n  routes\n&#125;)\n\nexport default router\n</code></pre>\n<pre><code class=\"js\">// main.js中需要配置如下\nimport &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport router from &#39;./router&#39;\n\nconst app = createApp(App);\napp.use(router).mount(&#39;#app&#39;)\n</code></pre>\n<p>这样之后，就可以访问项目地址&#x2F;index进入页面IndexView</p>\n<h3 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h3><pre><code class=\"sh\">npm insatll axios\n</code></pre>\n<p>用于发送http请求</p>\n<pre><code class=\"js\">import &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport router from &#39;./router&#39;\nimport axios from &#39;axios&#39;\naxios.defaults.baseURL = &quot;http://localhost:8080/&quot;\n//设置基本路径，在之后的请求中不需要重复输入这段url\naxios.interceptors.request.use((config) =&gt; &#123;\n    const token = Cookies.get(&#39;token&#39;);\n    const username = Cookies.get(&#39;username&#39;);\n    if (token) &#123;\n        config.headers[&#39;Authorization&#39;] = token;\n    &#125;\n\n    if (username) &#123;\n        config.headers[&#39;X-Username&#39;] = username;\n    &#125;\n\n    config.headers[&#39;Referrer-Policy&#39;] = &#39;no-referrer&#39;\n    return config;\n&#125;);\n//这个interceptor用来解决跨域问题\nconst app = createApp(App);\napp.config.globalProperties.$axios = axios\napp.config.globalProperties.$http = axios\n// 将axios的别名设置为$axios或者$http\napp.use(router).mount(&#39;#app&#39;)\n</code></pre>\n<p>示例使用</p>\n<pre><code class=\"js\">        async handleLogin() &#123;\n            const response = await this.$axios.post(&#39;/user/login&#39;, this.userData).then(response =&gt; &#123;\n                if (response.data.code == &quot;200&quot;) &#123;\n                    Cookies.set(&#39;token&#39;, response.data.data);\n                    Cookies.set(&#39;username&#39;, this.userData.username);\n                    ElMessage.info(response.data.message)\n                    location.reload();\n                &#125; else &#123;\n                    ElMessage.error(response.data.message)\n                &#125;\n            &#125;)\n\n        &#125;,\n</code></pre>\n<p>这里使用post请求访问<a href=\"http://localhost:8080/user/login%EF%BC%8C%E5%B9%B6%E5%9C%A8requestBody%E4%B8%AD%E6%90%BA%E5%B8%A6%E4%BA%86%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E3%80%82%E5%B9%B6%E5%B0%86%E5%BE%97%E5%88%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%94%BE%E5%9C%A8response%E4%B8%AD%E3%80%82%E4%B9%8B%E5%90%8E%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C\">http://localhost:8080/user/login，并在requestBody中携带了用户登录信息。并将得到的返回值放在response中。之后进行操作</a></p>\n<h3 id=\"ElementPlus\"><a href=\"#ElementPlus\" class=\"headerlink\" title=\"ElementPlus\"></a>ElementPlus</h3><p><a href=\"https://element-plus.org/zh-CN/guide/quickstart.html#%E7%94%A8%E6%B3%95\">查看官方使用文档</a></p>\n<h3 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h3><p>包配置文件在项目根目录的pom.xml中</p>\n<p>基本示例</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;3.1.2&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.example&lt;/groupId&gt;\n    &lt;artifactId&gt;home-gohoy-k8s_backend&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;demo&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;17&lt;/java.version&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-kubernetes-fabric8-all&lt;/artifactId&gt;\n            &lt;version&gt;3.0.3&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre>\n<p>主要需要添加依赖的是dependency标签。</p>\n<p>修改完成后，使用mvn install 进行安装依赖</p>\n<p>mvn package 按照build标签把项目进行打包，用于部署</p>\n<p>配置文件：一般是根目录的.m2&#x2F;setting.xml</p>\n<p>maven换源：</p>\n<pre><code class=\"xml\">    &lt;mirror&gt;\n          &lt;id&gt;nexus-aliyun&lt;/id&gt;\n          &lt;name&gt;Nexus aliyun&lt;/name&gt;\n        &lt;mirrorOf&gt;external:*&lt;/mirrorOf&gt;\n          &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;\n      &lt;/mirror&gt;\n</code></pre>\n<p>在mirrors标签中加入这些即可</p>\n<h3 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h3><p>Maven包设置：</p>\n<pre><code class=\"xml\">    &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n            &lt;version&gt;3.1.2&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n            &lt;version&gt;3.1.0&lt;/version&gt;\n            &lt;scope&gt;compile&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>配置：</p>\n<pre><code class=\"yaml\">spring:\n  application:\n    name:k8s-web\nserver:\n  port: 8080\n</code></pre>\n<p>主启动类的格式：</p>\n<pre><code class=\"java\">@SpringBootApplication\npublic class K8sWebMainApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(K8sWebMainApplication.class, args);\n    &#125;\n&#125;\n</code></pre>\n<p>这些是最基本的，且不变的。</p>\n<p>可能会需要其他配置。在类名前加上不同的注解。</p>\n<p>运行这个类，SpringBoot就会在指定端口开启一个tomcat服务器用来接收http请求。（默认8080）</p>\n<p>配置文件默认在项目根目录&#x2F;resources&#x2F;application.yaml（或者application.application）</p>\n<h3 id=\"MyBatisPlus\"><a href=\"#MyBatisPlus\" class=\"headerlink\" title=\"MyBatisPlus\"></a>MyBatisPlus</h3><p>Maven包引用</p>\n<pre><code class=\"xml\">    &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.5.3.1&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>用来简化SpringBoot和数据库的操作</p>\n<p>配置：</p>\n<pre><code class=\"yaml\"># applicaiton.yaml\nmybatis-plus:\n  mapper-locations: classpath:mapper/*.xml\n</code></pre>\n<p>这里配置了mapper的路径，让SpringBoot能够找到Mybatis的系列配置，但是基础的crud用不到这些mapper文件</p>\n<p>基础使用：</p>\n<pre><code class=\"java\">// dao文件需要继承BaseMapper&lt;entity&gt;，里面实现的基础的crud\n@Table(name = &quot;users&quot;)\npublic interface UserDao extends BaseMapper&lt;User&gt; &#123;\n&#125;\n</code></pre>\n<pre><code class=\"java\">// service文件需要继承Iservice&lt;entity&gt;，里面定义了基本的crud接口\npublic interface UserService extends IService&lt;User&gt; &#123;\n&#125;\n</code></pre>\n<pre><code class=\"java\">// 在serviceImpl文件中继承 ServiceImpl&lt;Dao文件 , entity&gt; ，里面实现了Iservice&lt;entity&gt;的接口\n@Service\npublic class UserServiceImpl extends ServiceImpl&lt;UserDao , User&gt; implements UserService &#123;\n&#125;\n</code></pre>\n<h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><p>这里准备使用docker来启动</p>\n<p><code>docker run --name mysql  --restart=always -p 3306:3306 \\ -e &quot;MYSQL_ROOT_PASSWORD=040424&quot; mysql </code></p>\n<p>修改远程连接：<code>update user set host=&#39;*&#39; where user=&#39;root&#39;&amp;&amp; host=&#39;localhost&#39;; flush privileges;</code></p>\n<p>然后使用可视化工具比如MySQLWorkBrench来进行表的设计和操作。</p>\n<p>Maven包配置</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;version&gt;8.0.33&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>SpringBoot配置</p>\n<pre><code class=\"yam\">spring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/k8s?user=root&amp;password=040424&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=Asia/Shanghai\n    driver-class-name: com.mysql.cj.jdbc.Driver\n</code></pre>\n<p>这里主要要配置url。</p>\n<p>在这里配置之后，MyBatisPlus的curd操作就能够找到数据源</p>\n<h3 id=\"SpringCloudKubernetes\"><a href=\"#SpringCloudKubernetes\" class=\"headerlink\" title=\"SpringCloudKubernetes\"></a>SpringCloudKubernetes</h3><p>Maven 配置</p>\n<pre><code class=\"xml\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-kubernetes-fabric8-all&lt;/artifactId&gt;\n            &lt;version&gt;3.0.3&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>SpringBoot 配置</p>\n<pre><code class=\"yaml\">spring:\n  cloud:\n    kubernetes:\n      discovery:\n        enabled: true\n</code></pre>\n<p>基本使用：首先要把k8s的配置文件默认在&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf  复制到用户根目录的 .kube&#x2F;config</p>\n<p>然后开始编码：</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.config;\n\nimport io.fabric8.kubernetes.client.*;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class KubernetesConfig &#123;\n\n    @Bean\n    public KubernetesClient kubernetesClient() &#123;\n        Config config = new ConfigBuilder().withMasterUrl(&quot;https://192.168.111.140:6443&quot;).build();\n        return new KubernetesClientBuilder().withConfig(config).build();\n    &#125;\n&#125;\n</code></pre>\n<p>这段代码将kubernetesClient注入到SpringBoot容器中，生成一个实例。</p>\n<p>然后使用的时候直接调用它提供的api</p>\n<pre><code class=\"java\">   config = new Namespace();\n   ObjectMeta metadata = new ObjectMeta();\n   metadata.setName(&quot;default&quot;);\n   config.setMetadata(metadata);\n   kubernetesClient.resource(config).createOrReplace();\n</code></pre>\n<p>这段代码使用kubernetesClient创建了一个namespace config</p>\n<h3 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h3><p>用来生成token，来进行鉴权</p>\n<p>Maven配置</p>\n<pre><code class=\"xml\">        &lt;dependency&gt;\n            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n            &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;\n            &lt;version&gt;0.11.5&lt;/version&gt; &lt;!-- Replace with the latest version --&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n            &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;\n            &lt;version&gt;0.11.5&lt;/version&gt; &lt;!-- Replace with the latest version --&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n            &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;\n            &lt;version&gt;0.11.5&lt;/version&gt; &lt;!-- Replace with the latest version --&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>自定义一个JWTUtil.java</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.utils;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\n\nimport javax.crypto.spec.SecretKeySpec;\nimport java.nio.charset.StandardCharsets;\nimport java.security.Key;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class JWTUtils &#123;\n    private static final String SECRET_KEY = &quot;TheFurthestDistanceInTheWorldIsNotBetweenLifeAndDeathButWhenIStandInFrontOfYouYetYouDonNotKnowThatILoveYou&quot;;\n    // 生成JWT令牌\n    public static String generateToken(String username,byte isAdmin, long expirationMillis) &#123;\n        Date now = new Date();\n        Date expiration = new Date(now.getTime() + expirationMillis);\n        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();\n        // 在claims中添加用户信息或其他声明\n        claims.put(&quot;username&quot;, username);\n        claims.put(&quot;isAdmin&quot;,isAdmin);\n        // 可以添加更多的声明，比如用户角色等\n        byte[] apiKeySecretBytes = SECRET_KEY.getBytes(StandardCharsets.UTF_8);\n        Key signingKey = new SecretKeySpec(apiKeySecretBytes, SignatureAlgorithm.HS256.getJcaName());\n        return Jwts.builder()\n                .setClaims(claims)\n                .setIssuedAt(now)\n                .setExpiration(expiration)\n                .signWith(signingKey)\n                .compact();\n    &#125;\n    // 验证JWT令牌，如果验证失败将抛出异常，否则返回声明（claims）\n    public static Claims verifyToken(String token) &#123;\n        byte[] apiKeySecretBytes = SECRET_KEY.getBytes(StandardCharsets.UTF_8);\n        Key signingKey = new SecretKeySpec(apiKeySecretBytes, SignatureAlgorithm.HS256.getJcaName());\n        return Jwts.parserBuilder()\n                .setSigningKey(signingKey)\n                .build()\n                .parseClaimsJws(token)\n                .getBody();\n    &#125;\n&#125;\n</code></pre>\n<p>提供两个方法</p>\n<ul>\n<li>generateToken：使用用户的username和isAdmin字段和过期时间和自定义的Sercert_Key来混淆生成一个token</li>\n<li>verifyToken：将token进行解码，并返回</li>\n</ul>\n<p>基本使用：</p>\n<p>在登录成功后生成一个token，在接收到前端的请求时，使用token进行鉴权。</p>\n<h3 id=\"Lombok\"><a href=\"#Lombok\" class=\"headerlink\" title=\"Lombok\"></a>Lombok</h3><p>用来快速生成类的get set方法，快速标记链式编程等</p>\n<p>Maven配置：</p>\n<pre><code class=\"xml\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.26&lt;/version&gt;\n            &lt;scope&gt;compile&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>基本使用：</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.entities;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.example.home.gohoy.k8s_backend.dto.UserDTO;\nimport jakarta.persistence.*;\nimport lombok.Data;\nimport java.sql.Timestamp;\nimport java.util.Objects;\n@Data\n@Entity\n@TableName(&quot;users&quot;)\n@Table(name = &quot;users&quot;, schema = &quot;k8s&quot;)\npublic class User  extends UserDTO&#123;\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Id\n    @Column(name = &quot;id&quot;)\n    private int id;\n    @Basic\n    @Column(name = &quot;password&quot;)\n    private String password;\n&#125;\n</code></pre>\n<p>直接注解@Data</p>\n<p>自动为下面的属性id 和password生成get set方法</p>\n<h3 id=\"Swagger\"><a href=\"#Swagger\" class=\"headerlink\" title=\"Swagger\"></a>Swagger</h3><p>Maven配置</p>\n<pre><code class=\"xm\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;\n            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;\n            &lt;version&gt;2.0.4&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>基本使用：</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.controller.admin;\n\nimport com.example.home.gohoy.k8s_backend.dao.UserDao;\nimport com.example.home.gohoy.k8s_backend.dto.UserDTO;\nimport com.example.home.gohoy.k8s_backend.entities.User;\nimport com.example.home.gohoy.k8s_backend.service.user.UserService;\nimport com.example.home.gohoy.k8s_backend.utils.CommonResult;\nimport io.swagger.v3.oas.annotations.responses.ApiResponse;\nimport jakarta.annotation.Resource;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@CrossOrigin(&quot;*&quot;)\n@ApiResponse\n@RequestMapping(&quot;/admin/&quot;)\npublic class AdminUserController &#123;\n    @Resource\n    private UserService userService;\n    @Resource\n    private UserDao userDao;\n    @GetMapping(&quot;/getUserByName/&#123;username&#125;&quot;)\n    @ApiResponse(description = &quot;通过参数userName获取user数据&quot;)\n    private CommonResult getUserByName(@PathVariable(&quot;username&quot;) String userName)&#123;\n  &#125;\n    @GetMapping(&quot;/getUsersByPage/&#123;pageNum&#125;/&#123;pageSize&#125;&quot;)\n    @ApiResponse(description = &quot;分页获取所有用户&quot;)\n    private CommonResult getUsers(@PathVariable(&quot;pageNum&quot;) int pageNum,@PathVariable(&quot;pageSize&quot;)int pageSize)&#123;\n    &#125;\n    @PostMapping(&quot;/updateUser&quot;)\n    @ApiResponse(description = &quot;更新用户信息&quot;)\n    public CommonResult updateUser(@RequestBody User user )&#123;\n\n    &#125;\n&#125;\n</code></pre>\n<p>@ApiResponses：标记这个类是定义了很多api</p>\n<p>@ApiResponse（description&#x3D;”这里是api的描述”）：标记这个方法是一个api</p>\n<p>然后在项目运行的url，例如：localhost:8080&#x2F;swagger-ui.html可以查看这些api，并且可以进行测试</p>\n<h3 id=\"Interceptor\"><a href=\"#Interceptor\" class=\"headerlink\" title=\"Interceptor\"></a>Interceptor</h3><p>Maven配置</p>\n<pre><code class=\"xml\">&lt;!--\t\tservlet--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.1&lt;/version&gt; &lt;!-- Replace with the appropriate version --&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>Interceptor主要实现接口HandlerInterceptor的方法preHandle</p>\n<p>这个方法是在controller处理请求前执行的。</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.utils.interceptors;\n\nimport com.example.home.gohoy.k8s_backend.utils.JWTUtils;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport javax.servlet.http.HttpServletResponse;\n@Component\npublic class AdminInterceptor implements HandlerInterceptor &#123;\n\n    @Override\n    public boolean preHandle(jakarta.servlet.http.HttpServletRequest request, jakarta.servlet.http.HttpServletResponse response, Object handler) throws Exception &#123;\n        if(request.getMethod().equals(&quot;OPTIONS&quot;))&#123;\n            return true;\n        &#125;\n        System.out.println(&quot;AdminInterceptor&quot;);\n        // 从请求头部获取 Authorization Cookie\n        String token = request.getHeader(&quot;Authorization&quot;);\n\n        if  (JWTUtils.verifyToken(token).get(&quot;isAdmin&quot;).equals(1))&#123;\n            return true;\n        &#125;else &#123;\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            return false;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这段代码的逻辑，就在拦截请求，通过token来获取用户的username，然后从数据库查询是否存在admin权限。</p>\n<p>拦截器SpringBoot注入文件</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class InterceptorConfig implements WebMvcConfigurer &#123;\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        registry.addInterceptor(new AdminInterceptor())\n                .addPathPatterns(&quot;/admin/**&quot;);\n        registry.addInterceptor(new LoginInterceptor())\n                .addPathPatterns(&quot;/**&quot;)\n                .excludePathPatterns(&quot;/user/login&quot;, &quot;/user/register&quot;, &quot;/swagger-ui.html&quot;, &quot;/swagger-ui/**&quot;,\n                        &quot;/webjars/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>这里exludePathPatterns是排除的路径，防止登录注册和swagger页面不能进入。</p>\n<h3 id=\"HttpClient（当前项目弃用）\"><a href=\"#HttpClient（当前项目弃用）\" class=\"headerlink\" title=\"HttpClient（当前项目弃用）\"></a>HttpClient（当前项目弃用）</h3><p>用来发送http请求。</p>\n<p>使用的原因：Kubevirt的Api没有整合好的Java包，需要自己进行http请求</p>\n<p>Maven配置：</p>\n<pre><code class=\"xml\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;\n            &lt;version&gt;4.5.14&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>进行kubevirt编程：</p>\n<p>1.鉴权：（是从kubernetesClient调试的来的）</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.utils;\n\nimport com.example.home.gohoy.k8s_backend.entities.kubevirt.*;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport io.fabric8.kubernetes.client.KubernetesClientException;\nimport jakarta.validation.constraints.NotNull;\nimport okhttp3.*;\nimport okhttp3.HttpUrl;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport org.springframework.stereotype.Component;\n\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.security.*;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.RSAPrivateCrtKeySpec;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.stream.Collectors;\n\n@Component\npublic class KubevirtUtil &#123;\n\n\n    private final String clientCertResource = &quot;&quot;;\n    private String caCertResource = &quot;&quot;;\nprivate TrustManager[] trustManagers;\n\n    public SSLContext preLoad() throws Exception &#123;\n//        System.out.println(caCertResource);\n//        System.out.println(clientCertResource);\n        String clientKeyResource = &quot;&quot;;\n//        System.out.println(clientKeyResource);\n        InputStream caCert = createInputStreamFromBase64EncodedString(caCertResource);\n        InputStream clientCert = createInputStreamFromBase64EncodedString(clientCertResource);\n        InputStream clientKey = createInputStreamFromBase64EncodedString(clientKeyResource);\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        KeyStore trustStore = KeyStore.getInstance(&quot;pkcs12&quot;);\n        char[] trustStorePassphrase = &quot;changeit&quot;.toCharArray();\n        trustStore.load(null);\n        while (caCert.available() &gt; 0) &#123;\n            CertificateFactory certFactory = CertificateFactory.getInstance(&quot;X509&quot;);\n            X509Certificate cert = (X509Certificate) certFactory.generateCertificate(caCert);\n            String alias = cert.getSubjectX500Principal().getName() + &quot;_&quot; + cert.getSerialNumber().toString(16);\n            trustStore.setCertificateEntry(alias, cert);\n        &#125;\n        tmf.init(trustStore);\n         trustManagers = tmf.getTrustManagers();\n      // clientKey clientCrt\n        CertificateFactory certFactory = CertificateFactory.getInstance(&quot;X509&quot;);\n        Collection&lt;? extends Certificate&gt; certificates = certFactory.generateCertificates(clientCert);\n        PrivateKey privateKey ;\n        byte[] keyBytes = decodePem(clientKey);\n        KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);\n        try &#123;\n            // First let&#39;s try PKCS8\n            privateKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(keyBytes));\n        &#125; catch (InvalidKeySpecException e) &#123;\n            // Otherwise try PKCS8\n            RSAPrivateCrtKeySpec keySpec = PKCS1Util.decodePKCS1(keyBytes);\n            privateKey= keyFactory.generatePrivate(keySpec);\n        &#125;\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keyStore.load(null);\n        String alias = certificates.stream().map(cert-&gt;((X509Certificate)cert).getIssuerX500Principal().getName()).collect(Collectors.joining(&quot;_&quot;));\n        keyStore.setKeyEntry(alias, privateKey, trustStorePassphrase, certificates.toArray(new Certificate[0]));\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        kmf.init(keyStore, trustStorePassphrase);\n        KeyManager[] keyManagers = kmf.getKeyManagers();\n\n        //sslContext\n        SSLContext sslContext ;\n        try &#123;\n             sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;);\n            sslContext.init(keyManagers, trustManagers, new SecureRandom());\n        &#125; catch (KeyManagementException | NoSuchAlgorithmException e) &#123;\n            throw KubernetesClientException.launderThrowable(e);\n        &#125;\n        return sslContext;\n    &#125;\n\n    public String sendHttpRequest(@NotNull String method,@NotNull String path, Headers headers, RequestBody requestBody) throws Exception &#123;\n        SSLContext sslContext = preLoad();\n\n        OkHttpClient httpClient = new OkHttpClient.Builder()\n                .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])\n                .hostnameVerifier((hostname, session) -&gt; true)\n                .build();\n\n        HttpUrl url = HttpUrl.parse(&quot;https://192.168.111.140:6443&quot; + path);\n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url)\n                .method(method, requestBody);\n        System.out.println(url);\n\n        if (headers != null) &#123;\n            requestBuilder.headers(headers);\n        &#125;\n\n        Request request = requestBuilder.build();\n\n        try (Response response = httpClient.newCall(request).execute()) &#123;\n            ResponseBody responseBody = response.body();\n            if (responseBody != null) &#123;\n                String result = responseBody.string();\n                System.out.println(result);\n                return result;\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        return null;\n    &#125;\n\n\n\n    private static ByteArrayInputStream createInputStreamFromBase64EncodedString(String data) &#123;\n        byte[] bytes;\n        try &#123;\n            bytes = Base64.getDecoder().decode(data);\n        &#125; catch (IllegalArgumentException illegalArgumentException) &#123;\n            bytes = data.getBytes();\n        &#125;\n\n        return new ByteArrayInputStream(bytes);\n    &#125;\n\n    private static byte[] decodePem(InputStream keyInputStream) throws IOException &#123;\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(keyInputStream))) &#123;\n            String line;\n            while ((line = reader.readLine()) != null) &#123;\n                if (line.contains(&quot;-----BEGIN &quot;)) &#123;\n                    return readBytes(reader, line.trim().replace(&quot;BEGIN&quot;, &quot;END&quot;));\n                &#125;\n            &#125;\n            throw new IOException(&quot;PEM is invalid: no begin marker&quot;);\n        &#125;\n    &#125;\n    private static byte[] readBytes(BufferedReader reader, String endMarker) throws IOException &#123;\n        String line;\n        StringBuilder buf = new StringBuilder();\n\n        while ((line = reader.readLine()) != null) &#123;\n            if (line.contains(endMarker)) &#123;\n                return Base64.getDecoder().decode(buf.toString());\n            &#125;\n            buf.append(line.trim());\n        &#125;\n        throw new IOException(&quot;PEM is invalid : No end marker&quot;);\n    &#125;\n\n\n\n    public String getRequestBody() throws JsonProcessingException &#123;\n        HashMap&lt;String, String&gt; labels = new HashMap&lt;&gt;();\n        labels.put(&quot;slt&quot;, &quot;vm-test-1&quot;);\n\n        ArrayList&lt;Disk&gt; disks = new ArrayList&lt;&gt;();\n        disks.add(new Disk().setName(&quot;containerinit&quot;).setBootOrder(1)\n                .setDisk(new DiskTarget().setBus(&quot;virtio&quot;))\n        );\n        ArrayList&lt;Interface&gt; interfaces = new ArrayList&lt;&gt;();\n        interfaces.add(new Interface().setName(&quot;default&quot;).setMasquerade(&quot;&#123;&#125;&quot;));\n\n        ArrayList&lt;Network&gt; networks = new ArrayList&lt;&gt;();\n        networks.add(new Network().setName(&quot;default&quot;).setPod(new PodNetwork()));\n\n        ArrayList&lt;Volume&gt; volumes = new ArrayList&lt;&gt;();\n        volumes.add(new Volume()\n                .setName(&quot;containerinit&quot;)\n                .setPersistentVolumeClaim(\n                        new PersistentVolumeClaimVolumeSource()\n                                .setClaimName(&quot;euler-test-1&quot;)\n                )\n        );\n\n        VirtualMachine virtualMachine = new VirtualMachine();\n        virtualMachine.setApiVersion(&quot;kubevirt.io/v1&quot;)\n                .setKind(&quot;VirtualMachine&quot;)\n                .setMetadata(new ObjectMeta().setName(&quot;vm-test-1&quot;))\n                .setSpec(new VirtualMachineSpec().setRunning(true)\n                        .setTemplate(new VirtualMachineInstanceTemplateSpec()\n                                .setMetadata(new ObjectMeta()\n                                        .setNamespace(&quot;default&quot;)\n                                        .setLabels(labels)\n                                ).setSpec(\n                                        new VirtualMachineInstanceSpec()\n                                                .setDomain(\n                                                        new DomainSpec().setDevices(new Devices()\n                                                                .setAutoattachGraphicsDevice(true)\n                                                                .setDisks(disks)\n                                                                .setInterfaces(interfaces)\n                                                        ).setResources(new ResourceRequirements()\n                                                                .setRequests(new Requests()\n                                                                        .setCpu(&quot;2&quot;)\n                                                                        .setMemory(&quot;1G&quot;)\n                                                                )\n                                                        )\n                                                ).setNetworks(networks)\n                                                .setVolumes(volumes)\n                                )\n                        )\n                );\n        ObjectMapper objectMapper = new ObjectMapper();\n        String requestBody = objectMapper.writeValueAsString(virtualMachine);\n        System.out.println(requestBody);\n        return  requestBody;\n    &#125;\n\n    public String sendHttpRequest(String method, String path) throws Exception &#123;\n        return sendHttpRequest(method,path,null,null);\n    &#125;\n&#125;\n</code></pre>\n<p>这里的密钥是从k8s的config中复制得到</p>\n<p>鉴权操作主要是进行了证书的配置。</p>\n<p>2.调用kubevirt Api（弃用）</p>\n<p>遇到的困难：缺少一个完整kubevirt环境进行测试。</p>\n<p>3.实现kubevirt的方案：使用脚本监听文件修改来执行sh命令。</p>\n<h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><p>在部署的环境使用，可以查看<a href=\"https://www.runoob.com/w3cnote/nginx-setup-intro.html\">这篇教程</a></p>\n<h3 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h3><p>Docker用于作为k8s的container runtime</p>\n<p>以及最终项目的打包部署</p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>可以参考一些文章。<a href=\"https://blog.csdn.net/qq_52030824/article/details/127982206\">vue+springboot docker部署</a></p>\n<p>基本步骤：</p>\n<p>前端vue 使用npm run build，得到打包后的文件dist，将这个文件放在docker内部nginx的指定目录下。</p>\n<p>后端springboot需要使用maven打包成jar包。打包过程参考<a href=\"https://www.cnblogs.com/sanjay/p/11828081.html\">教程</a></p>\n<p>得到这些包之后，编写dockerfile 文件，将这些容器整合运行。</p>\n<ul>\n<li>打包得到前端和后端的最终文件</li>\n<li>docker Java17环境<ul>\n<li>将jar包放入这个镜像，使用Java -jar xxx.jar来运行后台包</li>\n</ul>\n</li>\n<li>docker MySQL8.0.32环境<ul>\n<li>将数据库文件写入容器中</li>\n</ul>\n</li>\n<li>docker Nginx环境<ul>\n<li>将前端打包文件放入此容器，然后编写nginx配置文件。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实操步骤\"><a href=\"#实操步骤\" class=\"headerlink\" title=\"实操步骤\"></a>实操步骤</h3><ol>\n<li><p>后端配置好端口后使用maven的package命令打包，得到jar包</p>\n<ol>\n<li>修改端口，MySQL的url：把localhost修改成服务器ip</li>\n</ol>\n</li>\n<li><p>前端配置好端口后，使用npm build得到dist文件夹</p>\n<ol>\n<li>修改端口和后端的base_url：把base_url修改成服务器ip</li>\n</ol>\n</li>\n<li><p>然后docker拉取镜像openjdk:17  mysql:8.0.32  nginx:latest</p>\n</li>\n<li><p>然后写dockerfile文件，将jar包引入为镜像</p>\n<ol>\n<li><pre><code class=\"dockerfile\"># 使用合适的 JDK 17 基础镜像\nFROM openjdk:17\n\n# 复制 jar 包到容器\nCOPY home-gohoy-k8s_backend-0.0.1-SNAPSHOT.jar k8s_web.jar\n\n# 运行 jar 包\nCMD [&quot;java&quot;, &quot;-jar&quot;, &quot;/k8s_web.jar&quot;]\n\n# 暴露端口\nEXPOSE 8088\n</code></pre>\n</li>\n<li><p><code>docker build -t k8s-web-server:1.0 .</code></p>\n</li>\n<li><p>使用docker compose 配置项目需要的镜像的环境</p>\n<ol>\n<li><pre><code class=\"yaml\">version: &quot;3&quot;\nservices:\n  k8s-web:\n    image: k8s-web-server:1.0\n    ports:\n      - &quot;8088:8088&quot;\n    volumes:\n      - /data/upload_pvc_commands/:/data/upload_pvc_commands/\n      - /root/.kube/:/root/.kube/\n      - /home/gohoy/k8s_web_docker/assets/:/data/assets/\n  mysql:\n    image: mysql:8.0.32\n    container_name: mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: &#39;040424&#39;\n      MYSQL_ALLOW_EMPTY_PASSWORD: &#39;no&#39;\n      MYSQL_DATABASE: &#39;k8s&#39;\n    ports:\n       - &quot;3306:3306&quot;\n    networks:\n      - k8s_web_network\n\n\n  nginx:\n    image: nginx:latest\n    container_name: nginx\n    ports:\n      - &quot;80:80&quot;\n    volumes:\n      - /home/gohoy/k8s_web_docker/nginx/html:/usr/share/nginx/html\n      - /home/gohoy/k8s_web_docker/nginx/logs:/var/log/nginx\n      - /home/gohoy/k8s_web_docker/nginx/conf:/etc/nginx\n    networks:\n      - k8s_web_network\n\n# 创建自定义网络\nnetworks:\n   k8s_web_network:\n</code></pre>\n</li>\n<li><p>docker-compose up -d启动环境</p>\n</li>\n</ol>\n</li>\n<li><p>配置nginx</p>\n<ol>\n<li><p>在&#x2F;home&#x2F;gohoy&#x2F;k8s_web_docker&#x2F;nginx&#x2F;conf下配置nginx 的配置文件，nginx.conf 和 mime.types 是从容器里面copy出来的默认配置，如何在conf.d中放入 k8s_web.conf文件</p>\n</li>\n<li><pre><code class=\"conf\">server &#123;\n    listen 80;\n    location / &#123;\n        root /usr/share/nginx/html/dist; # 根据您的目录配置\n        index index.html;\n    &#125;\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log;\n&#125;\n</code></pre>\n</li>\n<li><p>把前端vue打包好的dist文件放在&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;下面</p>\n</li>\n</ol>\n</li>\n<li><p>配置MySQL</p>\n<ol>\n<li>直接在自己电脑使用MySQL work branch（或者同类工具如navicat）连接</li>\n<li>刷入sql脚本文件</li>\n</ol>\n</li>\n<li><p>启动主机上 <code>/home/gohoy/k8s_web_docker/watch_and_execute.sh</code>，这个脚本来监听&#x2F;data&#x2F;upload_pvc_commands&#x2F;文件夹，通过监听文件修改来执行kubevirt相关的命令</p>\n<ol>\n<li><pre><code class=\"sh\">#!/bin/bash\n\n# 目标目录\n\ntarget_directory=&quot;/data/upload_pvc_commands&quot;\n\n# 启动监听\n\ninotifywait -m -e create -e moved_to &quot;$target_directory&quot; |\n    while read path action file; do\n        if [[ &quot;$file&quot; == *.vm ]]; then\n            vm_name=&quot;$&#123;file%.vm&#125;&quot;\n            echo $vm_name\n            IMAGE_PATH=&quot;/home/gohoy/iso/ubuntu-20.04.qcow2&quot;\n            PV_NAME=&quot;$vm_name-pv&quot;\n            PVC_NAME=&quot;$vm_name-pvc&quot;\n            PVC_SIZE=&quot;45Gi&quot;\n            UPLOADPROXY_URL=$(kubectl -n cdi get svc -l cdi.kubevirt.io=cdi-uploadproxy | awk &#39;/cdi-uploadproxy/ &#123;print $3&#125;&#39;)\n            WAIT_SECS=&quot;240&quot;\n            echo &quot;upload images to $PVC_NAME&quot;\n            sed -e &quot;4s/pv/$PV_NAME/; 14s/pv/$PV_NAME/; 19s/pv/$PV_NAME/; 29s/pv/$PV_NAME/&quot; /data/upload_pvc_commands/pv.yaml &gt;/data/upload_pvc_commands/tmppv.yaml\n            kubectl apply -f /data/upload_pvc_commands/tmppv.yaml\n            # sed -e &quot;4s/pvc/$PVC_NAME/; 11s/45Gi/$PVC_SIZE/ &quot; /data/upload_pvc_commands/pvc.yaml &gt;/data/upload_pvc_commands/tmppvc.yaml\n            chmod -R 777 /data/*\n            virtctl image-upload --image-path=&quot;$IMAGE_PATH&quot; --pvc-name=&quot;$PVC_NAME&quot; \\\n                --pvc-size=&quot;$PVC_SIZE&quot; --uploadproxy-url=&quot;$UPLOADPROXY_URL&quot; \\\n                --insecure --wait-secs=&quot;$WAIT_SECS&quot;\n\n             chmod -R 777 /data/*\n             virtctl image-upload --image-path=&quot;$IMAGE_PATH&quot; --pvc-name=&quot;$PVC_NAME&quot; \\\n                --pvc-size=&quot;$PVC_SIZE&quot; --uploadproxy-url=&quot;$UPLOADPROXY_URL&quot; \\\n                --insecure --wait-secs=&quot;$WAIT_SECS&quot;\n\n            echo &quot;upload images done&quot;\n            sed -e &quot;4s/vm/$vm_name/; 11s/vm/$vm_name/; 33s/pvc/$vm_name-pvc/&quot; /data/upload_pvc_commands/vm.yaml &gt;/data/upload_pvc_commands/tmpvm.yaml\n\n            kubectl apply -f /data/upload_pvc_commands/tmpvm.yaml\n            rm -f /data/upload_pvc_commands/$vm_name.vm\n\n        elif [[ &quot;$file&quot; == *.delete ]]; then\n            vm_name=&quot;$&#123;file%.delete&#125;&quot;\n            echo &quot;Deleting VM: $vm_name&quot;\n            kubectl delete vm &quot;$vm_name&quot;\n            kubectl delete pvc &quot;$vm_name-pvc&quot;\n            kubectl delete pv &quot;$vm_name-pv&quot;\n\n            rm -f &quot;$target_directory/$vm_name.delete&quot;\n\n        fi\n\n    done\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"K8S-WEB项目文档\"><a href=\"#K8S-WEB项目文档\" class=\"headerlink\" title=\"K8S-WEB项目文档\"></a>K8S-WEB项目文档</h1><h2 id=\"需要了解的前置术语\"><a href=\"#需要了解的前置术语\" class=\"headerlink\" title=\"需要了解的前置术语\"></a>需要了解的前置术语</h2><ul>\n<li>前端：进行数据渲染和展示的部分。通常使用HTML CSS JavaScript实现</li>\n<li>后端：对数据进行增删改查，提供服务的部分</li>\n<li>VUE：前端框架，将HTML CSS JavaScript 整合到一个页面，便于开发</li>\n<li>VueRouter：Vue的组件，用来快速配置页面跳转</li>\n<li>Axios：Vue的组件，用来发起和配置Http请求。</li>\n<li>NPM：包管理工具，用来管理Vue项目的依赖包</li>\n<li>ElementPlus：Vue3的组件库，用来快速开发，美化页面。</li>\n<li>tomcat：web服务器，监听端口。SpringBoot使用tomcat来开启服务。</li>\n<li>SpringBoot：后端框架，用来快速开发服务端</li>\n<li>Maven：包管理工具，用来管理后端项目</li>\n<li>MyBatisPlus：用来快速开发服务端对数据库增删改查操作的框架</li>\n<li>MySQL：数据库</li>\n<li>SpringCloud：SpringBoot的微服务生态，包含多种框架</li>\n<li>SpringCloudKubernetes：SpringCloud的k8s组件。由官方维护</li>\n<li>JWT：JavaWebToken，是SpringBoot的组件，用来进行鉴权</li>\n<li>Lombok：是SpringBoot的组件，用来一键设置类的get，set方法</li>\n<li>HttpClient：是SpringBoot的组件，用来发起http请求。</li>\n<li>Swagger：是SpringBoot组件，用来统一api。</li>\n<li>token：用来鉴权的序列</li>\n<li>Cookie：是浏览器中暂时存储数据的一个数据结构。项目中在这里存储token和username</li>\n<li>Interceptor：拦截器，在后端处理请求前拦截请求，并进行操作</li>\n<li>Nginx：用来分发http请求，将请求根据端口分配到不同资源</li>\n<li>Docker</li>\n<li>Kubernetes</li>\n<li>Kubevirt</li>\n</ul>\n<h2 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h2><h3 id=\"整体代码包类型解读\"><a href=\"#整体代码包类型解读\" class=\"headerlink\" title=\"整体代码包类型解读\"></a>整体代码包类型解读</h3><img src=\"http://gohoy.top/i/2023/08/04/p6aqbg-1.png\" alt=\"image-20230804152221174\" style=\"zoom:80%;\" />\n\n<p><strong>可以很粗略的认为：所有其他的类都是为controller文件服务的</strong></p>\n<ul>\n<li><code>com.example.home.gohoy.k8s_backend</code>：此目录下的是所有代码<ul>\n<li>assets：静态文件</li>\n<li>config：配置文件</li>\n<li>controller：核心提供服务的文件，这里一般只调用service接口实现需求</li>\n<li>dao：数据库交互的核心文件，这里都实现了MyBatisPlus</li>\n<li>dto：用于前后端传输的类</li>\n<li>entities：实体类（实体对象）</li>\n<li>service：业务实现层</li>\n<li>utils：工具类</li>\n<li>K8sWebMainApplication.class：springBoot的启动类，整个项目由此进入</li>\n</ul>\n</li>\n<li>resource：存放springBoot配置文件<ul>\n<li>application.yml：spring boot配置文件。</li>\n<li>k8s-user.sql：sql表文件，与项目逻辑无关。</li>\n</ul>\n</li>\n<li>pom.xml：图中没有展示，这个文件是maven管理工具的配置文件，使用maven来控制依赖版本</li>\n</ul>\n<h3 id=\"后端代码的api框架\"><a href=\"#后端代码的api框架\" class=\"headerlink\" title=\"后端代码的api框架\"></a>后端代码的api框架</h3><img src=\"http://gohoy.top/i/2023/08/01/qoznsh-1.png\" alt=\"系统结构功能图\"  />\n\n<p>分别对应了代码的controller部分</p>\n<p><img src=\"http://gohoy.top/i/2023/08/04/r3vqkm-1.png\" alt=\"image-20230804163908243\"></p>\n<h3 id=\"数据库表\"><a href=\"#数据库表\" class=\"headerlink\" title=\"数据库表\"></a>数据库表</h3><p>数据库名称为：k8s</p>\n<p>只有一张表：users，文件见resource&#x2F;k8s-users.mysql</p>\n<h4 id=\"表user字段说明\"><a href=\"#表user字段说明\" class=\"headerlink\" title=\"表user字段说明\"></a>表user字段说明</h4><table>\n<thead>\n<tr>\n<th>ColumName</th>\n<th>id</th>\n<th>username</th>\n<th>password</th>\n<th>ctr_occupied</th>\n<th>ctr_name</th>\n<th>ctr_max</th>\n<th>vm_occupied</th>\n<th>vm_name</th>\n<th>vm_max</th>\n<th>is_admin</th>\n<th>token</th>\n<th>last_login</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>describe</td>\n<td>主键</td>\n<td>用户名，不可重复</td>\n<td>密码</td>\n<td>已经申请的container数量</td>\n<td>已经申请的container的名称</td>\n<td>最多可以申请的container数量</td>\n<td>已经申请的虚拟机的数量</td>\n<td>已经申请的虚拟机的名称</td>\n<td>最多可以申请的虚拟机的数量</td>\n<td>是否是管理员</td>\n<td>用于验证身份的token</td>\n<td>上次登录时间</td>\n</tr>\n<tr>\n<td>notNull</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>yes</td>\n<td>yes</td>\n<td></td>\n</tr>\n<tr>\n<td>default</td>\n<td></td>\n<td></td>\n<td></td>\n<td>0</td>\n<td>null</td>\n<td>1</td>\n<td>0</td>\n<td>null</td>\n<td>1</td>\n<td>0</td>\n<td></td>\n<td>null</td>\n</tr>\n<tr>\n<td>autoIncrease</td>\n<td>yes</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"处理请求的逻辑\"><a href=\"#处理请求的逻辑\" class=\"headerlink\" title=\"处理请求的逻辑\"></a>处理请求的逻辑</h3><img src=\"http://gohoy.top/i/2023/08/04/r5tcvh-1.png\" alt=\"image-20230804152329594\" style=\"zoom: 67%;\" />\n\n<h4 id=\"tomcat服务器如何把请求转发到对应的controller方法？\"><a href=\"#tomcat服务器如何把请求转发到对应的controller方法？\" class=\"headerlink\" title=\"tomcat服务器如何把请求转发到对应的controller方法？\"></a>tomcat服务器如何把请求转发到对应的controller方法？</h4><p>接下来以用户登录方法为例</p>\n<p>我们假设后端服务器的BASE_URL是<a href=\"http://localhost:8080/\">http://localhost:8080/</a></p>\n<ul>\n<li><p>前端使用POST请求访问了<a href=\"http://localhost:8080/user/login%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%90%BA%E5%B8%A6%E4%BA%86%E7%94%A8%E6%88%B7%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF\">http://localhost:8080/user/login，并且携带了用户的基本信息</a></p>\n</li>\n<li><p>tomcat检测到请求，将请求转发给Springboot框架</p>\n</li>\n<li><p>SpringBoot框架通过你的注解找到对应这个url对应的方法</p>\n<ul>\n<li><p>这个方法位于controller&#x2F;user&#x2F;UserController.class下</p>\n</li>\n<li><p>UserController.class这个文件需要注解</p>\n<ul>\n<li><img src=\"http://gohoy.top/i/2023/08/04/r5tald-1.png\" alt=\"image-20230804152933250\" style=\"zoom: 67%;\" />\n</li>\n<li><p><code>@CrossOrigin(&quot;*&quot;)</code></p>\n<p>允许跨域访问到这个方法</p>\n</li>\n<li><p><code>@ApiResponses</code></p>\n<p>插件Swagger的注解，用来整合所有api的信息，对于这个服务，可以在<a href=\"http://localhost:8080/swagger-ui.html%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E6%B3%A8%E5%86%8C%E7%9A%84api%EF%BC%8C%E5%B9%B6%E6%B5%8B%E8%AF%95\">http://localhost:8080/swagger-ui.html查看所有注册的api，并测试</a></p>\n</li>\n<li><p><code>@RestController()</code></p>\n<p>这个注解将这个类作为Restful风格的controller注册到SpringBoot框架中，</p>\n</li>\n<li><p><code>@RequestMapping(&quot;/user/&quot;)</code></p>\n<p>这个注解表示这个类接收url为<a href=\"http://localhost:8080/user/%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%B9%E6%B3%95%E8%AF%B7%E6%B1%82\">http://localhost:8080/user/的任意方法请求</a></p>\n</li>\n</ul>\n</li>\n<li><p>然后查看login的方法</p>\n<ul>\n<li><img src=\"http://gohoy.top/i/2023/08/04/r5t8ma-1.png\" alt=\"image-20230804153323097\" style=\"zoom:80%;\" />\n</li>\n<li><p><code>@PostMapping(&quot;/login&quot;)</code></p>\n<p>表示这个方法处理<a href=\"http://localhost:8080/user/login%E7%9A%84%E8%AF%B7%E6%B1%82\">http://localhost:8080/user/login的请求</a></p>\n</li>\n<li><p><code>@ApiResponse(description = &quot;用户登录&quot;)</code></p>\n<p>注册这个方法到swagger管理页面中，这个api的描述为“用户登录”</p>\n</li>\n<li><p><code>@RequestBody User user</code></p>\n<p>这是需要传入这个函数的参数，对应前端携带的用户信息。并把这个用户信息生成一个User类的对象</p>\n</li>\n<li><p>接下来就是对user对象进行操作。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"controller具体逻辑的实现流程\"><a href=\"#controller具体逻辑的实现流程\" class=\"headerlink\" title=\"controller具体逻辑的实现流程\"></a>controller具体逻辑的实现流程</h4><p>以根据用户名获取用户数据这个api为例</p>\n<p><img src=\"http://gohoy.top/i/2023/08/04/r6hzsn-1.png\" alt=\"image-20230804164347717\"></p>\n<ul>\n<li>它的返回值是CommonResult，这是我自定义的类（utils&#x2F;CommonResult.class），用于规范像前端返回的数据格式。</li>\n<li>调用了UserService的getUserByName方法<ul>\n<li><strong><img src=\"http://gohoy.top/i/2023/08/04/r7oqsr-1.png\" alt=\"image-20230804164546919\"></strong></li>\n<li>UserService这里只定义了一个接口，没有进行实现</li>\n</ul>\n</li>\n<li>UserServiceImpl.class文件实现了UserService接口的方法<ul>\n<li><img src=\"http://gohoy.top/i/2023/08/04/r8urkd-1.png\" style=\"zoom:67%;\" /></li>\n</ul>\n</li>\n<li>UserServiceImpl中又调用了UserDao中的方法来从数据库查询用户<ul>\n<li><img src=\"http://gohoy.top/i/2023/08/04/r9dp3f-1.png\"></li>\n<li>这里面什么都没写，因为它继承了BaseMapper类，BaseMapper是MyBatisPlus框架实现的类，其中已经有最基本的对数据库进行增删改查的方法。</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"为什么要有这么多流程呢？直接把在controller文件中调用UserDao实现查询可以吗\"><a href=\"#为什么要有这么多流程呢？直接把在controller文件中调用UserDao实现查询可以吗\" class=\"headerlink\" title=\"为什么要有这么多流程呢？直接把在controller文件中调用UserDao实现查询可以吗\"></a>为什么要有这么多流程呢？直接把在controller文件中调用UserDao实现查询可以吗</h5><p>分出controller service dao三层是后端开发的规范，在比较复杂的后端逻辑时可以理清思路，便于实现。</p>\n<p>所以简单的业务逻辑是可以直接在controller实现的。</p>\n<h3 id=\"controller文件中实现api\"><a href=\"#controller文件中实现api\" class=\"headerlink\" title=\"controller文件中实现api\"></a>controller文件中实现api</h3><h4 id=\"一般的api，简单的增删改查\"><a href=\"#一般的api，简单的增删改查\" class=\"headerlink\" title=\"一般的api，简单的增删改查\"></a>一般的api，简单的增删改查</h4><h5 id=\"AdminPodController：管理员Pod管理api\"><a href=\"#AdminPodController：管理员Pod管理api\" class=\"headerlink\" title=\"AdminPodController：管理员Pod管理api\"></a><code>AdminPodController</code>：管理员Pod管理api</h5><ul>\n<li><code>/getAllPods/&#123;type&#125;)</code>：获取所有pod信息<ul>\n<li>使用kubernetesClient获取所有pod，将pod进行筛选，除去系统pod</li>\n<li>将剩下的pod每一个都构建成PodInfo的对象，返回List<PodInfo></li>\n</ul>\n</li>\n<li><code>/setCtrDefaultResource/</code>：设置默认的pod资源，需要传入PodResourceDTO对象<ul>\n<li>这个api实现的方法是：将podResourceDTO对象的属性存放在k8s集群中的configMap中。</li>\n</ul>\n</li>\n<li><code>/setVMDefaultResource/</code>：与<code>/setCtrDefaultResource/</code>同理</li>\n<li><code>/getDefaultConfig/&#123;type&#125;</code>：根据字符串type获取不同的configMap</li>\n</ul>\n<h5 id=\"AdminUserController：管理员用户管理api：\"><a href=\"#AdminUserController：管理员用户管理api：\" class=\"headerlink\" title=\"AdminUserController：管理员用户管理api：\"></a><code>AdminUserController</code>：管理员用户管理api：</h5><ul>\n<li><code>/getUserByName/&#123;username&#125;</code>：通过用户名从数据库查询该用户的信息</li>\n<li><code>/getUsersByPage/&#123;pageNum&#125;/&#123;pageSize&#125;</code>：分页获取全部用户，使用了MyBatisPlus内置的分页方法。</li>\n<li><code>/updateUser</code>：更新用户信息</li>\n<li><code>/deleteUser/&#123;id&#125;</code>：通过id删除用户</li>\n</ul>\n<h5 id=\"PodController：用户对pod的功能需求\"><a href=\"#PodController：用户对pod的功能需求\" class=\"headerlink\" title=\"PodController：用户对pod的功能需求\"></a><code>PodController</code>：用户对pod的功能需求</h5><ul>\n<li><code>/selectPodByUserName/&#123;username&#125;</code>：通过用户名查询该用户所拥有的pod。因为pod创建的时候的名称都是username-type-job-random的形式，这里通过把所有的pod导出，遍历筛选的方法获得目标。</li>\n<li><code>/deletePod/&#123;podName&#125;</code>：通过pod名称来删除pod</li>\n</ul>\n<h5 id=\"UserController：用户登录注册和其他对自己信息的管理\"><a href=\"#UserController：用户登录注册和其他对自己信息的管理\" class=\"headerlink\" title=\"UserController：用户登录注册和其他对自己信息的管理\"></a><code>UserController</code>：用户登录注册和其他对自己信息的管理</h5><ul>\n<li><code>/register</code>：传入用户名，密码，只要数据库中没有这个用户就进行插入。</li>\n<li><code>/getUserDTO/&#123;username&#125;</code>：通过用户名，获取除了密码以外的所有信息。</li>\n<li><code>/getIndex</code>：前端主页显示的内容，通过此处获取index.md进行展示</li>\n</ul>\n<h4 id=\"较为复杂的api逻辑分析\"><a href=\"#较为复杂的api逻辑分析\" class=\"headerlink\" title=\"较为复杂的api逻辑分析\"></a>较为复杂的api逻辑分析</h4><h5 id=\"PodController：用户对pod的功能需求-1\"><a href=\"#PodController：用户对pod的功能需求-1\" class=\"headerlink\" title=\"PodController：用户对pod的功能需求\"></a><code>PodController</code>：用户对pod的功能需求</h5><ul>\n<li><code>/createCtr/&#123;username&#125;</code>：用户开启一个pod<ul>\n<li>使用username获取用户信息，判断用户是否还有可用的pod数量。</li>\n<li>从configmap中获取该类型pod的资源数量</li>\n<li>按照资源限制依次创建PV，PVC，Service，Job。PV和PVC用来持久化用户信息，Service用来暴露pod的ssh端口，Job用来控制pod的属性（比如存活时间等）</li>\n<li>创建成功之后将clusterIp，sshPort，rootPassword返回。</li>\n</ul>\n</li>\n<li><code>/createVm/&#123;username&#125;</code>：TODO</li>\n</ul>\n<h5 id=\"UserController：用户登录注册和其他对自己信息的管理-1\"><a href=\"#UserController：用户登录注册和其他对自己信息的管理-1\" class=\"headerlink\" title=\"UserController：用户登录注册和其他对自己信息的管理\"></a><code>UserController</code>：用户登录注册和其他对自己信息的管理</h5><ul>\n<li><code>/login</code>：用户登录，传入username和password<ul>\n<li>首先验证用户名密码是否正确</li>\n<li>然后按照用户的username，isAdmin属性来使用jwt生成一个token。过期时间默认一周</li>\n<li>然后纠正用户可用的pod数量，因为当pod的job自然结束后，没有钩子函数能够通知我们去修改用户可用pod数量。所以这里在登录的时候进行扫描纠正。</li>\n<li>返回给前端token，前端在访问其他api的时候都需要在cookie中携带username和token</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"kubevirt相关api实现的步骤\"><a href=\"#kubevirt相关api实现的步骤\" class=\"headerlink\" title=\"kubevirt相关api实现的步骤\"></a>kubevirt相关api实现的步骤</h3><h4 id=\"走通使用kubevirt进行创建虚拟机的过程，并选取一个最终实现的方案\"><a href=\"#走通使用kubevirt进行创建虚拟机的过程，并选取一个最终实现的方案\" class=\"headerlink\" title=\"~~ 走通使用kubevirt进行创建虚拟机的过程，并选取一个最终实现的方案~~\"></a>~~ 走通使用kubevirt进行创建虚拟机的过程，并选取一个最终实现的方案~~</h4><h5 id=\"将虚拟机镜像传给pvc，然后使用这个pvc创建一个vm（已完成）\"><a href=\"#将虚拟机镜像传给pvc，然后使用这个pvc创建一个vm（已完成）\" class=\"headerlink\" title=\"将虚拟机镜像传给pvc，然后使用这个pvc创建一个vm（已完成）\"></a><del>将虚拟机镜像传给pvc，然后使用这个pvc创建一个vm（已完成）</del></h5><h5 id=\"使用数据类型datavolume来创建虚拟机\"><a href=\"#使用数据类型datavolume来创建虚拟机\" class=\"headerlink\" title=\"使用数据类型datavolume来创建虚拟机\"></a><del>使用数据类型datavolume来创建虚拟机</del></h5><p><del>优势：可以通过一个模板来clone虚拟机。通过快照来保存虚拟机的数据</del></p>\n<p><del>但是从来没有用过这种方法。可行性待验证</del></p>\n<h4 id=\"通过kubevirt提供的api，实现这个方案\"><a href=\"#通过kubevirt提供的api，实现这个方案\" class=\"headerlink\" title=\"~~ 通过kubevirt提供的api，实现这个方案~~\"></a>~~ 通过kubevirt提供的api，实现这个方案~~</h4><h5 id=\"首先要对请求进行鉴权配置（已完成）\"><a href=\"#首先要对请求进行鉴权配置（已完成）\" class=\"headerlink\" title=\"~~ 首先要对请求进行鉴权配置（已完成）~~\"></a>~~ 首先要对请求进行鉴权配置（已完成）~~</h5><p><del>k8s默认api需要进行证书验证。所以如果直接访问api地址会被拦截。</del></p>\n<p><del>我仿照kubernetesClient进行了证书验证的操作。此项已完成</del></p>\n<h5 id=\"验证将pod配置序列化为请求体正常发送请求的方法\"><a href=\"#验证将pod配置序列化为请求体正常发送请求的方法\" class=\"headerlink\" title=\"~~ 验证将pod配置序列化为请求体正常发送请求的方法~~\"></a>~~ 验证将pod配置序列化为请求体正常发送请求的方法~~</h5><p><del>因为在api中，pod的配置全部都被放在请求体中，而Java存储这些配置的方法是生成一个类。</del></p>\n<p><del>这里需要去验证如何把类中的数据正确传递给k8s</del></p>\n<h4 id=\"kubevirt最终方案\"><a href=\"#kubevirt最终方案\" class=\"headerlink\" title=\"kubevirt最终方案\"></a>kubevirt最终方案</h4><p>使用脚本监听文件修改，通过监听文件修改来执行kubectl命令来进行虚拟机操作（当前使用的方案）</p>\n<pre><code class=\"sh\">#!/bin/bash\n\n# 目标目录\n\ntarget_directory=&quot;/data/upload_pvc_commands&quot;\n\n# 启动监听\n\ninotifywait -m -e create -e moved_to &quot;$target_directory&quot; |\n    while read path action file; do\n        if [[ &quot;$file&quot; == *.vm ]]; then\n            vm_name=&quot;$&#123;file%.vm&#125;&quot;\n            echo $vm_name\n            IMAGE_PATH=&quot;/home/gohoy/iso/ubuntu-20.04.qcow2&quot;\n            PV_NAME=&quot;$vm_name-pv&quot;\n            PVC_NAME=&quot;$vm_name-pvc&quot;\n            PVC_SIZE=&quot;45Gi&quot;\n            UPLOADPROXY_URL=$(kubectl -n cdi get svc -l cdi.kubevirt.io=cdi-uploadproxy | awk &#39;/cdi-uploadproxy/ &#123;print $3&#125;&#39;)\n            WAIT_SECS=&quot;240&quot;\n            echo &quot;upload images to $PVC_NAME&quot;\n            sed -e &quot;4s/pv/$PV_NAME/; 14s/pv/$PV_NAME/; 19s/pv/$PV_NAME/; 29s/pv/$PV_NAME/&quot; /data/upload_pvc_commands/pv.yaml &gt;/data/upload_pvc_commands/tmppv.yaml\n            kubectl apply -f /data/upload_pvc_commands/tmppv.yaml\n            # sed -e &quot;4s/pvc/$PVC_NAME/; 11s/45Gi/$PVC_SIZE/ &quot; /data/upload_pvc_commands/pvc.yaml &gt;/data/upload_pvc_commands/tmppvc.yaml\n            chmod -R 777 /data/*\n            virtctl image-upload --image-path=&quot;$IMAGE_PATH&quot; --pvc-name=&quot;$PVC_NAME&quot; \\\n                --pvc-size=&quot;$PVC_SIZE&quot; --uploadproxy-url=&quot;$UPLOADPROXY_URL&quot; \\\n                --insecure --wait-secs=&quot;$WAIT_SECS&quot;\n\n             chmod -R 777 /data/*\n             virtctl image-upload --image-path=&quot;$IMAGE_PATH&quot; --pvc-name=&quot;$PVC_NAME&quot; \\\n                --pvc-size=&quot;$PVC_SIZE&quot; --uploadproxy-url=&quot;$UPLOADPROXY_URL&quot; \\\n                --insecure --wait-secs=&quot;$WAIT_SECS&quot;\n\n            echo &quot;upload images done&quot;\n            sed -e &quot;4s/vm/$vm_name/; 11s/vm/$vm_name/; 33s/pvc/$vm_name-pvc/&quot; /data/upload_pvc_commands/vm.yaml &gt;/data/upload_pvc_commands/tmpvm.yaml\n\n            kubectl apply -f /data/upload_pvc_commands/tmpvm.yaml\n            rm -f /data/upload_pvc_commands/$vm_name.vm\n\n        elif [[ &quot;$file&quot; == *.delete ]]; then\n            vm_name=&quot;$&#123;file%.delete&#125;&quot;\n            echo &quot;Deleting VM: $vm_name&quot;\n            kubectl delete vm &quot;$vm_name&quot;\n            kubectl delete pvc &quot;$vm_name-pvc&quot;\n            kubectl delete pv &quot;$vm_name-pv&quot;\n\n            rm -f &quot;$target_directory/$vm_name.delete&quot;\n\n        fi\n\n    done\n</code></pre>\n<h2 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a>前端</h2><h3 id=\"前端代码包\"><a href=\"#前端代码包\" class=\"headerlink\" title=\"前端代码包\"></a>前端代码包</h3><p><img src=\"http://gohoy.top/i/2023/08/14/qm6mnh-1.png\" alt=\"image-20230814160921521\"></p>\n<ul>\n<li>node_modules：所有前端组件的目录。由npm管理</li>\n<li>public：放一些公共文件，比如网站的头像，index.html</li>\n<li>src：主要代码的存放处<ul>\n<li>assets：静态资源</li>\n<li>components：组件，需要重复使用的部分</li>\n<li>router：路由，管理页面的跳转</li>\n<li>views：主要的页面存放处</li>\n<li>App.vue：整个项目的入口</li>\n<li>main.js：整个项目的配置文件</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"前端文件的架构\"><a href=\"#前端文件的架构\" class=\"headerlink\" title=\"前端文件的架构\"></a>前端文件的架构</h3><img src=\"http://gohoy.top/i/2023/08/14/qqtpor-1.png\" alt=\"image-20230814161708391\" style=\"zoom:67%;\" />\n\n<p>页面的入口是App.vue</p>\n<p>App.vue中的<code>   &lt;router-view&gt;&lt;/router-view&gt;</code>是这个页面被渲染的地方。</p>\n<h2 id=\"框架的使用说明\"><a href=\"#框架的使用说明\" class=\"headerlink\" title=\"框架的使用说明\"></a>框架的使用说明</h2><h3 id=\"NPM\"><a href=\"#NPM\" class=\"headerlink\" title=\"NPM\"></a>NPM</h3><p>NodeJs提供的包管理工具</p>\n<p>npm install <packageName> 安装某个包</p>\n<p>npm install 按照npm的配置文件package.json来安装所有依赖</p>\n<p>在前端项目中，需要Node注意版本。</p>\n<p>npm run <option> 将项目运行，一般会有 serve 和build 选项。前者用于开发。后者将项目打包，用于部署</p>\n<h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><p>vue ui：开启一个webCli来进行vue项目管理</p>\n<p>vue init <packageName> 创建一个vue项目（可以在web页面进行）</p>\n<h3 id=\"VueRouter\"><a href=\"#VueRouter\" class=\"headerlink\" title=\"VueRouter\"></a>VueRouter</h3><pre><code class=\"sh\">npm install vue-router\n//在创建vue项目的时候可以选择直接安装\n</code></pre>\n<p>用于页面跳转，整合在整个vue项目中。</p>\n<pre><code class=\"js\">//   router/index.js示例\nimport &#123; createRouter, createWebHashHistory &#125; from &#39;vue-router&#39;\nimport IndexView from &#39;@/views/indexView.vue&#39;\nconst routes = [\n  &#123;\n    path: &#39;/index&#39;,\n    name: &#39;home&#39;,\n    component: IndexView\n  &#125;\n]\n\nconst router = createRouter(&#123;\n  history: createWebHashHistory(),\n  routes\n&#125;)\n\nexport default router\n</code></pre>\n<pre><code class=\"js\">// main.js中需要配置如下\nimport &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport router from &#39;./router&#39;\n\nconst app = createApp(App);\napp.use(router).mount(&#39;#app&#39;)\n</code></pre>\n<p>这样之后，就可以访问项目地址&#x2F;index进入页面IndexView</p>\n<h3 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h3><pre><code class=\"sh\">npm insatll axios\n</code></pre>\n<p>用于发送http请求</p>\n<pre><code class=\"js\">import &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;./App.vue&#39;\nimport router from &#39;./router&#39;\nimport axios from &#39;axios&#39;\naxios.defaults.baseURL = &quot;http://localhost:8080/&quot;\n//设置基本路径，在之后的请求中不需要重复输入这段url\naxios.interceptors.request.use((config) =&gt; &#123;\n    const token = Cookies.get(&#39;token&#39;);\n    const username = Cookies.get(&#39;username&#39;);\n    if (token) &#123;\n        config.headers[&#39;Authorization&#39;] = token;\n    &#125;\n\n    if (username) &#123;\n        config.headers[&#39;X-Username&#39;] = username;\n    &#125;\n\n    config.headers[&#39;Referrer-Policy&#39;] = &#39;no-referrer&#39;\n    return config;\n&#125;);\n//这个interceptor用来解决跨域问题\nconst app = createApp(App);\napp.config.globalProperties.$axios = axios\napp.config.globalProperties.$http = axios\n// 将axios的别名设置为$axios或者$http\napp.use(router).mount(&#39;#app&#39;)\n</code></pre>\n<p>示例使用</p>\n<pre><code class=\"js\">        async handleLogin() &#123;\n            const response = await this.$axios.post(&#39;/user/login&#39;, this.userData).then(response =&gt; &#123;\n                if (response.data.code == &quot;200&quot;) &#123;\n                    Cookies.set(&#39;token&#39;, response.data.data);\n                    Cookies.set(&#39;username&#39;, this.userData.username);\n                    ElMessage.info(response.data.message)\n                    location.reload();\n                &#125; else &#123;\n                    ElMessage.error(response.data.message)\n                &#125;\n            &#125;)\n\n        &#125;,\n</code></pre>\n<p>这里使用post请求访问<a href=\"http://localhost:8080/user/login%EF%BC%8C%E5%B9%B6%E5%9C%A8requestBody%E4%B8%AD%E6%90%BA%E5%B8%A6%E4%BA%86%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E3%80%82%E5%B9%B6%E5%B0%86%E5%BE%97%E5%88%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%94%BE%E5%9C%A8response%E4%B8%AD%E3%80%82%E4%B9%8B%E5%90%8E%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C\">http://localhost:8080/user/login，并在requestBody中携带了用户登录信息。并将得到的返回值放在response中。之后进行操作</a></p>\n<h3 id=\"ElementPlus\"><a href=\"#ElementPlus\" class=\"headerlink\" title=\"ElementPlus\"></a>ElementPlus</h3><p><a href=\"https://element-plus.org/zh-CN/guide/quickstart.html#%E7%94%A8%E6%B3%95\">查看官方使用文档</a></p>\n<h3 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h3><p>包配置文件在项目根目录的pom.xml中</p>\n<p>基本示例</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;3.1.2&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.example&lt;/groupId&gt;\n    &lt;artifactId&gt;home-gohoy-k8s_backend&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;demo&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;17&lt;/java.version&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-kubernetes-fabric8-all&lt;/artifactId&gt;\n            &lt;version&gt;3.0.3&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre>\n<p>主要需要添加依赖的是dependency标签。</p>\n<p>修改完成后，使用mvn install 进行安装依赖</p>\n<p>mvn package 按照build标签把项目进行打包，用于部署</p>\n<p>配置文件：一般是根目录的.m2&#x2F;setting.xml</p>\n<p>maven换源：</p>\n<pre><code class=\"xml\">    &lt;mirror&gt;\n          &lt;id&gt;nexus-aliyun&lt;/id&gt;\n          &lt;name&gt;Nexus aliyun&lt;/name&gt;\n        &lt;mirrorOf&gt;external:*&lt;/mirrorOf&gt;\n          &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;\n      &lt;/mirror&gt;\n</code></pre>\n<p>在mirrors标签中加入这些即可</p>\n<h3 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h3><p>Maven包设置：</p>\n<pre><code class=\"xml\">    &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n            &lt;version&gt;3.1.2&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n            &lt;version&gt;3.1.0&lt;/version&gt;\n            &lt;scope&gt;compile&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>配置：</p>\n<pre><code class=\"yaml\">spring:\n  application:\n    name:k8s-web\nserver:\n  port: 8080\n</code></pre>\n<p>主启动类的格式：</p>\n<pre><code class=\"java\">@SpringBootApplication\npublic class K8sWebMainApplication &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(K8sWebMainApplication.class, args);\n    &#125;\n&#125;\n</code></pre>\n<p>这些是最基本的，且不变的。</p>\n<p>可能会需要其他配置。在类名前加上不同的注解。</p>\n<p>运行这个类，SpringBoot就会在指定端口开启一个tomcat服务器用来接收http请求。（默认8080）</p>\n<p>配置文件默认在项目根目录&#x2F;resources&#x2F;application.yaml（或者application.application）</p>\n<h3 id=\"MyBatisPlus\"><a href=\"#MyBatisPlus\" class=\"headerlink\" title=\"MyBatisPlus\"></a>MyBatisPlus</h3><p>Maven包引用</p>\n<pre><code class=\"xml\">    &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n            &lt;version&gt;3.5.3.1&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>用来简化SpringBoot和数据库的操作</p>\n<p>配置：</p>\n<pre><code class=\"yaml\"># applicaiton.yaml\nmybatis-plus:\n  mapper-locations: classpath:mapper/*.xml\n</code></pre>\n<p>这里配置了mapper的路径，让SpringBoot能够找到Mybatis的系列配置，但是基础的crud用不到这些mapper文件</p>\n<p>基础使用：</p>\n<pre><code class=\"java\">// dao文件需要继承BaseMapper&lt;entity&gt;，里面实现的基础的crud\n@Table(name = &quot;users&quot;)\npublic interface UserDao extends BaseMapper&lt;User&gt; &#123;\n&#125;\n</code></pre>\n<pre><code class=\"java\">// service文件需要继承Iservice&lt;entity&gt;，里面定义了基本的crud接口\npublic interface UserService extends IService&lt;User&gt; &#123;\n&#125;\n</code></pre>\n<pre><code class=\"java\">// 在serviceImpl文件中继承 ServiceImpl&lt;Dao文件 , entity&gt; ，里面实现了Iservice&lt;entity&gt;的接口\n@Service\npublic class UserServiceImpl extends ServiceImpl&lt;UserDao , User&gt; implements UserService &#123;\n&#125;\n</code></pre>\n<h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><p>这里准备使用docker来启动</p>\n<p><code>docker run --name mysql  --restart=always -p 3306:3306 \\ -e &quot;MYSQL_ROOT_PASSWORD=040424&quot; mysql </code></p>\n<p>修改远程连接：<code>update user set host=&#39;*&#39; where user=&#39;root&#39;&amp;&amp; host=&#39;localhost&#39;; flush privileges;</code></p>\n<p>然后使用可视化工具比如MySQLWorkBrench来进行表的设计和操作。</p>\n<p>Maven包配置</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;version&gt;8.0.33&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>SpringBoot配置</p>\n<pre><code class=\"yam\">spring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/k8s?user=root&amp;password=040424&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=Asia/Shanghai\n    driver-class-name: com.mysql.cj.jdbc.Driver\n</code></pre>\n<p>这里主要要配置url。</p>\n<p>在这里配置之后，MyBatisPlus的curd操作就能够找到数据源</p>\n<h3 id=\"SpringCloudKubernetes\"><a href=\"#SpringCloudKubernetes\" class=\"headerlink\" title=\"SpringCloudKubernetes\"></a>SpringCloudKubernetes</h3><p>Maven 配置</p>\n<pre><code class=\"xml\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-kubernetes-fabric8-all&lt;/artifactId&gt;\n            &lt;version&gt;3.0.3&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>SpringBoot 配置</p>\n<pre><code class=\"yaml\">spring:\n  cloud:\n    kubernetes:\n      discovery:\n        enabled: true\n</code></pre>\n<p>基本使用：首先要把k8s的配置文件默认在&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf  复制到用户根目录的 .kube&#x2F;config</p>\n<p>然后开始编码：</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.config;\n\nimport io.fabric8.kubernetes.client.*;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class KubernetesConfig &#123;\n\n    @Bean\n    public KubernetesClient kubernetesClient() &#123;\n        Config config = new ConfigBuilder().withMasterUrl(&quot;https://192.168.111.140:6443&quot;).build();\n        return new KubernetesClientBuilder().withConfig(config).build();\n    &#125;\n&#125;\n</code></pre>\n<p>这段代码将kubernetesClient注入到SpringBoot容器中，生成一个实例。</p>\n<p>然后使用的时候直接调用它提供的api</p>\n<pre><code class=\"java\">   config = new Namespace();\n   ObjectMeta metadata = new ObjectMeta();\n   metadata.setName(&quot;default&quot;);\n   config.setMetadata(metadata);\n   kubernetesClient.resource(config).createOrReplace();\n</code></pre>\n<p>这段代码使用kubernetesClient创建了一个namespace config</p>\n<h3 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h3><p>用来生成token，来进行鉴权</p>\n<p>Maven配置</p>\n<pre><code class=\"xml\">        &lt;dependency&gt;\n            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n            &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;\n            &lt;version&gt;0.11.5&lt;/version&gt; &lt;!-- Replace with the latest version --&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n            &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;\n            &lt;version&gt;0.11.5&lt;/version&gt; &lt;!-- Replace with the latest version --&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;\n            &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;\n            &lt;version&gt;0.11.5&lt;/version&gt; &lt;!-- Replace with the latest version --&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>自定义一个JWTUtil.java</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.utils;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\n\nimport javax.crypto.spec.SecretKeySpec;\nimport java.nio.charset.StandardCharsets;\nimport java.security.Key;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class JWTUtils &#123;\n    private static final String SECRET_KEY = &quot;TheFurthestDistanceInTheWorldIsNotBetweenLifeAndDeathButWhenIStandInFrontOfYouYetYouDonNotKnowThatILoveYou&quot;;\n    // 生成JWT令牌\n    public static String generateToken(String username,byte isAdmin, long expirationMillis) &#123;\n        Date now = new Date();\n        Date expiration = new Date(now.getTime() + expirationMillis);\n        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();\n        // 在claims中添加用户信息或其他声明\n        claims.put(&quot;username&quot;, username);\n        claims.put(&quot;isAdmin&quot;,isAdmin);\n        // 可以添加更多的声明，比如用户角色等\n        byte[] apiKeySecretBytes = SECRET_KEY.getBytes(StandardCharsets.UTF_8);\n        Key signingKey = new SecretKeySpec(apiKeySecretBytes, SignatureAlgorithm.HS256.getJcaName());\n        return Jwts.builder()\n                .setClaims(claims)\n                .setIssuedAt(now)\n                .setExpiration(expiration)\n                .signWith(signingKey)\n                .compact();\n    &#125;\n    // 验证JWT令牌，如果验证失败将抛出异常，否则返回声明（claims）\n    public static Claims verifyToken(String token) &#123;\n        byte[] apiKeySecretBytes = SECRET_KEY.getBytes(StandardCharsets.UTF_8);\n        Key signingKey = new SecretKeySpec(apiKeySecretBytes, SignatureAlgorithm.HS256.getJcaName());\n        return Jwts.parserBuilder()\n                .setSigningKey(signingKey)\n                .build()\n                .parseClaimsJws(token)\n                .getBody();\n    &#125;\n&#125;\n</code></pre>\n<p>提供两个方法</p>\n<ul>\n<li>generateToken：使用用户的username和isAdmin字段和过期时间和自定义的Sercert_Key来混淆生成一个token</li>\n<li>verifyToken：将token进行解码，并返回</li>\n</ul>\n<p>基本使用：</p>\n<p>在登录成功后生成一个token，在接收到前端的请求时，使用token进行鉴权。</p>\n<h3 id=\"Lombok\"><a href=\"#Lombok\" class=\"headerlink\" title=\"Lombok\"></a>Lombok</h3><p>用来快速生成类的get set方法，快速标记链式编程等</p>\n<p>Maven配置：</p>\n<pre><code class=\"xml\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.18.26&lt;/version&gt;\n            &lt;scope&gt;compile&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>基本使用：</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.entities;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.example.home.gohoy.k8s_backend.dto.UserDTO;\nimport jakarta.persistence.*;\nimport lombok.Data;\nimport java.sql.Timestamp;\nimport java.util.Objects;\n@Data\n@Entity\n@TableName(&quot;users&quot;)\n@Table(name = &quot;users&quot;, schema = &quot;k8s&quot;)\npublic class User  extends UserDTO&#123;\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Id\n    @Column(name = &quot;id&quot;)\n    private int id;\n    @Basic\n    @Column(name = &quot;password&quot;)\n    private String password;\n&#125;\n</code></pre>\n<p>直接注解@Data</p>\n<p>自动为下面的属性id 和password生成get set方法</p>\n<h3 id=\"Swagger\"><a href=\"#Swagger\" class=\"headerlink\" title=\"Swagger\"></a>Swagger</h3><p>Maven配置</p>\n<pre><code class=\"xm\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;\n            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;\n            &lt;version&gt;2.0.4&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>基本使用：</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.controller.admin;\n\nimport com.example.home.gohoy.k8s_backend.dao.UserDao;\nimport com.example.home.gohoy.k8s_backend.dto.UserDTO;\nimport com.example.home.gohoy.k8s_backend.entities.User;\nimport com.example.home.gohoy.k8s_backend.service.user.UserService;\nimport com.example.home.gohoy.k8s_backend.utils.CommonResult;\nimport io.swagger.v3.oas.annotations.responses.ApiResponse;\nimport jakarta.annotation.Resource;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@CrossOrigin(&quot;*&quot;)\n@ApiResponse\n@RequestMapping(&quot;/admin/&quot;)\npublic class AdminUserController &#123;\n    @Resource\n    private UserService userService;\n    @Resource\n    private UserDao userDao;\n    @GetMapping(&quot;/getUserByName/&#123;username&#125;&quot;)\n    @ApiResponse(description = &quot;通过参数userName获取user数据&quot;)\n    private CommonResult getUserByName(@PathVariable(&quot;username&quot;) String userName)&#123;\n  &#125;\n    @GetMapping(&quot;/getUsersByPage/&#123;pageNum&#125;/&#123;pageSize&#125;&quot;)\n    @ApiResponse(description = &quot;分页获取所有用户&quot;)\n    private CommonResult getUsers(@PathVariable(&quot;pageNum&quot;) int pageNum,@PathVariable(&quot;pageSize&quot;)int pageSize)&#123;\n    &#125;\n    @PostMapping(&quot;/updateUser&quot;)\n    @ApiResponse(description = &quot;更新用户信息&quot;)\n    public CommonResult updateUser(@RequestBody User user )&#123;\n\n    &#125;\n&#125;\n</code></pre>\n<p>@ApiResponses：标记这个类是定义了很多api</p>\n<p>@ApiResponse（description&#x3D;”这里是api的描述”）：标记这个方法是一个api</p>\n<p>然后在项目运行的url，例如：localhost:8080&#x2F;swagger-ui.html可以查看这些api，并且可以进行测试</p>\n<h3 id=\"Interceptor\"><a href=\"#Interceptor\" class=\"headerlink\" title=\"Interceptor\"></a>Interceptor</h3><p>Maven配置</p>\n<pre><code class=\"xml\">&lt;!--\t\tservlet--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.1&lt;/version&gt; &lt;!-- Replace with the appropriate version --&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>Interceptor主要实现接口HandlerInterceptor的方法preHandle</p>\n<p>这个方法是在controller处理请求前执行的。</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.utils.interceptors;\n\nimport com.example.home.gohoy.k8s_backend.utils.JWTUtils;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport javax.servlet.http.HttpServletResponse;\n@Component\npublic class AdminInterceptor implements HandlerInterceptor &#123;\n\n    @Override\n    public boolean preHandle(jakarta.servlet.http.HttpServletRequest request, jakarta.servlet.http.HttpServletResponse response, Object handler) throws Exception &#123;\n        if(request.getMethod().equals(&quot;OPTIONS&quot;))&#123;\n            return true;\n        &#125;\n        System.out.println(&quot;AdminInterceptor&quot;);\n        // 从请求头部获取 Authorization Cookie\n        String token = request.getHeader(&quot;Authorization&quot;);\n\n        if  (JWTUtils.verifyToken(token).get(&quot;isAdmin&quot;).equals(1))&#123;\n            return true;\n        &#125;else &#123;\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            return false;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这段代码的逻辑，就在拦截请求，通过token来获取用户的username，然后从数据库查询是否存在admin权限。</p>\n<p>拦截器SpringBoot注入文件</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class InterceptorConfig implements WebMvcConfigurer &#123;\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        registry.addInterceptor(new AdminInterceptor())\n                .addPathPatterns(&quot;/admin/**&quot;);\n        registry.addInterceptor(new LoginInterceptor())\n                .addPathPatterns(&quot;/**&quot;)\n                .excludePathPatterns(&quot;/user/login&quot;, &quot;/user/register&quot;, &quot;/swagger-ui.html&quot;, &quot;/swagger-ui/**&quot;,\n                        &quot;/webjars/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>这里exludePathPatterns是排除的路径，防止登录注册和swagger页面不能进入。</p>\n<h3 id=\"HttpClient（当前项目弃用）\"><a href=\"#HttpClient（当前项目弃用）\" class=\"headerlink\" title=\"HttpClient（当前项目弃用）\"></a>HttpClient（当前项目弃用）</h3><p>用来发送http请求。</p>\n<p>使用的原因：Kubevirt的Api没有整合好的Java包，需要自己进行http请求</p>\n<p>Maven配置：</p>\n<pre><code class=\"xml\">        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;\n            &lt;version&gt;4.5.14&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<p>进行kubevirt编程：</p>\n<p>1.鉴权：（是从kubernetesClient调试的来的）</p>\n<pre><code class=\"java\">package com.example.home.gohoy.k8s_backend.utils;\n\nimport com.example.home.gohoy.k8s_backend.entities.kubevirt.*;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport io.fabric8.kubernetes.client.KubernetesClientException;\nimport jakarta.validation.constraints.NotNull;\nimport okhttp3.*;\nimport okhttp3.HttpUrl;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport org.springframework.stereotype.Component;\n\nimport javax.net.ssl.*;\nimport java.io.*;\nimport java.security.*;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.RSAPrivateCrtKeySpec;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.stream.Collectors;\n\n@Component\npublic class KubevirtUtil &#123;\n\n\n    private final String clientCertResource = &quot;&quot;;\n    private String caCertResource = &quot;&quot;;\nprivate TrustManager[] trustManagers;\n\n    public SSLContext preLoad() throws Exception &#123;\n//        System.out.println(caCertResource);\n//        System.out.println(clientCertResource);\n        String clientKeyResource = &quot;&quot;;\n//        System.out.println(clientKeyResource);\n        InputStream caCert = createInputStreamFromBase64EncodedString(caCertResource);\n        InputStream clientCert = createInputStreamFromBase64EncodedString(clientCertResource);\n        InputStream clientKey = createInputStreamFromBase64EncodedString(clientKeyResource);\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        KeyStore trustStore = KeyStore.getInstance(&quot;pkcs12&quot;);\n        char[] trustStorePassphrase = &quot;changeit&quot;.toCharArray();\n        trustStore.load(null);\n        while (caCert.available() &gt; 0) &#123;\n            CertificateFactory certFactory = CertificateFactory.getInstance(&quot;X509&quot;);\n            X509Certificate cert = (X509Certificate) certFactory.generateCertificate(caCert);\n            String alias = cert.getSubjectX500Principal().getName() + &quot;_&quot; + cert.getSerialNumber().toString(16);\n            trustStore.setCertificateEntry(alias, cert);\n        &#125;\n        tmf.init(trustStore);\n         trustManagers = tmf.getTrustManagers();\n      // clientKey clientCrt\n        CertificateFactory certFactory = CertificateFactory.getInstance(&quot;X509&quot;);\n        Collection&lt;? extends Certificate&gt; certificates = certFactory.generateCertificates(clientCert);\n        PrivateKey privateKey ;\n        byte[] keyBytes = decodePem(clientKey);\n        KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);\n        try &#123;\n            // First let&#39;s try PKCS8\n            privateKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(keyBytes));\n        &#125; catch (InvalidKeySpecException e) &#123;\n            // Otherwise try PKCS8\n            RSAPrivateCrtKeySpec keySpec = PKCS1Util.decodePKCS1(keyBytes);\n            privateKey= keyFactory.generatePrivate(keySpec);\n        &#125;\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keyStore.load(null);\n        String alias = certificates.stream().map(cert-&gt;((X509Certificate)cert).getIssuerX500Principal().getName()).collect(Collectors.joining(&quot;_&quot;));\n        keyStore.setKeyEntry(alias, privateKey, trustStorePassphrase, certificates.toArray(new Certificate[0]));\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        kmf.init(keyStore, trustStorePassphrase);\n        KeyManager[] keyManagers = kmf.getKeyManagers();\n\n        //sslContext\n        SSLContext sslContext ;\n        try &#123;\n             sslContext = SSLContext.getInstance(&quot;TLSv1.2&quot;);\n            sslContext.init(keyManagers, trustManagers, new SecureRandom());\n        &#125; catch (KeyManagementException | NoSuchAlgorithmException e) &#123;\n            throw KubernetesClientException.launderThrowable(e);\n        &#125;\n        return sslContext;\n    &#125;\n\n    public String sendHttpRequest(@NotNull String method,@NotNull String path, Headers headers, RequestBody requestBody) throws Exception &#123;\n        SSLContext sslContext = preLoad();\n\n        OkHttpClient httpClient = new OkHttpClient.Builder()\n                .sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0])\n                .hostnameVerifier((hostname, session) -&gt; true)\n                .build();\n\n        HttpUrl url = HttpUrl.parse(&quot;https://192.168.111.140:6443&quot; + path);\n        Request.Builder requestBuilder = new Request.Builder()\n                .url(url)\n                .method(method, requestBody);\n        System.out.println(url);\n\n        if (headers != null) &#123;\n            requestBuilder.headers(headers);\n        &#125;\n\n        Request request = requestBuilder.build();\n\n        try (Response response = httpClient.newCall(request).execute()) &#123;\n            ResponseBody responseBody = response.body();\n            if (responseBody != null) &#123;\n                String result = responseBody.string();\n                System.out.println(result);\n                return result;\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        return null;\n    &#125;\n\n\n\n    private static ByteArrayInputStream createInputStreamFromBase64EncodedString(String data) &#123;\n        byte[] bytes;\n        try &#123;\n            bytes = Base64.getDecoder().decode(data);\n        &#125; catch (IllegalArgumentException illegalArgumentException) &#123;\n            bytes = data.getBytes();\n        &#125;\n\n        return new ByteArrayInputStream(bytes);\n    &#125;\n\n    private static byte[] decodePem(InputStream keyInputStream) throws IOException &#123;\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(keyInputStream))) &#123;\n            String line;\n            while ((line = reader.readLine()) != null) &#123;\n                if (line.contains(&quot;-----BEGIN &quot;)) &#123;\n                    return readBytes(reader, line.trim().replace(&quot;BEGIN&quot;, &quot;END&quot;));\n                &#125;\n            &#125;\n            throw new IOException(&quot;PEM is invalid: no begin marker&quot;);\n        &#125;\n    &#125;\n    private static byte[] readBytes(BufferedReader reader, String endMarker) throws IOException &#123;\n        String line;\n        StringBuilder buf = new StringBuilder();\n\n        while ((line = reader.readLine()) != null) &#123;\n            if (line.contains(endMarker)) &#123;\n                return Base64.getDecoder().decode(buf.toString());\n            &#125;\n            buf.append(line.trim());\n        &#125;\n        throw new IOException(&quot;PEM is invalid : No end marker&quot;);\n    &#125;\n\n\n\n    public String getRequestBody() throws JsonProcessingException &#123;\n        HashMap&lt;String, String&gt; labels = new HashMap&lt;&gt;();\n        labels.put(&quot;slt&quot;, &quot;vm-test-1&quot;);\n\n        ArrayList&lt;Disk&gt; disks = new ArrayList&lt;&gt;();\n        disks.add(new Disk().setName(&quot;containerinit&quot;).setBootOrder(1)\n                .setDisk(new DiskTarget().setBus(&quot;virtio&quot;))\n        );\n        ArrayList&lt;Interface&gt; interfaces = new ArrayList&lt;&gt;();\n        interfaces.add(new Interface().setName(&quot;default&quot;).setMasquerade(&quot;&#123;&#125;&quot;));\n\n        ArrayList&lt;Network&gt; networks = new ArrayList&lt;&gt;();\n        networks.add(new Network().setName(&quot;default&quot;).setPod(new PodNetwork()));\n\n        ArrayList&lt;Volume&gt; volumes = new ArrayList&lt;&gt;();\n        volumes.add(new Volume()\n                .setName(&quot;containerinit&quot;)\n                .setPersistentVolumeClaim(\n                        new PersistentVolumeClaimVolumeSource()\n                                .setClaimName(&quot;euler-test-1&quot;)\n                )\n        );\n\n        VirtualMachine virtualMachine = new VirtualMachine();\n        virtualMachine.setApiVersion(&quot;kubevirt.io/v1&quot;)\n                .setKind(&quot;VirtualMachine&quot;)\n                .setMetadata(new ObjectMeta().setName(&quot;vm-test-1&quot;))\n                .setSpec(new VirtualMachineSpec().setRunning(true)\n                        .setTemplate(new VirtualMachineInstanceTemplateSpec()\n                                .setMetadata(new ObjectMeta()\n                                        .setNamespace(&quot;default&quot;)\n                                        .setLabels(labels)\n                                ).setSpec(\n                                        new VirtualMachineInstanceSpec()\n                                                .setDomain(\n                                                        new DomainSpec().setDevices(new Devices()\n                                                                .setAutoattachGraphicsDevice(true)\n                                                                .setDisks(disks)\n                                                                .setInterfaces(interfaces)\n                                                        ).setResources(new ResourceRequirements()\n                                                                .setRequests(new Requests()\n                                                                        .setCpu(&quot;2&quot;)\n                                                                        .setMemory(&quot;1G&quot;)\n                                                                )\n                                                        )\n                                                ).setNetworks(networks)\n                                                .setVolumes(volumes)\n                                )\n                        )\n                );\n        ObjectMapper objectMapper = new ObjectMapper();\n        String requestBody = objectMapper.writeValueAsString(virtualMachine);\n        System.out.println(requestBody);\n        return  requestBody;\n    &#125;\n\n    public String sendHttpRequest(String method, String path) throws Exception &#123;\n        return sendHttpRequest(method,path,null,null);\n    &#125;\n&#125;\n</code></pre>\n<p>这里的密钥是从k8s的config中复制得到</p>\n<p>鉴权操作主要是进行了证书的配置。</p>\n<p>2.调用kubevirt Api（弃用）</p>\n<p>遇到的困难：缺少一个完整kubevirt环境进行测试。</p>\n<p>3.实现kubevirt的方案：使用脚本监听文件修改来执行sh命令。</p>\n<h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><p>在部署的环境使用，可以查看<a href=\"https://www.runoob.com/w3cnote/nginx-setup-intro.html\">这篇教程</a></p>\n<h3 id=\"docker\"><a href=\"#docker\" class=\"headerlink\" title=\"docker\"></a>docker</h3><p>Docker用于作为k8s的container runtime</p>\n<p>以及最终项目的打包部署</p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>可以参考一些文章。<a href=\"https://blog.csdn.net/qq_52030824/article/details/127982206\">vue+springboot docker部署</a></p>\n<p>基本步骤：</p>\n<p>前端vue 使用npm run build，得到打包后的文件dist，将这个文件放在docker内部nginx的指定目录下。</p>\n<p>后端springboot需要使用maven打包成jar包。打包过程参考<a href=\"https://www.cnblogs.com/sanjay/p/11828081.html\">教程</a></p>\n<p>得到这些包之后，编写dockerfile 文件，将这些容器整合运行。</p>\n<ul>\n<li>打包得到前端和后端的最终文件</li>\n<li>docker Java17环境<ul>\n<li>将jar包放入这个镜像，使用Java -jar xxx.jar来运行后台包</li>\n</ul>\n</li>\n<li>docker MySQL8.0.32环境<ul>\n<li>将数据库文件写入容器中</li>\n</ul>\n</li>\n<li>docker Nginx环境<ul>\n<li>将前端打包文件放入此容器，然后编写nginx配置文件。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实操步骤\"><a href=\"#实操步骤\" class=\"headerlink\" title=\"实操步骤\"></a>实操步骤</h3><ol>\n<li><p>后端配置好端口后使用maven的package命令打包，得到jar包</p>\n<ol>\n<li>修改端口，MySQL的url：把localhost修改成服务器ip</li>\n</ol>\n</li>\n<li><p>前端配置好端口后，使用npm build得到dist文件夹</p>\n<ol>\n<li>修改端口和后端的base_url：把base_url修改成服务器ip</li>\n</ol>\n</li>\n<li><p>然后docker拉取镜像openjdk:17  mysql:8.0.32  nginx:latest</p>\n</li>\n<li><p>然后写dockerfile文件，将jar包引入为镜像</p>\n<ol>\n<li><pre><code class=\"dockerfile\"># 使用合适的 JDK 17 基础镜像\nFROM openjdk:17\n\n# 复制 jar 包到容器\nCOPY home-gohoy-k8s_backend-0.0.1-SNAPSHOT.jar k8s_web.jar\n\n# 运行 jar 包\nCMD [&quot;java&quot;, &quot;-jar&quot;, &quot;/k8s_web.jar&quot;]\n\n# 暴露端口\nEXPOSE 8088\n</code></pre>\n</li>\n<li><p><code>docker build -t k8s-web-server:1.0 .</code></p>\n</li>\n<li><p>使用docker compose 配置项目需要的镜像的环境</p>\n<ol>\n<li><pre><code class=\"yaml\">version: &quot;3&quot;\nservices:\n  k8s-web:\n    image: k8s-web-server:1.0\n    ports:\n      - &quot;8088:8088&quot;\n    volumes:\n      - /data/upload_pvc_commands/:/data/upload_pvc_commands/\n      - /root/.kube/:/root/.kube/\n      - /home/gohoy/k8s_web_docker/assets/:/data/assets/\n  mysql:\n    image: mysql:8.0.32\n    container_name: mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: &#39;040424&#39;\n      MYSQL_ALLOW_EMPTY_PASSWORD: &#39;no&#39;\n      MYSQL_DATABASE: &#39;k8s&#39;\n    ports:\n       - &quot;3306:3306&quot;\n    networks:\n      - k8s_web_network\n\n\n  nginx:\n    image: nginx:latest\n    container_name: nginx\n    ports:\n      - &quot;80:80&quot;\n    volumes:\n      - /home/gohoy/k8s_web_docker/nginx/html:/usr/share/nginx/html\n      - /home/gohoy/k8s_web_docker/nginx/logs:/var/log/nginx\n      - /home/gohoy/k8s_web_docker/nginx/conf:/etc/nginx\n    networks:\n      - k8s_web_network\n\n# 创建自定义网络\nnetworks:\n   k8s_web_network:\n</code></pre>\n</li>\n<li><p>docker-compose up -d启动环境</p>\n</li>\n</ol>\n</li>\n<li><p>配置nginx</p>\n<ol>\n<li><p>在&#x2F;home&#x2F;gohoy&#x2F;k8s_web_docker&#x2F;nginx&#x2F;conf下配置nginx 的配置文件，nginx.conf 和 mime.types 是从容器里面copy出来的默认配置，如何在conf.d中放入 k8s_web.conf文件</p>\n</li>\n<li><pre><code class=\"conf\">server &#123;\n    listen 80;\n    location / &#123;\n        root /usr/share/nginx/html/dist; # 根据您的目录配置\n        index index.html;\n    &#125;\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log;\n&#125;\n</code></pre>\n</li>\n<li><p>把前端vue打包好的dist文件放在&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;下面</p>\n</li>\n</ol>\n</li>\n<li><p>配置MySQL</p>\n<ol>\n<li>直接在自己电脑使用MySQL work branch（或者同类工具如navicat）连接</li>\n<li>刷入sql脚本文件</li>\n</ol>\n</li>\n<li><p>启动主机上 <code>/home/gohoy/k8s_web_docker/watch_and_execute.sh</code>，这个脚本来监听&#x2F;data&#x2F;upload_pvc_commands&#x2F;文件夹，通过监听文件修改来执行kubevirt相关的命令</p>\n<ol>\n<li><pre><code class=\"sh\">#!/bin/bash\n\n# 目标目录\n\ntarget_directory=&quot;/data/upload_pvc_commands&quot;\n\n# 启动监听\n\ninotifywait -m -e create -e moved_to &quot;$target_directory&quot; |\n    while read path action file; do\n        if [[ &quot;$file&quot; == *.vm ]]; then\n            vm_name=&quot;$&#123;file%.vm&#125;&quot;\n            echo $vm_name\n            IMAGE_PATH=&quot;/home/gohoy/iso/ubuntu-20.04.qcow2&quot;\n            PV_NAME=&quot;$vm_name-pv&quot;\n            PVC_NAME=&quot;$vm_name-pvc&quot;\n            PVC_SIZE=&quot;45Gi&quot;\n            UPLOADPROXY_URL=$(kubectl -n cdi get svc -l cdi.kubevirt.io=cdi-uploadproxy | awk &#39;/cdi-uploadproxy/ &#123;print $3&#125;&#39;)\n            WAIT_SECS=&quot;240&quot;\n            echo &quot;upload images to $PVC_NAME&quot;\n            sed -e &quot;4s/pv/$PV_NAME/; 14s/pv/$PV_NAME/; 19s/pv/$PV_NAME/; 29s/pv/$PV_NAME/&quot; /data/upload_pvc_commands/pv.yaml &gt;/data/upload_pvc_commands/tmppv.yaml\n            kubectl apply -f /data/upload_pvc_commands/tmppv.yaml\n            # sed -e &quot;4s/pvc/$PVC_NAME/; 11s/45Gi/$PVC_SIZE/ &quot; /data/upload_pvc_commands/pvc.yaml &gt;/data/upload_pvc_commands/tmppvc.yaml\n            chmod -R 777 /data/*\n            virtctl image-upload --image-path=&quot;$IMAGE_PATH&quot; --pvc-name=&quot;$PVC_NAME&quot; \\\n                --pvc-size=&quot;$PVC_SIZE&quot; --uploadproxy-url=&quot;$UPLOADPROXY_URL&quot; \\\n                --insecure --wait-secs=&quot;$WAIT_SECS&quot;\n\n             chmod -R 777 /data/*\n             virtctl image-upload --image-path=&quot;$IMAGE_PATH&quot; --pvc-name=&quot;$PVC_NAME&quot; \\\n                --pvc-size=&quot;$PVC_SIZE&quot; --uploadproxy-url=&quot;$UPLOADPROXY_URL&quot; \\\n                --insecure --wait-secs=&quot;$WAIT_SECS&quot;\n\n            echo &quot;upload images done&quot;\n            sed -e &quot;4s/vm/$vm_name/; 11s/vm/$vm_name/; 33s/pvc/$vm_name-pvc/&quot; /data/upload_pvc_commands/vm.yaml &gt;/data/upload_pvc_commands/tmpvm.yaml\n\n            kubectl apply -f /data/upload_pvc_commands/tmpvm.yaml\n            rm -f /data/upload_pvc_commands/$vm_name.vm\n\n        elif [[ &quot;$file&quot; == *.delete ]]; then\n            vm_name=&quot;$&#123;file%.delete&#125;&quot;\n            echo &quot;Deleting VM: $vm_name&quot;\n            kubectl delete vm &quot;$vm_name&quot;\n            kubectl delete pvc &quot;$vm_name-pvc&quot;\n            kubectl delete pv &quot;$vm_name-pv&quot;\n\n            rm -f &quot;$target_directory/$vm_name.delete&quot;\n\n        fi\n\n    done\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"K8S负载均衡方案","_content":"\n# k8s容器和虚拟机负载均衡方案分析\n\n## 负载均衡方案\n\n### 先说结论：直接使用k8s的service\n\n原因：我们的项目较为轻量，并且实现的是容器级别的负载均衡，这点k8s默认支持的ipvs策略就实现很好。其他更多负载均衡策略着重于node级别或service级别。我们的项目并不需要。\n\n### 内部负载均衡（k8s自带）\n\nk8s的内部服务发现是基于dns解析完成的\n\n默认解析到一个稳定虚拟 IP （Service），该虚拟 IP 再通过 kube_proxy 将流量均衡到后端 Pods 上。 （ Pod 的 IP 可能会随着 Pod 的重建而变动，但 Service 的 IP 是稳定的 ）\n\n#### 四层负载均衡 （容器级别的负载均衡）\n\n负载均衡器用 ip+port 接收请求，再直接转发到后端对应服务上；\n\n工作在传输层 ；\n\n客户端和服务器之间建立一次TCP连接，而负载均衡设备只是起到一个类似路由器的转发动作。\n\n基本原理都是：维护一个端口映射表，将对service请求按照策略分配给不同pod。\n\n官方提供三种模式：\n\n* userspace模式：性能差，维护一个iptables映射表，在用户态查询，需要来回切换用户态和内核态，消耗大。\n\n* iptables模式：性能适中，将对于iptables映射表的查询全部放在内核态，减少了用户态和内核态切换的时间消耗，但是当添加大量的iptables rules的时候，性能依然会变差。\n\n* ipvs模式：性能好，维护一个哈希表作为映射。1.9版本之后的k8s默认使用该策略\n\n#### 七层负载均衡（service 级别的负载均衡）\n\n七层负载均衡需要建立两次 TCP 连接， \nclient 到 LB（loadBalancer），LB根据消息中的内容( 比如 URL 或者 cookie 中的信息 )来做出负载均衡的决定； \n然后，建立 LB 到 server 的连接。\n\n<img src=\"http://gohoy.top/i/2023/08/11/r0dihv-1.png\" title=\"\" alt=\"\" width=\"307\">\n\n#### ingress\n\n<img src=\"http://gohoy.top/i/2023/08/11/rcwyal-1.png\" title=\"\" alt=\"\" width=\"337\">\n\n这是ingress的工作流程。通过不同域名来分配不同service\n\n### 外部负载均衡（使用第三方组件）\n\n<img src=\"http://gohoy.top/i/2023/08/11/rcx0i6-1.png\" title=\"\" alt=\"\" width=\"390\">\n\n根据chatgpt的回答，有大量开源插件能够实现负载均衡。但是大多数专注于七层负载均衡（service级别）。\n\nHAProxy：很多大型网站都在使用的组件，很好支持七层和四层负载。可以说是免费LB的最优选择。但是对于我们的项目（负载较小）有些“杀鸡用牛刀”。\n\n## 持久化策略\n\n### 通过导出历史命令文件，在下次启动时执行这个文件。\n\n想法：导出history文件，下次开启容器时执行。\n\nhistory可以加密后导出给用户，可以存储在主机。\n\n### 开放两种容器，一种支持持久化存储，一种不支持。\n\n### 开放两种容器，一种支持持久化存储，一种支持导出历史文件。\n\n","source":"_posts/k8s容器和虚拟机负载均衡方案分析.md","raw":"---\ntitle: K8S负载均衡方案\ncategory: K8S\ntag: \n - K8S\n - 负载均衡\n---\n\n# k8s容器和虚拟机负载均衡方案分析\n\n## 负载均衡方案\n\n### 先说结论：直接使用k8s的service\n\n原因：我们的项目较为轻量，并且实现的是容器级别的负载均衡，这点k8s默认支持的ipvs策略就实现很好。其他更多负载均衡策略着重于node级别或service级别。我们的项目并不需要。\n\n### 内部负载均衡（k8s自带）\n\nk8s的内部服务发现是基于dns解析完成的\n\n默认解析到一个稳定虚拟 IP （Service），该虚拟 IP 再通过 kube_proxy 将流量均衡到后端 Pods 上。 （ Pod 的 IP 可能会随着 Pod 的重建而变动，但 Service 的 IP 是稳定的 ）\n\n#### 四层负载均衡 （容器级别的负载均衡）\n\n负载均衡器用 ip+port 接收请求，再直接转发到后端对应服务上；\n\n工作在传输层 ；\n\n客户端和服务器之间建立一次TCP连接，而负载均衡设备只是起到一个类似路由器的转发动作。\n\n基本原理都是：维护一个端口映射表，将对service请求按照策略分配给不同pod。\n\n官方提供三种模式：\n\n* userspace模式：性能差，维护一个iptables映射表，在用户态查询，需要来回切换用户态和内核态，消耗大。\n\n* iptables模式：性能适中，将对于iptables映射表的查询全部放在内核态，减少了用户态和内核态切换的时间消耗，但是当添加大量的iptables rules的时候，性能依然会变差。\n\n* ipvs模式：性能好，维护一个哈希表作为映射。1.9版本之后的k8s默认使用该策略\n\n#### 七层负载均衡（service 级别的负载均衡）\n\n七层负载均衡需要建立两次 TCP 连接， \nclient 到 LB（loadBalancer），LB根据消息中的内容( 比如 URL 或者 cookie 中的信息 )来做出负载均衡的决定； \n然后，建立 LB 到 server 的连接。\n\n<img src=\"http://gohoy.top/i/2023/08/11/r0dihv-1.png\" title=\"\" alt=\"\" width=\"307\">\n\n#### ingress\n\n<img src=\"http://gohoy.top/i/2023/08/11/rcwyal-1.png\" title=\"\" alt=\"\" width=\"337\">\n\n这是ingress的工作流程。通过不同域名来分配不同service\n\n### 外部负载均衡（使用第三方组件）\n\n<img src=\"http://gohoy.top/i/2023/08/11/rcx0i6-1.png\" title=\"\" alt=\"\" width=\"390\">\n\n根据chatgpt的回答，有大量开源插件能够实现负载均衡。但是大多数专注于七层负载均衡（service级别）。\n\nHAProxy：很多大型网站都在使用的组件，很好支持七层和四层负载。可以说是免费LB的最优选择。但是对于我们的项目（负载较小）有些“杀鸡用牛刀”。\n\n## 持久化策略\n\n### 通过导出历史命令文件，在下次启动时执行这个文件。\n\n想法：导出history文件，下次开启容器时执行。\n\nhistory可以加密后导出给用户，可以存储在主机。\n\n### 开放两种容器，一种支持持久化存储，一种不支持。\n\n### 开放两种容器，一种支持持久化存储，一种支持导出历史文件。\n\n","slug":"k8s容器和虚拟机负载均衡方案分析","published":1,"date":"2023-08-30T06:28:51.554Z","updated":"2023-09-11T13:33:00.351Z","_id":"cllyxpksf000614gf4pft5uf0","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"k8s容器和虚拟机负载均衡方案分析\"><a href=\"#k8s容器和虚拟机负载均衡方案分析\" class=\"headerlink\" title=\"k8s容器和虚拟机负载均衡方案分析\"></a>k8s容器和虚拟机负载均衡方案分析</h1><h2 id=\"负载均衡方案\"><a href=\"#负载均衡方案\" class=\"headerlink\" title=\"负载均衡方案\"></a>负载均衡方案</h2><h3 id=\"先说结论：直接使用k8s的service\"><a href=\"#先说结论：直接使用k8s的service\" class=\"headerlink\" title=\"先说结论：直接使用k8s的service\"></a>先说结论：直接使用k8s的service</h3><p>原因：我们的项目较为轻量，并且实现的是容器级别的负载均衡，这点k8s默认支持的ipvs策略就实现很好。其他更多负载均衡策略着重于node级别或service级别。我们的项目并不需要。</p>\n<h3 id=\"内部负载均衡（k8s自带）\"><a href=\"#内部负载均衡（k8s自带）\" class=\"headerlink\" title=\"内部负载均衡（k8s自带）\"></a>内部负载均衡（k8s自带）</h3><p>k8s的内部服务发现是基于dns解析完成的</p>\n<p>默认解析到一个稳定虚拟 IP （Service），该虚拟 IP 再通过 kube_proxy 将流量均衡到后端 Pods 上。 （ Pod 的 IP 可能会随着 Pod 的重建而变动，但 Service 的 IP 是稳定的 ）</p>\n<h4 id=\"四层负载均衡-（容器级别的负载均衡）\"><a href=\"#四层负载均衡-（容器级别的负载均衡）\" class=\"headerlink\" title=\"四层负载均衡 （容器级别的负载均衡）\"></a>四层负载均衡 （容器级别的负载均衡）</h4><p>负载均衡器用 ip+port 接收请求，再直接转发到后端对应服务上；</p>\n<p>工作在传输层 ；</p>\n<p>客户端和服务器之间建立一次TCP连接，而负载均衡设备只是起到一个类似路由器的转发动作。</p>\n<p>基本原理都是：维护一个端口映射表，将对service请求按照策略分配给不同pod。</p>\n<p>官方提供三种模式：</p>\n<ul>\n<li><p>userspace模式：性能差，维护一个iptables映射表，在用户态查询，需要来回切换用户态和内核态，消耗大。</p>\n</li>\n<li><p>iptables模式：性能适中，将对于iptables映射表的查询全部放在内核态，减少了用户态和内核态切换的时间消耗，但是当添加大量的iptables rules的时候，性能依然会变差。</p>\n</li>\n<li><p>ipvs模式：性能好，维护一个哈希表作为映射。1.9版本之后的k8s默认使用该策略</p>\n</li>\n</ul>\n<h4 id=\"七层负载均衡（service-级别的负载均衡）\"><a href=\"#七层负载均衡（service-级别的负载均衡）\" class=\"headerlink\" title=\"七层负载均衡（service 级别的负载均衡）\"></a>七层负载均衡（service 级别的负载均衡）</h4><p>七层负载均衡需要建立两次 TCP 连接，<br>client 到 LB（loadBalancer），LB根据消息中的内容( 比如 URL 或者 cookie 中的信息 )来做出负载均衡的决定；<br>然后，建立 LB 到 server 的连接。</p>\n<img src=\"http://gohoy.top/i/2023/08/11/r0dihv-1.png\" title=\"\" alt=\"\" width=\"307\">\n\n<h4 id=\"ingress\"><a href=\"#ingress\" class=\"headerlink\" title=\"ingress\"></a>ingress</h4><img src=\"http://gohoy.top/i/2023/08/11/rcwyal-1.png\" title=\"\" alt=\"\" width=\"337\">\n\n<p>这是ingress的工作流程。通过不同域名来分配不同service</p>\n<h3 id=\"外部负载均衡（使用第三方组件）\"><a href=\"#外部负载均衡（使用第三方组件）\" class=\"headerlink\" title=\"外部负载均衡（使用第三方组件）\"></a>外部负载均衡（使用第三方组件）</h3><img src=\"http://gohoy.top/i/2023/08/11/rcx0i6-1.png\" title=\"\" alt=\"\" width=\"390\">\n\n<p>根据chatgpt的回答，有大量开源插件能够实现负载均衡。但是大多数专注于七层负载均衡（service级别）。</p>\n<p>HAProxy：很多大型网站都在使用的组件，很好支持七层和四层负载。可以说是免费LB的最优选择。但是对于我们的项目（负载较小）有些“杀鸡用牛刀”。</p>\n<h2 id=\"持久化策略\"><a href=\"#持久化策略\" class=\"headerlink\" title=\"持久化策略\"></a>持久化策略</h2><h3 id=\"通过导出历史命令文件，在下次启动时执行这个文件。\"><a href=\"#通过导出历史命令文件，在下次启动时执行这个文件。\" class=\"headerlink\" title=\"通过导出历史命令文件，在下次启动时执行这个文件。\"></a>通过导出历史命令文件，在下次启动时执行这个文件。</h3><p>想法：导出history文件，下次开启容器时执行。</p>\n<p>history可以加密后导出给用户，可以存储在主机。</p>\n<h3 id=\"开放两种容器，一种支持持久化存储，一种不支持。\"><a href=\"#开放两种容器，一种支持持久化存储，一种不支持。\" class=\"headerlink\" title=\"开放两种容器，一种支持持久化存储，一种不支持。\"></a>开放两种容器，一种支持持久化存储，一种不支持。</h3><h3 id=\"开放两种容器，一种支持持久化存储，一种支持导出历史文件。\"><a href=\"#开放两种容器，一种支持持久化存储，一种支持导出历史文件。\" class=\"headerlink\" title=\"开放两种容器，一种支持持久化存储，一种支持导出历史文件。\"></a>开放两种容器，一种支持持久化存储，一种支持导出历史文件。</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"k8s容器和虚拟机负载均衡方案分析\"><a href=\"#k8s容器和虚拟机负载均衡方案分析\" class=\"headerlink\" title=\"k8s容器和虚拟机负载均衡方案分析\"></a>k8s容器和虚拟机负载均衡方案分析</h1><h2 id=\"负载均衡方案\"><a href=\"#负载均衡方案\" class=\"headerlink\" title=\"负载均衡方案\"></a>负载均衡方案</h2><h3 id=\"先说结论：直接使用k8s的service\"><a href=\"#先说结论：直接使用k8s的service\" class=\"headerlink\" title=\"先说结论：直接使用k8s的service\"></a>先说结论：直接使用k8s的service</h3><p>原因：我们的项目较为轻量，并且实现的是容器级别的负载均衡，这点k8s默认支持的ipvs策略就实现很好。其他更多负载均衡策略着重于node级别或service级别。我们的项目并不需要。</p>\n<h3 id=\"内部负载均衡（k8s自带）\"><a href=\"#内部负载均衡（k8s自带）\" class=\"headerlink\" title=\"内部负载均衡（k8s自带）\"></a>内部负载均衡（k8s自带）</h3><p>k8s的内部服务发现是基于dns解析完成的</p>\n<p>默认解析到一个稳定虚拟 IP （Service），该虚拟 IP 再通过 kube_proxy 将流量均衡到后端 Pods 上。 （ Pod 的 IP 可能会随着 Pod 的重建而变动，但 Service 的 IP 是稳定的 ）</p>\n<h4 id=\"四层负载均衡-（容器级别的负载均衡）\"><a href=\"#四层负载均衡-（容器级别的负载均衡）\" class=\"headerlink\" title=\"四层负载均衡 （容器级别的负载均衡）\"></a>四层负载均衡 （容器级别的负载均衡）</h4><p>负载均衡器用 ip+port 接收请求，再直接转发到后端对应服务上；</p>\n<p>工作在传输层 ；</p>\n<p>客户端和服务器之间建立一次TCP连接，而负载均衡设备只是起到一个类似路由器的转发动作。</p>\n<p>基本原理都是：维护一个端口映射表，将对service请求按照策略分配给不同pod。</p>\n<p>官方提供三种模式：</p>\n<ul>\n<li><p>userspace模式：性能差，维护一个iptables映射表，在用户态查询，需要来回切换用户态和内核态，消耗大。</p>\n</li>\n<li><p>iptables模式：性能适中，将对于iptables映射表的查询全部放在内核态，减少了用户态和内核态切换的时间消耗，但是当添加大量的iptables rules的时候，性能依然会变差。</p>\n</li>\n<li><p>ipvs模式：性能好，维护一个哈希表作为映射。1.9版本之后的k8s默认使用该策略</p>\n</li>\n</ul>\n<h4 id=\"七层负载均衡（service-级别的负载均衡）\"><a href=\"#七层负载均衡（service-级别的负载均衡）\" class=\"headerlink\" title=\"七层负载均衡（service 级别的负载均衡）\"></a>七层负载均衡（service 级别的负载均衡）</h4><p>七层负载均衡需要建立两次 TCP 连接，<br>client 到 LB（loadBalancer），LB根据消息中的内容( 比如 URL 或者 cookie 中的信息 )来做出负载均衡的决定；<br>然后，建立 LB 到 server 的连接。</p>\n<img src=\"http://gohoy.top/i/2023/08/11/r0dihv-1.png\" title=\"\" alt=\"\" width=\"307\">\n\n<h4 id=\"ingress\"><a href=\"#ingress\" class=\"headerlink\" title=\"ingress\"></a>ingress</h4><img src=\"http://gohoy.top/i/2023/08/11/rcwyal-1.png\" title=\"\" alt=\"\" width=\"337\">\n\n<p>这是ingress的工作流程。通过不同域名来分配不同service</p>\n<h3 id=\"外部负载均衡（使用第三方组件）\"><a href=\"#外部负载均衡（使用第三方组件）\" class=\"headerlink\" title=\"外部负载均衡（使用第三方组件）\"></a>外部负载均衡（使用第三方组件）</h3><img src=\"http://gohoy.top/i/2023/08/11/rcx0i6-1.png\" title=\"\" alt=\"\" width=\"390\">\n\n<p>根据chatgpt的回答，有大量开源插件能够实现负载均衡。但是大多数专注于七层负载均衡（service级别）。</p>\n<p>HAProxy：很多大型网站都在使用的组件，很好支持七层和四层负载。可以说是免费LB的最优选择。但是对于我们的项目（负载较小）有些“杀鸡用牛刀”。</p>\n<h2 id=\"持久化策略\"><a href=\"#持久化策略\" class=\"headerlink\" title=\"持久化策略\"></a>持久化策略</h2><h3 id=\"通过导出历史命令文件，在下次启动时执行这个文件。\"><a href=\"#通过导出历史命令文件，在下次启动时执行这个文件。\" class=\"headerlink\" title=\"通过导出历史命令文件，在下次启动时执行这个文件。\"></a>通过导出历史命令文件，在下次启动时执行这个文件。</h3><p>想法：导出history文件，下次开启容器时执行。</p>\n<p>history可以加密后导出给用户，可以存储在主机。</p>\n<h3 id=\"开放两种容器，一种支持持久化存储，一种不支持。\"><a href=\"#开放两种容器，一种支持持久化存储，一种不支持。\" class=\"headerlink\" title=\"开放两种容器，一种支持持久化存储，一种不支持。\"></a>开放两种容器，一种支持持久化存储，一种不支持。</h3><h3 id=\"开放两种容器，一种支持持久化存储，一种支持导出历史文件。\"><a href=\"#开放两种容器，一种支持持久化存储，一种支持导出历史文件。\" class=\"headerlink\" title=\"开放两种容器，一种支持持久化存储，一种支持导出历史文件。\"></a>开放两种容器，一种支持持久化存储，一种支持导出历史文件。</h3>"},{"title":"兰亭序吉他谱","_content":"\n<img title=\"\" src=\"http://gohoy.top/i/2023/08/30/nuosq7-1.png\" alt=\"\" width=\"737\" style=\"zoom:150%;\"   >\n\n![](http://gohoy.top/i/2023/08/11/shcrib-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shd57a-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shd8rt-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shdptl-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shdwnj-1.png)\n\n![](http://gohoy.top/i/2023/08/11/she18r-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shecbc-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sheuju-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sheycz-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shf5w3-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shfjuk-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shfxj5-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shgd1p-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shginl-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shgoli-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shh18s-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shhal1-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shhhnd-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shhpmm-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shi00x-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shi4tp-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shio0k-1.png)\n","source":"_posts/兰亭序吉他谱.md","raw":"---\ntitle: 兰亭序吉他谱\ncategory: 吉他谱\ntag: \n - 吉他谱\n---\n\n<img title=\"\" src=\"http://gohoy.top/i/2023/08/30/nuosq7-1.png\" alt=\"\" width=\"737\" style=\"zoom:150%;\"   >\n\n![](http://gohoy.top/i/2023/08/11/shcrib-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shd57a-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shd8rt-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shdptl-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shdwnj-1.png)\n\n![](http://gohoy.top/i/2023/08/11/she18r-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shecbc-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sheuju-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sheycz-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shf5w3-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shfjuk-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shfxj5-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shgd1p-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shginl-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shgoli-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shh18s-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shhal1-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shhhnd-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shhpmm-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shi00x-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shi4tp-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shio0k-1.png)\n","slug":"兰亭序吉他谱","published":1,"date":"2023-08-30T06:28:51.574Z","updated":"2023-08-30T06:42:45.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllyxpksh000914gfdjctcaaa","content":"<img title=\"\" src=\"http://gohoy.top/i/2023/08/30/nuosq7-1.png\" alt=\"\" width=\"737\" style=\"zoom:150%;\"   >\n\n<p><img src=\"http://gohoy.top/i/2023/08/11/shcrib-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shd57a-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shd8rt-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shdptl-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shdwnj-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/she18r-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shecbc-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sheuju-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sheycz-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shf5w3-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shfjuk-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shfxj5-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shgd1p-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shginl-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shgoli-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shh18s-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shhal1-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shhhnd-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shhpmm-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shi00x-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shi4tp-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shio0k-1.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<img title=\"\" src=\"http://gohoy.top/i/2023/08/30/nuosq7-1.png\" alt=\"\" width=\"737\" style=\"zoom:150%;\"   >\n\n<p><img src=\"http://gohoy.top/i/2023/08/11/shcrib-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shd57a-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shd8rt-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shdptl-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shdwnj-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/she18r-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shecbc-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sheuju-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sheycz-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shf5w3-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shfjuk-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shfxj5-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shgd1p-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shginl-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shgoli-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shh18s-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shhal1-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shhhnd-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shhpmm-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shi00x-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shi4tp-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shio0k-1.png\"></p>\n"},{"title":"四子ding设计","_content":"\n# 四子ding 设计\n\n我想完成一个棋类游戏，规则如下：\n游戏开始时，双方各执黑白棋子，棋盘为4x4的空棋盘。\n玩家依次在空闲的交叉处放置自己的棋子，可以利用特定序列完成吃子。\n在放置棋子的过程中，如果某个玩家第一个完成了特定序列吃子的条件，该玩家获得发言权。\n发言权的作用是在放置棋子后，在开始移动棋子之前进行两个操作：后手拿走敌方一个棋子和先手移动自己的棋子。\n移动棋子时，玩家可以将棋子向相邻的空闲位置移动一格。\n如果移动后的棋子所在的行或列满足特定的吃子条件，即符合规则中描述的吃子情况，可以吃掉对方的棋子。\n吃子后，被吃掉的棋子需要从棋盘上移除，吃子的玩家不获得其他优势。\n如果某一方在棋盘上完成了四子连珠，特定位置的连珠可以移出对方的棋子。在棋盘中间位置的四子连珠能移出对方的两个棋子，而在边线上的四子连珠能移出对方的一个棋子。斜方向不算连珠。\n最终，先吃完对方的棋子的玩家获胜。\n吃子序列为：\n\n吃子的序列规定为,假设a为己方棋子，b为敌方棋子，A为最近放置或移动的棋子,0为没有棋子:(1)Aab0,aAb0,0aAb,0Aab,baA0,bAa0,0bAa,0baA。可以吃掉b一个棋子。但是在0的地方不能有任何棋子，不然则不符合(1)的吃子序列，但有可能符合(2)的序列\n(2)aAbb Aabb bbaA bbAa可以吃掉bb两个棋子。\n(3)Abbb bbbA可以吃掉bbb三个棋子。\n需要注意的是，只有第一个符合(1)完成吃子的才能获得\"发言权\"\n这些序列对横竖列都生效\n\n\n\n","source":"_posts/四子ding 设计.md","raw":"---\ntitle: 四子ding设计\ncategory: 设计文档\ntag: \n - 设计文档\n - 四子ding\n---\n\n# 四子ding 设计\n\n我想完成一个棋类游戏，规则如下：\n游戏开始时，双方各执黑白棋子，棋盘为4x4的空棋盘。\n玩家依次在空闲的交叉处放置自己的棋子，可以利用特定序列完成吃子。\n在放置棋子的过程中，如果某个玩家第一个完成了特定序列吃子的条件，该玩家获得发言权。\n发言权的作用是在放置棋子后，在开始移动棋子之前进行两个操作：后手拿走敌方一个棋子和先手移动自己的棋子。\n移动棋子时，玩家可以将棋子向相邻的空闲位置移动一格。\n如果移动后的棋子所在的行或列满足特定的吃子条件，即符合规则中描述的吃子情况，可以吃掉对方的棋子。\n吃子后，被吃掉的棋子需要从棋盘上移除，吃子的玩家不获得其他优势。\n如果某一方在棋盘上完成了四子连珠，特定位置的连珠可以移出对方的棋子。在棋盘中间位置的四子连珠能移出对方的两个棋子，而在边线上的四子连珠能移出对方的一个棋子。斜方向不算连珠。\n最终，先吃完对方的棋子的玩家获胜。\n吃子序列为：\n\n吃子的序列规定为,假设a为己方棋子，b为敌方棋子，A为最近放置或移动的棋子,0为没有棋子:(1)Aab0,aAb0,0aAb,0Aab,baA0,bAa0,0bAa,0baA。可以吃掉b一个棋子。但是在0的地方不能有任何棋子，不然则不符合(1)的吃子序列，但有可能符合(2)的序列\n(2)aAbb Aabb bbaA bbAa可以吃掉bb两个棋子。\n(3)Abbb bbbA可以吃掉bbb三个棋子。\n需要注意的是，只有第一个符合(1)完成吃子的才能获得\"发言权\"\n这些序列对横竖列都生效\n\n\n\n","slug":"四子ding 设计","published":1,"date":"2023-08-30T06:28:51.579Z","updated":"2023-09-11T13:39:37.696Z","_id":"cllyxpksh000a14gf8xah0ujq","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"四子ding-设计\"><a href=\"#四子ding-设计\" class=\"headerlink\" title=\"四子ding 设计\"></a>四子ding 设计</h1><p>我想完成一个棋类游戏，规则如下：<br>游戏开始时，双方各执黑白棋子，棋盘为4x4的空棋盘。<br>玩家依次在空闲的交叉处放置自己的棋子，可以利用特定序列完成吃子。<br>在放置棋子的过程中，如果某个玩家第一个完成了特定序列吃子的条件，该玩家获得发言权。<br>发言权的作用是在放置棋子后，在开始移动棋子之前进行两个操作：后手拿走敌方一个棋子和先手移动自己的棋子。<br>移动棋子时，玩家可以将棋子向相邻的空闲位置移动一格。<br>如果移动后的棋子所在的行或列满足特定的吃子条件，即符合规则中描述的吃子情况，可以吃掉对方的棋子。<br>吃子后，被吃掉的棋子需要从棋盘上移除，吃子的玩家不获得其他优势。<br>如果某一方在棋盘上完成了四子连珠，特定位置的连珠可以移出对方的棋子。在棋盘中间位置的四子连珠能移出对方的两个棋子，而在边线上的四子连珠能移出对方的一个棋子。斜方向不算连珠。<br>最终，先吃完对方的棋子的玩家获胜。<br>吃子序列为：</p>\n<p>吃子的序列规定为,假设a为己方棋子，b为敌方棋子，A为最近放置或移动的棋子,0为没有棋子:(1)Aab0,aAb0,0aAb,0Aab,baA0,bAa0,0bAa,0baA。可以吃掉b一个棋子。但是在0的地方不能有任何棋子，不然则不符合(1)的吃子序列，但有可能符合(2)的序列<br>(2)aAbb Aabb bbaA bbAa可以吃掉bb两个棋子。<br>(3)Abbb bbbA可以吃掉bbb三个棋子。<br>需要注意的是，只有第一个符合(1)完成吃子的才能获得”发言权”<br>这些序列对横竖列都生效</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"四子ding-设计\"><a href=\"#四子ding-设计\" class=\"headerlink\" title=\"四子ding 设计\"></a>四子ding 设计</h1><p>我想完成一个棋类游戏，规则如下：<br>游戏开始时，双方各执黑白棋子，棋盘为4x4的空棋盘。<br>玩家依次在空闲的交叉处放置自己的棋子，可以利用特定序列完成吃子。<br>在放置棋子的过程中，如果某个玩家第一个完成了特定序列吃子的条件，该玩家获得发言权。<br>发言权的作用是在放置棋子后，在开始移动棋子之前进行两个操作：后手拿走敌方一个棋子和先手移动自己的棋子。<br>移动棋子时，玩家可以将棋子向相邻的空闲位置移动一格。<br>如果移动后的棋子所在的行或列满足特定的吃子条件，即符合规则中描述的吃子情况，可以吃掉对方的棋子。<br>吃子后，被吃掉的棋子需要从棋盘上移除，吃子的玩家不获得其他优势。<br>如果某一方在棋盘上完成了四子连珠，特定位置的连珠可以移出对方的棋子。在棋盘中间位置的四子连珠能移出对方的两个棋子，而在边线上的四子连珠能移出对方的一个棋子。斜方向不算连珠。<br>最终，先吃完对方的棋子的玩家获胜。<br>吃子序列为：</p>\n<p>吃子的序列规定为,假设a为己方棋子，b为敌方棋子，A为最近放置或移动的棋子,0为没有棋子:(1)Aab0,aAb0,0aAb,0Aab,baA0,bAa0,0bAa,0baA。可以吃掉b一个棋子。但是在0的地方不能有任何棋子，不然则不符合(1)的吃子序列，但有可能符合(2)的序列<br>(2)aAbb Aabb bbaA bbAa可以吃掉bb两个棋子。<br>(3)Abbb bbbA可以吃掉bbb三个棋子。<br>需要注意的是，只有第一个符合(1)完成吃子的才能获得”发言权”<br>这些序列对横竖列都生效</p>\n"},{"title":"小幸运吉他谱","_content":"\n<img src=\"http://gohoy.top/i/2023/09/03/z03lhz-1.png\" title=\"\" alt=\"\" width=\"888\">\n\n![](http://gohoy.top/i/2023/09/03/z041mp-1.png)\n\n![](http://gohoy.top/i/2023/09/03/z04gr0-1.png)\n\n![](http://gohoy.top/i/2023/09/03/z04xeu-1.png)\n\n<img title=\"\" src=\"http://gohoy.top/i/2023/09/03/z051zt-1.png\" alt=\"\" width=\"653\">\n","source":"_posts/小幸运吉他.md","raw":"---\ntitle: 小幸运吉他谱\ncategory: 吉他谱\ntag: \n - 吉他谱\n---\n\n<img src=\"http://gohoy.top/i/2023/09/03/z03lhz-1.png\" title=\"\" alt=\"\" width=\"888\">\n\n![](http://gohoy.top/i/2023/09/03/z041mp-1.png)\n\n![](http://gohoy.top/i/2023/09/03/z04gr0-1.png)\n\n![](http://gohoy.top/i/2023/09/03/z04xeu-1.png)\n\n<img title=\"\" src=\"http://gohoy.top/i/2023/09/03/z051zt-1.png\" alt=\"\" width=\"653\">\n","slug":"小幸运吉他","published":1,"date":"2023-08-30T06:28:51.584Z","updated":"2023-09-03T13:16:55.952Z","_id":"cllyxpksj000e14gf65nf48xn","comments":1,"layout":"post","photos":[],"link":"","content":"<img src=\"http://gohoy.top/i/2023/09/03/z03lhz-1.png\" title=\"\" alt=\"\" width=\"888\">\n\n<p><img src=\"http://gohoy.top/i/2023/09/03/z041mp-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/09/03/z04gr0-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/09/03/z04xeu-1.png\"></p>\n<img title=\"\" src=\"http://gohoy.top/i/2023/09/03/z051zt-1.png\" alt=\"\" width=\"653\">\n","site":{"data":{}},"excerpt":"","more":"<img src=\"http://gohoy.top/i/2023/09/03/z03lhz-1.png\" title=\"\" alt=\"\" width=\"888\">\n\n<p><img src=\"http://gohoy.top/i/2023/09/03/z041mp-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/09/03/z04gr0-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/09/03/z04xeu-1.png\"></p>\n<img title=\"\" src=\"http://gohoy.top/i/2023/09/03/z051zt-1.png\" alt=\"\" width=\"653\">\n"},{"title":"晴天吉他谱","_content":"\n![](https://gohoy.top/i/2023/09/04/vlfkfw-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlfsal-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlfffb-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlfhp9-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlfidk-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlfj3z-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlg5e6-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlgclr-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlgetf-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlgak1-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlgc0q-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlgl3d-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlh57v-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlh8rq-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlh5kz-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlhgkq-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlhhvg-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlhm5g-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vli1u7-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlicyb-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vli4v7-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vli6vn-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vli6xq-1.png)\n","source":"_posts/晴天.md","raw":"---\ntitle: 晴天吉他谱\ncategory: 吉他谱\ntag: \n - 吉他谱\n---\n\n![](https://gohoy.top/i/2023/09/04/vlfkfw-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlfsal-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlfffb-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlfhp9-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlfidk-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlfj3z-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlg5e6-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlgclr-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlgetf-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlgak1-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlgc0q-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlgl3d-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlh57v-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlh8rq-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlh5kz-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlhgkq-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlhhvg-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlhm5g-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vli1u7-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vlicyb-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vli4v7-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vli6vn-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vli6xq-1.png)\n","slug":"晴天","published":1,"date":"2023-08-30T06:28:51.575Z","updated":"2023-09-04T11:11:02.864Z","_id":"cllyxpksj000g14gf6kq8fry4","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://gohoy.top/i/2023/09/04/vlfkfw-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlfsal-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlfffb-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlfhp9-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlfidk-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlfj3z-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlg5e6-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlgclr-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlgetf-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlgak1-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlgc0q-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlgl3d-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlh57v-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlh8rq-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlh5kz-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlhgkq-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlhhvg-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlhm5g-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vli1u7-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlicyb-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vli4v7-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vli6vn-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vli6xq-1.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://gohoy.top/i/2023/09/04/vlfkfw-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlfsal-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlfffb-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlfhp9-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlfidk-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlfj3z-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlg5e6-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlgclr-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlgetf-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlgak1-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlgc0q-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlgl3d-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlh57v-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlh8rq-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlh5kz-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlhgkq-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlhhvg-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlhm5g-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vli1u7-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vlicyb-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vli4v7-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vli6vn-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vli6xq-1.png\"></p>\n"},{"title":"openEuler docker container构建","_content":"\n# openeuler container 构建\n\n## 运行官方的docker镜像\n\n```shell\n docker run --name euler1 --network host -it  openeuler/openeuler:22.03 /bin/bash \n```\n\n不指定 --network 的时候会连不上网，原因暂且未知，但是k8s起一个pod可以正常联网\n\n## 安装包\n\n```shell\nyum install -y openssh-server openssh-clients lsof passwd gdb make ncurses-devel flex bison openssl openssl-devel elfutils-libelf-devel binutils binutils-devel\n```\n\n## 配置ssh\n\n```shell\n ssh-keygen -A\n /usr/sbin/sshd\n lsof -i:22\n passwd //修改root密码为123456\n```\n\n## 将kernel源码移入container内\n\n```shell\ndocker cp ./kernel euler:/home/\n```\n\n## 在内部复制一份内核文件。make clean 后进行make 确保make编译环境没有问题。\n\n## 内部头文件环境也完整\n\n![](http://gohoy.top/i/2023/08/11/s99838-1.png)\n\n## 导出镜像包\n\n```shell\ndocker export euler1 -o /home/gohoy/docker-img/euler-container.tar\n```\n\n## 导入镜像包，查看是否成功保存快照\n\n```shell\ncat /home/gohoy/docker-img/euler-container.tar | docker import - openeuler/container:v1\n```\n\n```shell\ndocker run --name euler_container --it openeuler/container:v1 /bin/bash\n```\n\n成功进入镜像中，且环境完整。\n\n## 最终镜像大小4.56gb 其中kernel源代码3.6gb\n\n![](http://gohoy.top/i/2023/08/11/s994bn-1.png)\n\n## 脚本以及配置文件\n\n```pod.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: container\n  labels:\n    stl: container\nspec:\n  containers:\n    - name: container\n      command:\n        - \"/bin/bash\"\n        - \"-ce\"\n        - \"tail -f /dev/null\"\n      lifecycle:\n        postStart:\n          exec:\n            command: [\"/usr/sbin/sshd\"] #启动container运行sshd\n      resources:\n        limits:\n          memory: 1G\n          cpu: 1\n      image: openeuler/container:v2\n```\n\n```shell\n  for (( i=1; i <= $1 ; i++ ))\n  do\n    container=($(kubectl get pods | sed -n '2,$p'| gawk '{print $1}'))\n     if echo \"${container[@]}\" | grep -wq \"container-$i\"\n     then\n       continue\n     else\n       ((ssh=30000+$i))\n       sed -e \"4s/service/service-$i/; 10s/30000/$ssh/; 13s/container/container-$i/\" /home/gohoy/docker-img/service.yaml > /home/gohoy/docker-img/tmpservice.yaml #service\n       kubectl create -f  /home/gohoy/docker-img/tmpservice.yaml\n       sed -e \"4s/container/container-$i/; 6s/container/container-$i/; 9s/container/container-$i/\"  /home/gohoy/docker-img/pod.yaml >  /home/gohoy/docker-img/tmppod.yaml # \n       kubectl apply -f  /home/gohoy/docker-img/tmppod.yaml\n\n     fi\n  done\n```\n","source":"_posts/构建openEuler的docker容器.md","raw":"---\ntitle: openEuler docker container构建\ncategory: docker\ntag: \n - docker\n - 教程\n - contianer\n - openEuler\n---\n\n# openeuler container 构建\n\n## 运行官方的docker镜像\n\n```shell\n docker run --name euler1 --network host -it  openeuler/openeuler:22.03 /bin/bash \n```\n\n不指定 --network 的时候会连不上网，原因暂且未知，但是k8s起一个pod可以正常联网\n\n## 安装包\n\n```shell\nyum install -y openssh-server openssh-clients lsof passwd gdb make ncurses-devel flex bison openssl openssl-devel elfutils-libelf-devel binutils binutils-devel\n```\n\n## 配置ssh\n\n```shell\n ssh-keygen -A\n /usr/sbin/sshd\n lsof -i:22\n passwd //修改root密码为123456\n```\n\n## 将kernel源码移入container内\n\n```shell\ndocker cp ./kernel euler:/home/\n```\n\n## 在内部复制一份内核文件。make clean 后进行make 确保make编译环境没有问题。\n\n## 内部头文件环境也完整\n\n![](http://gohoy.top/i/2023/08/11/s99838-1.png)\n\n## 导出镜像包\n\n```shell\ndocker export euler1 -o /home/gohoy/docker-img/euler-container.tar\n```\n\n## 导入镜像包，查看是否成功保存快照\n\n```shell\ncat /home/gohoy/docker-img/euler-container.tar | docker import - openeuler/container:v1\n```\n\n```shell\ndocker run --name euler_container --it openeuler/container:v1 /bin/bash\n```\n\n成功进入镜像中，且环境完整。\n\n## 最终镜像大小4.56gb 其中kernel源代码3.6gb\n\n![](http://gohoy.top/i/2023/08/11/s994bn-1.png)\n\n## 脚本以及配置文件\n\n```pod.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: container\n  labels:\n    stl: container\nspec:\n  containers:\n    - name: container\n      command:\n        - \"/bin/bash\"\n        - \"-ce\"\n        - \"tail -f /dev/null\"\n      lifecycle:\n        postStart:\n          exec:\n            command: [\"/usr/sbin/sshd\"] #启动container运行sshd\n      resources:\n        limits:\n          memory: 1G\n          cpu: 1\n      image: openeuler/container:v2\n```\n\n```shell\n  for (( i=1; i <= $1 ; i++ ))\n  do\n    container=($(kubectl get pods | sed -n '2,$p'| gawk '{print $1}'))\n     if echo \"${container[@]}\" | grep -wq \"container-$i\"\n     then\n       continue\n     else\n       ((ssh=30000+$i))\n       sed -e \"4s/service/service-$i/; 10s/30000/$ssh/; 13s/container/container-$i/\" /home/gohoy/docker-img/service.yaml > /home/gohoy/docker-img/tmpservice.yaml #service\n       kubectl create -f  /home/gohoy/docker-img/tmpservice.yaml\n       sed -e \"4s/container/container-$i/; 6s/container/container-$i/; 9s/container/container-$i/\"  /home/gohoy/docker-img/pod.yaml >  /home/gohoy/docker-img/tmppod.yaml # \n       kubectl apply -f  /home/gohoy/docker-img/tmppod.yaml\n\n     fi\n  done\n```\n","slug":"构建openEuler的docker容器","published":1,"date":"2023-08-30T06:28:51.568Z","updated":"2023-08-30T06:35:53.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllyxpksl000k14gf2yvfgf4e","content":"<h1 id=\"openeuler-container-构建\"><a href=\"#openeuler-container-构建\" class=\"headerlink\" title=\"openeuler container 构建\"></a>openeuler container 构建</h1><h2 id=\"运行官方的docker镜像\"><a href=\"#运行官方的docker镜像\" class=\"headerlink\" title=\"运行官方的docker镜像\"></a>运行官方的docker镜像</h2><pre><code class=\"shell\"> docker run --name euler1 --network host -it  openeuler/openeuler:22.03 /bin/bash \n</code></pre>\n<p>不指定 –network 的时候会连不上网，原因暂且未知，但是k8s起一个pod可以正常联网</p>\n<h2 id=\"安装包\"><a href=\"#安装包\" class=\"headerlink\" title=\"安装包\"></a>安装包</h2><pre><code class=\"shell\">yum install -y openssh-server openssh-clients lsof passwd gdb make ncurses-devel flex bison openssl openssl-devel elfutils-libelf-devel binutils binutils-devel\n</code></pre>\n<h2 id=\"配置ssh\"><a href=\"#配置ssh\" class=\"headerlink\" title=\"配置ssh\"></a>配置ssh</h2><pre><code class=\"shell\"> ssh-keygen -A\n /usr/sbin/sshd\n lsof -i:22\n passwd //修改root密码为123456\n</code></pre>\n<h2 id=\"将kernel源码移入container内\"><a href=\"#将kernel源码移入container内\" class=\"headerlink\" title=\"将kernel源码移入container内\"></a>将kernel源码移入container内</h2><pre><code class=\"shell\">docker cp ./kernel euler:/home/\n</code></pre>\n<h2 id=\"在内部复制一份内核文件。make-clean-后进行make-确保make编译环境没有问题。\"><a href=\"#在内部复制一份内核文件。make-clean-后进行make-确保make编译环境没有问题。\" class=\"headerlink\" title=\"在内部复制一份内核文件。make clean 后进行make 确保make编译环境没有问题。\"></a>在内部复制一份内核文件。make clean 后进行make 确保make编译环境没有问题。</h2><h2 id=\"内部头文件环境也完整\"><a href=\"#内部头文件环境也完整\" class=\"headerlink\" title=\"内部头文件环境也完整\"></a>内部头文件环境也完整</h2><p><img src=\"http://gohoy.top/i/2023/08/11/s99838-1.png\"></p>\n<h2 id=\"导出镜像包\"><a href=\"#导出镜像包\" class=\"headerlink\" title=\"导出镜像包\"></a>导出镜像包</h2><pre><code class=\"shell\">docker export euler1 -o /home/gohoy/docker-img/euler-container.tar\n</code></pre>\n<h2 id=\"导入镜像包，查看是否成功保存快照\"><a href=\"#导入镜像包，查看是否成功保存快照\" class=\"headerlink\" title=\"导入镜像包，查看是否成功保存快照\"></a>导入镜像包，查看是否成功保存快照</h2><pre><code class=\"shell\">cat /home/gohoy/docker-img/euler-container.tar | docker import - openeuler/container:v1\n</code></pre>\n<pre><code class=\"shell\">docker run --name euler_container --it openeuler/container:v1 /bin/bash\n</code></pre>\n<p>成功进入镜像中，且环境完整。</p>\n<h2 id=\"最终镜像大小4-56gb-其中kernel源代码3-6gb\"><a href=\"#最终镜像大小4-56gb-其中kernel源代码3-6gb\" class=\"headerlink\" title=\"最终镜像大小4.56gb 其中kernel源代码3.6gb\"></a>最终镜像大小4.56gb 其中kernel源代码3.6gb</h2><p><img src=\"http://gohoy.top/i/2023/08/11/s994bn-1.png\"></p>\n<h2 id=\"脚本以及配置文件\"><a href=\"#脚本以及配置文件\" class=\"headerlink\" title=\"脚本以及配置文件\"></a>脚本以及配置文件</h2><pre><code class=\"pod.yaml\">apiVersion: v1\nkind: Pod\nmetadata:\n  name: container\n  labels:\n    stl: container\nspec:\n  containers:\n    - name: container\n      command:\n        - &quot;/bin/bash&quot;\n        - &quot;-ce&quot;\n        - &quot;tail -f /dev/null&quot;\n      lifecycle:\n        postStart:\n          exec:\n            command: [&quot;/usr/sbin/sshd&quot;] #启动container运行sshd\n      resources:\n        limits:\n          memory: 1G\n          cpu: 1\n      image: openeuler/container:v2\n</code></pre>\n<pre><code class=\"shell\">  for (( i=1; i &lt;= $1 ; i++ ))\n  do\n    container=($(kubectl get pods | sed -n &#39;2,$p&#39;| gawk &#39;&#123;print $1&#125;&#39;))\n     if echo &quot;$&#123;container[@]&#125;&quot; | grep -wq &quot;container-$i&quot;\n     then\n       continue\n     else\n       ((ssh=30000+$i))\n       sed -e &quot;4s/service/service-$i/; 10s/30000/$ssh/; 13s/container/container-$i/&quot; /home/gohoy/docker-img/service.yaml &gt; /home/gohoy/docker-img/tmpservice.yaml #service\n       kubectl create -f  /home/gohoy/docker-img/tmpservice.yaml\n       sed -e &quot;4s/container/container-$i/; 6s/container/container-$i/; 9s/container/container-$i/&quot;  /home/gohoy/docker-img/pod.yaml &gt;  /home/gohoy/docker-img/tmppod.yaml # \n       kubectl apply -f  /home/gohoy/docker-img/tmppod.yaml\n\n     fi\n  done\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"openeuler-container-构建\"><a href=\"#openeuler-container-构建\" class=\"headerlink\" title=\"openeuler container 构建\"></a>openeuler container 构建</h1><h2 id=\"运行官方的docker镜像\"><a href=\"#运行官方的docker镜像\" class=\"headerlink\" title=\"运行官方的docker镜像\"></a>运行官方的docker镜像</h2><pre><code class=\"shell\"> docker run --name euler1 --network host -it  openeuler/openeuler:22.03 /bin/bash \n</code></pre>\n<p>不指定 –network 的时候会连不上网，原因暂且未知，但是k8s起一个pod可以正常联网</p>\n<h2 id=\"安装包\"><a href=\"#安装包\" class=\"headerlink\" title=\"安装包\"></a>安装包</h2><pre><code class=\"shell\">yum install -y openssh-server openssh-clients lsof passwd gdb make ncurses-devel flex bison openssl openssl-devel elfutils-libelf-devel binutils binutils-devel\n</code></pre>\n<h2 id=\"配置ssh\"><a href=\"#配置ssh\" class=\"headerlink\" title=\"配置ssh\"></a>配置ssh</h2><pre><code class=\"shell\"> ssh-keygen -A\n /usr/sbin/sshd\n lsof -i:22\n passwd //修改root密码为123456\n</code></pre>\n<h2 id=\"将kernel源码移入container内\"><a href=\"#将kernel源码移入container内\" class=\"headerlink\" title=\"将kernel源码移入container内\"></a>将kernel源码移入container内</h2><pre><code class=\"shell\">docker cp ./kernel euler:/home/\n</code></pre>\n<h2 id=\"在内部复制一份内核文件。make-clean-后进行make-确保make编译环境没有问题。\"><a href=\"#在内部复制一份内核文件。make-clean-后进行make-确保make编译环境没有问题。\" class=\"headerlink\" title=\"在内部复制一份内核文件。make clean 后进行make 确保make编译环境没有问题。\"></a>在内部复制一份内核文件。make clean 后进行make 确保make编译环境没有问题。</h2><h2 id=\"内部头文件环境也完整\"><a href=\"#内部头文件环境也完整\" class=\"headerlink\" title=\"内部头文件环境也完整\"></a>内部头文件环境也完整</h2><p><img src=\"http://gohoy.top/i/2023/08/11/s99838-1.png\"></p>\n<h2 id=\"导出镜像包\"><a href=\"#导出镜像包\" class=\"headerlink\" title=\"导出镜像包\"></a>导出镜像包</h2><pre><code class=\"shell\">docker export euler1 -o /home/gohoy/docker-img/euler-container.tar\n</code></pre>\n<h2 id=\"导入镜像包，查看是否成功保存快照\"><a href=\"#导入镜像包，查看是否成功保存快照\" class=\"headerlink\" title=\"导入镜像包，查看是否成功保存快照\"></a>导入镜像包，查看是否成功保存快照</h2><pre><code class=\"shell\">cat /home/gohoy/docker-img/euler-container.tar | docker import - openeuler/container:v1\n</code></pre>\n<pre><code class=\"shell\">docker run --name euler_container --it openeuler/container:v1 /bin/bash\n</code></pre>\n<p>成功进入镜像中，且环境完整。</p>\n<h2 id=\"最终镜像大小4-56gb-其中kernel源代码3-6gb\"><a href=\"#最终镜像大小4-56gb-其中kernel源代码3-6gb\" class=\"headerlink\" title=\"最终镜像大小4.56gb 其中kernel源代码3.6gb\"></a>最终镜像大小4.56gb 其中kernel源代码3.6gb</h2><p><img src=\"http://gohoy.top/i/2023/08/11/s994bn-1.png\"></p>\n<h2 id=\"脚本以及配置文件\"><a href=\"#脚本以及配置文件\" class=\"headerlink\" title=\"脚本以及配置文件\"></a>脚本以及配置文件</h2><pre><code class=\"pod.yaml\">apiVersion: v1\nkind: Pod\nmetadata:\n  name: container\n  labels:\n    stl: container\nspec:\n  containers:\n    - name: container\n      command:\n        - &quot;/bin/bash&quot;\n        - &quot;-ce&quot;\n        - &quot;tail -f /dev/null&quot;\n      lifecycle:\n        postStart:\n          exec:\n            command: [&quot;/usr/sbin/sshd&quot;] #启动container运行sshd\n      resources:\n        limits:\n          memory: 1G\n          cpu: 1\n      image: openeuler/container:v2\n</code></pre>\n<pre><code class=\"shell\">  for (( i=1; i &lt;= $1 ; i++ ))\n  do\n    container=($(kubectl get pods | sed -n &#39;2,$p&#39;| gawk &#39;&#123;print $1&#125;&#39;))\n     if echo &quot;$&#123;container[@]&#125;&quot; | grep -wq &quot;container-$i&quot;\n     then\n       continue\n     else\n       ((ssh=30000+$i))\n       sed -e &quot;4s/service/service-$i/; 10s/30000/$ssh/; 13s/container/container-$i/&quot; /home/gohoy/docker-img/service.yaml &gt; /home/gohoy/docker-img/tmpservice.yaml #service\n       kubectl create -f  /home/gohoy/docker-img/tmpservice.yaml\n       sed -e &quot;4s/container/container-$i/; 6s/container/container-$i/; 9s/container/container-$i/&quot;  /home/gohoy/docker-img/pod.yaml &gt;  /home/gohoy/docker-img/tmppod.yaml # \n       kubectl apply -f  /home/gohoy/docker-img/tmppod.yaml\n\n     fi\n  done\n</code></pre>\n"},{"title":"未闻花名吉他谱","_content":"\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-43-24-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-43-57-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-20-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-33-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-44-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-55-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-11-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-29-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-45-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-57-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-46-30-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-46-42-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-46-52-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-09-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-19-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-33-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-45-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-54-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-04-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-10-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-20-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-33-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-43-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-54-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-01-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-09-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-29-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-39-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-53-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-50-03-image.png)\n\n\n\n3![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-50-17-image.png)\n","source":"_posts/未闻花名.md","raw":"---\ntitle: 未闻花名吉他谱\ncategory: 吉他谱\ntag: \n - 吉他谱\n---\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-43-24-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-43-57-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-20-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-33-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-44-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-55-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-11-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-29-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-45-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-57-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-46-30-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-46-42-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-46-52-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-09-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-19-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-33-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-45-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-54-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-04-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-10-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-20-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-33-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-43-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-54-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-01-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-09-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-29-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-39-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-53-image.png)\n\n![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-50-03-image.png)\n\n\n\n3![](C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-50-17-image.png)\n","slug":"未闻花名","published":1,"date":"2023-08-30T06:28:51.582Z","updated":"2023-08-30T06:45:55.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllyxpksm000n14gffsszba8h","content":"<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-43-24-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-43-57-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-20-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-33-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-44-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-55-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-11-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-29-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-45-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-57-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-46-30-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-46-42-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-46-52-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-09-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-19-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-33-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-45-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-54-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-04-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-10-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-20-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-33-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-43-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-54-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-01-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-09-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-29-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-39-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-53-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-50-03-image.png\"></p>\n<p>3<img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-50-17-image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-43-24-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-43-57-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-20-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-33-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-44-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-44-55-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-11-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-29-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-45-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-45-57-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-46-30-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-46-42-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-46-52-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-09-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-19-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-33-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-45-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-47-54-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-04-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-10-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-20-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-33-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-43-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-48-54-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-01-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-09-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-29-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-39-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-49-53-image.png\"></p>\n<p><img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-50-03-image.png\"></p>\n<p>3<img src=\"C:\\Users\\34822\\AppData\\Roaming\\marktext\\images\\2023-02-07-13-50-17-image.png\"></p>\n"},{"title":"游戏掷筛","_content":"\n## 游戏机制中的概率论\n\n### 摘要\n\n- **前言**\n\n- **dota2中暴击率的伪随机性**\n  \n  - 自己手测5组数据\n  \n  - dota2官方wiki中对伪随机性（PRD）的定义\n  \n  - 分析c值的计算\n\n- **游戏中NdS掷骰机制**\n  \n  - 通过掷骰调整事件发生概率更平稳或者更极端\n  \n  - 通过掷骰调整事件放生概率偏向均值较大或较小的一侧。有三个相关模型\n\n- **总结**\n\n### 前言\n\n在互联网上，充斥着各种抽奖活动：拼多多的一分钱抽奖，微信抽奖，游戏抽奖等等。但是我们能感受到的是：游戏中中奖的概率似乎要高于微信或者拼多多等抽奖的概率。（因为我从未在游戏以外活动中抽到过奖励）。也考虑到游戏如果也和生活中的抽奖那样抽奖都是独立事件，那么运气影响的部分过高，竞技性就会降低，难以留住像我这样的“非酋玩家”。所以游戏中的概率一定不是真随机。\n\n下面就是我通过搜索资料了解到的一些游戏中的概率模型机制。   \n\n#### dota2中暴击率的伪随机性\n\n                                 表1 在裸出一个水晶剑（30暴击率）情况下的20次暴击图表\n\n<img title=\"\" src=\"https://gohoy.top/i/2023/09/04/vn14tu-1.png\" alt=\"\" width=\"825\">\n\n暴击率的平均值为0.28与30较为接近。\n\n因为自己手测能得到的样本数很少，随机性大。\n\n所以使用dota2wiki[随机分布 - Dota 2 Wiki，刀塔百科 (fandom.com)](https://dota2.fandom.com/zh/wiki/%E9%9A%8F%E6%9C%BA%E5%88%86%E5%B8%83?variant=zh#%E5%AE%9A%E4%B9%89)中机制的公式进行代码分析。\n\n这是dota2官方wiki中对**伪随机分布**(pseudo-random distribution，简称PRD)的定义\n\n![](https://gohoy.top/i/2023/09/04/vn1f1h-1.png)\n\n表1.1.1                     prd下直到下次暴击的攻击次数\n\n![](https://static.wikia.nocookie.net/dota2_gamepedia/images/8/8b/AttacksUntilNextProc25.jpg/revision/latest?cb=20130505045408)\n\n表1.1.2                    prd下的触发几率\n\n![](https://static.wikia.nocookie.net/dota2_gamepedia/images/4/48/PRD_proc_chance.png/revision/latest/scale-to-width-down/1000?cb=20171112125404)\n\ndota2官网中给出的C值\n\n<img src=\"https://gohoy.top/i/2023/09/04/vn1pld-1.png\" title=\"\" alt=\"\" width=\"409\">\n\n从[Calculating the constant C in Dota 2 pseudo-random distribution - Arqade (stackexchange.com)](https://gaming.stackexchange.com/questions/161430/calculating-the-constant-c-in-dota-2-pseudo-random-distribution)\n\n我们了解到这种伪随机暴击率是以马尔科夫链为理论进行的。![](https://gohoy.top/i/2023/09/04/vn20mh-1.png)\n\n即下一次普通攻击是否暴击仅和这一次是否暴击相关。\n\n例如暴击率为20%，第一次是1*C即5.6%，第二次为11.2%,如此累加，在第五次达到28%，第十次达到56%。当暴击时，暴击率再次从5.6%开始。也就是说更少出现真随机那样连续暴击或者连续不暴击的情况，减少运气成分，使游戏更加公平。\n\n同时，计算C值的c#代码如下\n\n```csharp\n//CfromP是主函数，传入理论概率P就可以求得递增的C值\npublic decimal CfromP( decimal p )\n{\n    decimal Cupper = p;\n    decimal Clower = 0m;\n    decimal Cmid;\n    decimal p1;\n    decimal p2 = 1m;\n    while(true)\n    {\n        Cmid = ( Cupper + Clower ) / 2m;\n        p1 = PfromC( Cmid );\n        if ( Math.Abs( p1 - p2 ) <= 0m ) break;\n\n        if ( p1 > p )\n        {\n            Cupper = Cmid;\n        }\n        else\n        {\n            Clower = Cmid;\n        }\n\n        p2 = p1;\n    }\n\n    return Cmid;\n}\n\nprivate decimal PfromC( decimal C )\n{\n    decimal pProcOnN = 0m;\n    decimal pProcByN = 0m;\n    decimal sumNpProcOnN = 0m;\n\n    int maxFails = (int)Math.Ceiling( 1m / C );\n    for (int N = 1; N <= maxFails; ++N)\n    {\n        pProcOnN = Math.Min( 1m, N * C ) * (1m - pProcByN);\n        pProcByN += pProcOnN;\n        sumNpProcOnN += N * pProcOnN;\n    }\n\n    return ( 1m / sumNpProcOnN );\n}\n```\n\n结果和dota2官方数据一致：\n\n```\nC(0.05) = 0.003801658303553139101756466\nC(0.10) = 0.014745844781072675877050816\nC(0.15) = 0.032220914373087674975117359\nC(0.20) = 0.055704042949781851858398652\nC(0.25) = 0.084744091852316990275274806\nC(0.30) = 0.118949192725403987583755553\nC(0.35) = 0.157983098125747077557540462\nC(0.40) = 0.201547413607754017070679639\nC(0.45) = 0.249306998440163189714677100\nC(0.50) = 0.302103025348741965169160432\nC(0.55) = 0.360397850933168697104686803\nC(0.60) = 0.422649730810374235490851220\nC(0.65) = 0.481125478337229174401911323\nC(0.70) = 0.571428571428571428571428572\nC(0.75) = 0.666666666666666666666666667\nC(0.80) = 0.750000000000000000000000000\nC(0.85) = 0.823529411764705882352941177\nC(0.90) = 0.888888888888888888888888889\nC(0.95) = 0.947368421052631578947368421`\n```\n\n> 假设一名英雄有15%的暴击率，连续N次不暴击，之后首次触发暴击所需普攻数[dota2中关于暴击/眩晕伪随机概率的玄学及其应用 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/509091713)\n\n![](https://pic4.zhimg.com/80/v2-9174147704e0534daf14018ddfce9317_1440w.webp)\n\n```text\n之前连续0次未触发,之后平均需要5.6996次攻击才能触发暴击/眩晕\n之前连续1次未触发,之后平均需要4.8261次攻击才能触发暴击/眩晕\n之前连续2次未触发,之后平均需要4.1568次攻击才能触发暴击/眩晕\n之前连续3次未触发,之后平均需要3.6702次攻击才能触发暴击/眩晕\n之前连续4次未触发,之后平均需要3.21次攻击才能触发暴击/眩晕\n之前连续5次未触发,之后平均需要2.8265次攻击才能触发暴击/眩晕\n之前连续6次未触发,之后平均需要2.4924次攻击才能触发暴击/眩晕\n之前连续7次未触发,之后平均需要2.1826次攻击才能触发暴击/眩晕\n```\n\n#### [游戏中NdS掷骰机制](http://www.redblobgames.com/articles/probability/damage-rolls.html)\n\n![](https://gohoy.top/i/2023/09/04/vn2dmq-1.png)\n\n**NdS**表示投掷S面的骰子N次，累加结果。比如1d12表示投掷一个12面骰子一次，3d4表示投掷一个4面骰子3次。\n\n**机制1**：可以通过此机制使概率出现更平稳（2d12）或者更看运气（12d2）来满足不同需要。\n\n![](https://gohoy.top/i/2023/09/04/vn2k35-1.png)\n\n从下面几个分布直方图中我们能看到取同样的随机数（0到24）可以分成2d12 3d8等很多种，掷骰次数越多得到的直方图越集中在12处。\n\n如：4d6的武器比3d8的武器输出更平稳，但3d8的武器造成高伤害的几率也更高。\n\n<img src=\"https://gohoy.top/i/2023/09/04/vn2tr3-1.png\" title=\"\" alt=\"\" data-align=\"right\">\n\n![](https://gohoy.top/i/2023/09/04/vn33qq-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vn3api-1.png)![](https://gohoy.top/i/2023/09/04/vn3hqm-1.png)![](https://gohoy.top/i/2023/09/04/vn3mo9-1.png)![](https://gohoy.top/i/2023/09/04/vn3xrs-1.png)\n\n**机制2：** 使概率分布不对称，得到更多偏小或偏大的值\n\n* 取两次掷骰中较大或较小的值\n\n![](https://gohoy.top/i/2023/09/04/vn43g9-1.png)\n\n图2.1.1                                                               2d12偏大\n\n![](https://gohoy.top/i/2023/09/04/vn4eht-1.png)\n\n图2.1.2                                                        2d12偏小\n\n![](https://gohoy.top/i/2023/09/04/vn4icd-1.png)\n\n* 取三次掷骰中较大或较小的两次结果之和\n\n![](https://gohoy.top/i/2023/09/04/vn4z4w-1.png)\n\n图2.2.1                                                         1d12\n\n![](https://gohoy.top/i/2023/09/04/vn5agp-1.png)\n\n图2.2.2                                                    2d12\n\n![](https://gohoy.top/i/2023/09/04/vn5fqh-1.png)\n\n偏移更细微些\n\n* 另一种是将三次掷骰中最小（大）的结果重新投掷\n\n![](https://gohoy.top/i/2023/09/04/vn5n9h-1.png)\n\n图3.1.1                                                           1d12偏大\n\n![](https://gohoy.top/i/2023/09/04/vn5sr5-1.png)\n\n### 总结\n\n以上的概率模型可以用在很多场景：比如随机奖励，抽卡机制，暴击机制等。\n\n游戏一般都会对玩家的抽奖概率做保护机制，因此出现了“大保底””小保底“之类的名词。通过给玩家一个目标来激励玩家的抽奖消费策略。\n\n同时也警示我们，不要轻信网络上的抽奖活动或者中奖信息，防止被骗。\n\n另外：计算机在软件层面只能产生假随机。只有在硬件层面，通过量子力学或者噪声等方法才可能实现真正的真随机。\n","source":"_posts/游戏机制中的概率论.md","raw":"---\ntitle: 游戏掷筛\ncategory: 理论\ntag: \n - 概率论\n - 掷筛\n - NdS\n---\n\n## 游戏机制中的概率论\n\n### 摘要\n\n- **前言**\n\n- **dota2中暴击率的伪随机性**\n  \n  - 自己手测5组数据\n  \n  - dota2官方wiki中对伪随机性（PRD）的定义\n  \n  - 分析c值的计算\n\n- **游戏中NdS掷骰机制**\n  \n  - 通过掷骰调整事件发生概率更平稳或者更极端\n  \n  - 通过掷骰调整事件放生概率偏向均值较大或较小的一侧。有三个相关模型\n\n- **总结**\n\n### 前言\n\n在互联网上，充斥着各种抽奖活动：拼多多的一分钱抽奖，微信抽奖，游戏抽奖等等。但是我们能感受到的是：游戏中中奖的概率似乎要高于微信或者拼多多等抽奖的概率。（因为我从未在游戏以外活动中抽到过奖励）。也考虑到游戏如果也和生活中的抽奖那样抽奖都是独立事件，那么运气影响的部分过高，竞技性就会降低，难以留住像我这样的“非酋玩家”。所以游戏中的概率一定不是真随机。\n\n下面就是我通过搜索资料了解到的一些游戏中的概率模型机制。   \n\n#### dota2中暴击率的伪随机性\n\n                                 表1 在裸出一个水晶剑（30暴击率）情况下的20次暴击图表\n\n<img title=\"\" src=\"https://gohoy.top/i/2023/09/04/vn14tu-1.png\" alt=\"\" width=\"825\">\n\n暴击率的平均值为0.28与30较为接近。\n\n因为自己手测能得到的样本数很少，随机性大。\n\n所以使用dota2wiki[随机分布 - Dota 2 Wiki，刀塔百科 (fandom.com)](https://dota2.fandom.com/zh/wiki/%E9%9A%8F%E6%9C%BA%E5%88%86%E5%B8%83?variant=zh#%E5%AE%9A%E4%B9%89)中机制的公式进行代码分析。\n\n这是dota2官方wiki中对**伪随机分布**(pseudo-random distribution，简称PRD)的定义\n\n![](https://gohoy.top/i/2023/09/04/vn1f1h-1.png)\n\n表1.1.1                     prd下直到下次暴击的攻击次数\n\n![](https://static.wikia.nocookie.net/dota2_gamepedia/images/8/8b/AttacksUntilNextProc25.jpg/revision/latest?cb=20130505045408)\n\n表1.1.2                    prd下的触发几率\n\n![](https://static.wikia.nocookie.net/dota2_gamepedia/images/4/48/PRD_proc_chance.png/revision/latest/scale-to-width-down/1000?cb=20171112125404)\n\ndota2官网中给出的C值\n\n<img src=\"https://gohoy.top/i/2023/09/04/vn1pld-1.png\" title=\"\" alt=\"\" width=\"409\">\n\n从[Calculating the constant C in Dota 2 pseudo-random distribution - Arqade (stackexchange.com)](https://gaming.stackexchange.com/questions/161430/calculating-the-constant-c-in-dota-2-pseudo-random-distribution)\n\n我们了解到这种伪随机暴击率是以马尔科夫链为理论进行的。![](https://gohoy.top/i/2023/09/04/vn20mh-1.png)\n\n即下一次普通攻击是否暴击仅和这一次是否暴击相关。\n\n例如暴击率为20%，第一次是1*C即5.6%，第二次为11.2%,如此累加，在第五次达到28%，第十次达到56%。当暴击时，暴击率再次从5.6%开始。也就是说更少出现真随机那样连续暴击或者连续不暴击的情况，减少运气成分，使游戏更加公平。\n\n同时，计算C值的c#代码如下\n\n```csharp\n//CfromP是主函数，传入理论概率P就可以求得递增的C值\npublic decimal CfromP( decimal p )\n{\n    decimal Cupper = p;\n    decimal Clower = 0m;\n    decimal Cmid;\n    decimal p1;\n    decimal p2 = 1m;\n    while(true)\n    {\n        Cmid = ( Cupper + Clower ) / 2m;\n        p1 = PfromC( Cmid );\n        if ( Math.Abs( p1 - p2 ) <= 0m ) break;\n\n        if ( p1 > p )\n        {\n            Cupper = Cmid;\n        }\n        else\n        {\n            Clower = Cmid;\n        }\n\n        p2 = p1;\n    }\n\n    return Cmid;\n}\n\nprivate decimal PfromC( decimal C )\n{\n    decimal pProcOnN = 0m;\n    decimal pProcByN = 0m;\n    decimal sumNpProcOnN = 0m;\n\n    int maxFails = (int)Math.Ceiling( 1m / C );\n    for (int N = 1; N <= maxFails; ++N)\n    {\n        pProcOnN = Math.Min( 1m, N * C ) * (1m - pProcByN);\n        pProcByN += pProcOnN;\n        sumNpProcOnN += N * pProcOnN;\n    }\n\n    return ( 1m / sumNpProcOnN );\n}\n```\n\n结果和dota2官方数据一致：\n\n```\nC(0.05) = 0.003801658303553139101756466\nC(0.10) = 0.014745844781072675877050816\nC(0.15) = 0.032220914373087674975117359\nC(0.20) = 0.055704042949781851858398652\nC(0.25) = 0.084744091852316990275274806\nC(0.30) = 0.118949192725403987583755553\nC(0.35) = 0.157983098125747077557540462\nC(0.40) = 0.201547413607754017070679639\nC(0.45) = 0.249306998440163189714677100\nC(0.50) = 0.302103025348741965169160432\nC(0.55) = 0.360397850933168697104686803\nC(0.60) = 0.422649730810374235490851220\nC(0.65) = 0.481125478337229174401911323\nC(0.70) = 0.571428571428571428571428572\nC(0.75) = 0.666666666666666666666666667\nC(0.80) = 0.750000000000000000000000000\nC(0.85) = 0.823529411764705882352941177\nC(0.90) = 0.888888888888888888888888889\nC(0.95) = 0.947368421052631578947368421`\n```\n\n> 假设一名英雄有15%的暴击率，连续N次不暴击，之后首次触发暴击所需普攻数[dota2中关于暴击/眩晕伪随机概率的玄学及其应用 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/509091713)\n\n![](https://pic4.zhimg.com/80/v2-9174147704e0534daf14018ddfce9317_1440w.webp)\n\n```text\n之前连续0次未触发,之后平均需要5.6996次攻击才能触发暴击/眩晕\n之前连续1次未触发,之后平均需要4.8261次攻击才能触发暴击/眩晕\n之前连续2次未触发,之后平均需要4.1568次攻击才能触发暴击/眩晕\n之前连续3次未触发,之后平均需要3.6702次攻击才能触发暴击/眩晕\n之前连续4次未触发,之后平均需要3.21次攻击才能触发暴击/眩晕\n之前连续5次未触发,之后平均需要2.8265次攻击才能触发暴击/眩晕\n之前连续6次未触发,之后平均需要2.4924次攻击才能触发暴击/眩晕\n之前连续7次未触发,之后平均需要2.1826次攻击才能触发暴击/眩晕\n```\n\n#### [游戏中NdS掷骰机制](http://www.redblobgames.com/articles/probability/damage-rolls.html)\n\n![](https://gohoy.top/i/2023/09/04/vn2dmq-1.png)\n\n**NdS**表示投掷S面的骰子N次，累加结果。比如1d12表示投掷一个12面骰子一次，3d4表示投掷一个4面骰子3次。\n\n**机制1**：可以通过此机制使概率出现更平稳（2d12）或者更看运气（12d2）来满足不同需要。\n\n![](https://gohoy.top/i/2023/09/04/vn2k35-1.png)\n\n从下面几个分布直方图中我们能看到取同样的随机数（0到24）可以分成2d12 3d8等很多种，掷骰次数越多得到的直方图越集中在12处。\n\n如：4d6的武器比3d8的武器输出更平稳，但3d8的武器造成高伤害的几率也更高。\n\n<img src=\"https://gohoy.top/i/2023/09/04/vn2tr3-1.png\" title=\"\" alt=\"\" data-align=\"right\">\n\n![](https://gohoy.top/i/2023/09/04/vn33qq-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vn3api-1.png)![](https://gohoy.top/i/2023/09/04/vn3hqm-1.png)![](https://gohoy.top/i/2023/09/04/vn3mo9-1.png)![](https://gohoy.top/i/2023/09/04/vn3xrs-1.png)\n\n**机制2：** 使概率分布不对称，得到更多偏小或偏大的值\n\n* 取两次掷骰中较大或较小的值\n\n![](https://gohoy.top/i/2023/09/04/vn43g9-1.png)\n\n图2.1.1                                                               2d12偏大\n\n![](https://gohoy.top/i/2023/09/04/vn4eht-1.png)\n\n图2.1.2                                                        2d12偏小\n\n![](https://gohoy.top/i/2023/09/04/vn4icd-1.png)\n\n* 取三次掷骰中较大或较小的两次结果之和\n\n![](https://gohoy.top/i/2023/09/04/vn4z4w-1.png)\n\n图2.2.1                                                         1d12\n\n![](https://gohoy.top/i/2023/09/04/vn5agp-1.png)\n\n图2.2.2                                                    2d12\n\n![](https://gohoy.top/i/2023/09/04/vn5fqh-1.png)\n\n偏移更细微些\n\n* 另一种是将三次掷骰中最小（大）的结果重新投掷\n\n![](https://gohoy.top/i/2023/09/04/vn5n9h-1.png)\n\n图3.1.1                                                           1d12偏大\n\n![](https://gohoy.top/i/2023/09/04/vn5sr5-1.png)\n\n### 总结\n\n以上的概率模型可以用在很多场景：比如随机奖励，抽卡机制，暴击机制等。\n\n游戏一般都会对玩家的抽奖概率做保护机制，因此出现了“大保底””小保底“之类的名词。通过给玩家一个目标来激励玩家的抽奖消费策略。\n\n同时也警示我们，不要轻信网络上的抽奖活动或者中奖信息，防止被骗。\n\n另外：计算机在软件层面只能产生假随机。只有在硬件层面，通过量子力学或者噪声等方法才可能实现真正的真随机。\n","slug":"游戏机制中的概率论","published":1,"date":"2023-08-30T06:28:51.586Z","updated":"2023-09-11T13:27:57.238Z","_id":"cllyxpkso000s14gfczrlcs18","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"游戏机制中的概率论\"><a href=\"#游戏机制中的概率论\" class=\"headerlink\" title=\"游戏机制中的概率论\"></a>游戏机制中的概率论</h2><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><ul>\n<li><p><strong>前言</strong></p>\n</li>\n<li><p><strong>dota2中暴击率的伪随机性</strong></p>\n<ul>\n<li><p>自己手测5组数据</p>\n</li>\n<li><p>dota2官方wiki中对伪随机性（PRD）的定义</p>\n</li>\n<li><p>分析c值的计算</p>\n</li>\n</ul>\n</li>\n<li><p><strong>游戏中NdS掷骰机制</strong></p>\n<ul>\n<li><p>通过掷骰调整事件发生概率更平稳或者更极端</p>\n</li>\n<li><p>通过掷骰调整事件放生概率偏向均值较大或较小的一侧。有三个相关模型</p>\n</li>\n</ul>\n</li>\n<li><p><strong>总结</strong></p>\n</li>\n</ul>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在互联网上，充斥着各种抽奖活动：拼多多的一分钱抽奖，微信抽奖，游戏抽奖等等。但是我们能感受到的是：游戏中中奖的概率似乎要高于微信或者拼多多等抽奖的概率。（因为我从未在游戏以外活动中抽到过奖励）。也考虑到游戏如果也和生活中的抽奖那样抽奖都是独立事件，那么运气影响的部分过高，竞技性就会降低，难以留住像我这样的“非酋玩家”。所以游戏中的概率一定不是真随机。</p>\n<p>下面就是我通过搜索资料了解到的一些游戏中的概率模型机制。   </p>\n<h4 id=\"dota2中暴击率的伪随机性\"><a href=\"#dota2中暴击率的伪随机性\" class=\"headerlink\" title=\"dota2中暴击率的伪随机性\"></a>dota2中暴击率的伪随机性</h4><p>                                 表1 在裸出一个水晶剑（30暴击率）情况下的20次暴击图表</p>\n<img title=\"\" src=\"https://gohoy.top/i/2023/09/04/vn14tu-1.png\" alt=\"\" width=\"825\">\n\n<p>暴击率的平均值为0.28与30较为接近。</p>\n<p>因为自己手测能得到的样本数很少，随机性大。</p>\n<p>所以使用dota2wiki<a href=\"https://dota2.fandom.com/zh/wiki/%E9%9A%8F%E6%9C%BA%E5%88%86%E5%B8%83?variant=zh#%E5%AE%9A%E4%B9%89\">随机分布 - Dota 2 Wiki，刀塔百科 (fandom.com)</a>中机制的公式进行代码分析。</p>\n<p>这是dota2官方wiki中对<strong>伪随机分布</strong>(pseudo-random distribution，简称PRD)的定义</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn1f1h-1.png\"></p>\n<p>表1.1.1                     prd下直到下次暴击的攻击次数</p>\n<p><img src=\"https://static.wikia.nocookie.net/dota2_gamepedia/images/8/8b/AttacksUntilNextProc25.jpg/revision/latest?cb=20130505045408\"></p>\n<p>表1.1.2                    prd下的触发几率</p>\n<p><img src=\"https://static.wikia.nocookie.net/dota2_gamepedia/images/4/48/PRD_proc_chance.png/revision/latest/scale-to-width-down/1000?cb=20171112125404\"></p>\n<p>dota2官网中给出的C值</p>\n<img src=\"https://gohoy.top/i/2023/09/04/vn1pld-1.png\" title=\"\" alt=\"\" width=\"409\">\n\n<p>从<a href=\"https://gaming.stackexchange.com/questions/161430/calculating-the-constant-c-in-dota-2-pseudo-random-distribution\">Calculating the constant C in Dota 2 pseudo-random distribution - Arqade (stackexchange.com)</a></p>\n<p>我们了解到这种伪随机暴击率是以马尔科夫链为理论进行的。<img src=\"https://gohoy.top/i/2023/09/04/vn20mh-1.png\"></p>\n<p>即下一次普通攻击是否暴击仅和这一次是否暴击相关。</p>\n<p>例如暴击率为20%，第一次是1*C即5.6%，第二次为11.2%,如此累加，在第五次达到28%，第十次达到56%。当暴击时，暴击率再次从5.6%开始。也就是说更少出现真随机那样连续暴击或者连续不暴击的情况，减少运气成分，使游戏更加公平。</p>\n<p>同时，计算C值的c#代码如下</p>\n<pre><code class=\"csharp\">//CfromP是主函数，传入理论概率P就可以求得递增的C值\npublic decimal CfromP( decimal p )\n&#123;\n    decimal Cupper = p;\n    decimal Clower = 0m;\n    decimal Cmid;\n    decimal p1;\n    decimal p2 = 1m;\n    while(true)\n    &#123;\n        Cmid = ( Cupper + Clower ) / 2m;\n        p1 = PfromC( Cmid );\n        if ( Math.Abs( p1 - p2 ) &lt;= 0m ) break;\n\n        if ( p1 &gt; p )\n        &#123;\n            Cupper = Cmid;\n        &#125;\n        else\n        &#123;\n            Clower = Cmid;\n        &#125;\n\n        p2 = p1;\n    &#125;\n\n    return Cmid;\n&#125;\n\nprivate decimal PfromC( decimal C )\n&#123;\n    decimal pProcOnN = 0m;\n    decimal pProcByN = 0m;\n    decimal sumNpProcOnN = 0m;\n\n    int maxFails = (int)Math.Ceiling( 1m / C );\n    for (int N = 1; N &lt;= maxFails; ++N)\n    &#123;\n        pProcOnN = Math.Min( 1m, N * C ) * (1m - pProcByN);\n        pProcByN += pProcOnN;\n        sumNpProcOnN += N * pProcOnN;\n    &#125;\n\n    return ( 1m / sumNpProcOnN );\n&#125;\n</code></pre>\n<p>结果和dota2官方数据一致：</p>\n<pre><code>C(0.05) = 0.003801658303553139101756466\nC(0.10) = 0.014745844781072675877050816\nC(0.15) = 0.032220914373087674975117359\nC(0.20) = 0.055704042949781851858398652\nC(0.25) = 0.084744091852316990275274806\nC(0.30) = 0.118949192725403987583755553\nC(0.35) = 0.157983098125747077557540462\nC(0.40) = 0.201547413607754017070679639\nC(0.45) = 0.249306998440163189714677100\nC(0.50) = 0.302103025348741965169160432\nC(0.55) = 0.360397850933168697104686803\nC(0.60) = 0.422649730810374235490851220\nC(0.65) = 0.481125478337229174401911323\nC(0.70) = 0.571428571428571428571428572\nC(0.75) = 0.666666666666666666666666667\nC(0.80) = 0.750000000000000000000000000\nC(0.85) = 0.823529411764705882352941177\nC(0.90) = 0.888888888888888888888888889\nC(0.95) = 0.947368421052631578947368421`\n</code></pre>\n<blockquote>\n<p>假设一名英雄有15%的暴击率，连续N次不暴击，之后首次触发暴击所需普攻数<a href=\"https://zhuanlan.zhihu.com/p/509091713\">dota2中关于暴击&#x2F;眩晕伪随机概率的玄学及其应用 - 知乎 (zhihu.com)</a></p>\n</blockquote>\n<p><img src=\"https://pic4.zhimg.com/80/v2-9174147704e0534daf14018ddfce9317_1440w.webp\"></p>\n<pre><code class=\"text\">之前连续0次未触发,之后平均需要5.6996次攻击才能触发暴击/眩晕\n之前连续1次未触发,之后平均需要4.8261次攻击才能触发暴击/眩晕\n之前连续2次未触发,之后平均需要4.1568次攻击才能触发暴击/眩晕\n之前连续3次未触发,之后平均需要3.6702次攻击才能触发暴击/眩晕\n之前连续4次未触发,之后平均需要3.21次攻击才能触发暴击/眩晕\n之前连续5次未触发,之后平均需要2.8265次攻击才能触发暴击/眩晕\n之前连续6次未触发,之后平均需要2.4924次攻击才能触发暴击/眩晕\n之前连续7次未触发,之后平均需要2.1826次攻击才能触发暴击/眩晕\n</code></pre>\n<h4 id=\"游戏中NdS掷骰机制\"><a href=\"#游戏中NdS掷骰机制\" class=\"headerlink\" title=\"游戏中NdS掷骰机制\"></a><a href=\"http://www.redblobgames.com/articles/probability/damage-rolls.html\">游戏中NdS掷骰机制</a></h4><p><img src=\"https://gohoy.top/i/2023/09/04/vn2dmq-1.png\"></p>\n<p><strong>NdS</strong>表示投掷S面的骰子N次，累加结果。比如1d12表示投掷一个12面骰子一次，3d4表示投掷一个4面骰子3次。</p>\n<p><strong>机制1</strong>：可以通过此机制使概率出现更平稳（2d12）或者更看运气（12d2）来满足不同需要。</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn2k35-1.png\"></p>\n<p>从下面几个分布直方图中我们能看到取同样的随机数（0到24）可以分成2d12 3d8等很多种，掷骰次数越多得到的直方图越集中在12处。</p>\n<p>如：4d6的武器比3d8的武器输出更平稳，但3d8的武器造成高伤害的几率也更高。</p>\n<img src=\"https://gohoy.top/i/2023/09/04/vn2tr3-1.png\" title=\"\" alt=\"\" data-align=\"right\">\n\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn33qq-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn3api-1.png\"><img src=\"https://gohoy.top/i/2023/09/04/vn3hqm-1.png\"><img src=\"https://gohoy.top/i/2023/09/04/vn3mo9-1.png\"><img src=\"https://gohoy.top/i/2023/09/04/vn3xrs-1.png\"></p>\n<p><strong>机制2：</strong> 使概率分布不对称，得到更多偏小或偏大的值</p>\n<ul>\n<li>取两次掷骰中较大或较小的值</li>\n</ul>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn43g9-1.png\"></p>\n<p>图2.1.1                                                               2d12偏大</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn4eht-1.png\"></p>\n<p>图2.1.2                                                        2d12偏小</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn4icd-1.png\"></p>\n<ul>\n<li>取三次掷骰中较大或较小的两次结果之和</li>\n</ul>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn4z4w-1.png\"></p>\n<p>图2.2.1                                                         1d12</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn5agp-1.png\"></p>\n<p>图2.2.2                                                    2d12</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn5fqh-1.png\"></p>\n<p>偏移更细微些</p>\n<ul>\n<li>另一种是将三次掷骰中最小（大）的结果重新投掷</li>\n</ul>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn5n9h-1.png\"></p>\n<p>图3.1.1                                                           1d12偏大</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn5sr5-1.png\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上的概率模型可以用在很多场景：比如随机奖励，抽卡机制，暴击机制等。</p>\n<p>游戏一般都会对玩家的抽奖概率做保护机制，因此出现了“大保底””小保底“之类的名词。通过给玩家一个目标来激励玩家的抽奖消费策略。</p>\n<p>同时也警示我们，不要轻信网络上的抽奖活动或者中奖信息，防止被骗。</p>\n<p>另外：计算机在软件层面只能产生假随机。只有在硬件层面，通过量子力学或者噪声等方法才可能实现真正的真随机。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"游戏机制中的概率论\"><a href=\"#游戏机制中的概率论\" class=\"headerlink\" title=\"游戏机制中的概率论\"></a>游戏机制中的概率论</h2><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><ul>\n<li><p><strong>前言</strong></p>\n</li>\n<li><p><strong>dota2中暴击率的伪随机性</strong></p>\n<ul>\n<li><p>自己手测5组数据</p>\n</li>\n<li><p>dota2官方wiki中对伪随机性（PRD）的定义</p>\n</li>\n<li><p>分析c值的计算</p>\n</li>\n</ul>\n</li>\n<li><p><strong>游戏中NdS掷骰机制</strong></p>\n<ul>\n<li><p>通过掷骰调整事件发生概率更平稳或者更极端</p>\n</li>\n<li><p>通过掷骰调整事件放生概率偏向均值较大或较小的一侧。有三个相关模型</p>\n</li>\n</ul>\n</li>\n<li><p><strong>总结</strong></p>\n</li>\n</ul>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在互联网上，充斥着各种抽奖活动：拼多多的一分钱抽奖，微信抽奖，游戏抽奖等等。但是我们能感受到的是：游戏中中奖的概率似乎要高于微信或者拼多多等抽奖的概率。（因为我从未在游戏以外活动中抽到过奖励）。也考虑到游戏如果也和生活中的抽奖那样抽奖都是独立事件，那么运气影响的部分过高，竞技性就会降低，难以留住像我这样的“非酋玩家”。所以游戏中的概率一定不是真随机。</p>\n<p>下面就是我通过搜索资料了解到的一些游戏中的概率模型机制。   </p>\n<h4 id=\"dota2中暴击率的伪随机性\"><a href=\"#dota2中暴击率的伪随机性\" class=\"headerlink\" title=\"dota2中暴击率的伪随机性\"></a>dota2中暴击率的伪随机性</h4><p>                                 表1 在裸出一个水晶剑（30暴击率）情况下的20次暴击图表</p>\n<img title=\"\" src=\"https://gohoy.top/i/2023/09/04/vn14tu-1.png\" alt=\"\" width=\"825\">\n\n<p>暴击率的平均值为0.28与30较为接近。</p>\n<p>因为自己手测能得到的样本数很少，随机性大。</p>\n<p>所以使用dota2wiki<a href=\"https://dota2.fandom.com/zh/wiki/%E9%9A%8F%E6%9C%BA%E5%88%86%E5%B8%83?variant=zh#%E5%AE%9A%E4%B9%89\">随机分布 - Dota 2 Wiki，刀塔百科 (fandom.com)</a>中机制的公式进行代码分析。</p>\n<p>这是dota2官方wiki中对<strong>伪随机分布</strong>(pseudo-random distribution，简称PRD)的定义</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn1f1h-1.png\"></p>\n<p>表1.1.1                     prd下直到下次暴击的攻击次数</p>\n<p><img src=\"https://static.wikia.nocookie.net/dota2_gamepedia/images/8/8b/AttacksUntilNextProc25.jpg/revision/latest?cb=20130505045408\"></p>\n<p>表1.1.2                    prd下的触发几率</p>\n<p><img src=\"https://static.wikia.nocookie.net/dota2_gamepedia/images/4/48/PRD_proc_chance.png/revision/latest/scale-to-width-down/1000?cb=20171112125404\"></p>\n<p>dota2官网中给出的C值</p>\n<img src=\"https://gohoy.top/i/2023/09/04/vn1pld-1.png\" title=\"\" alt=\"\" width=\"409\">\n\n<p>从<a href=\"https://gaming.stackexchange.com/questions/161430/calculating-the-constant-c-in-dota-2-pseudo-random-distribution\">Calculating the constant C in Dota 2 pseudo-random distribution - Arqade (stackexchange.com)</a></p>\n<p>我们了解到这种伪随机暴击率是以马尔科夫链为理论进行的。<img src=\"https://gohoy.top/i/2023/09/04/vn20mh-1.png\"></p>\n<p>即下一次普通攻击是否暴击仅和这一次是否暴击相关。</p>\n<p>例如暴击率为20%，第一次是1*C即5.6%，第二次为11.2%,如此累加，在第五次达到28%，第十次达到56%。当暴击时，暴击率再次从5.6%开始。也就是说更少出现真随机那样连续暴击或者连续不暴击的情况，减少运气成分，使游戏更加公平。</p>\n<p>同时，计算C值的c#代码如下</p>\n<pre><code class=\"csharp\">//CfromP是主函数，传入理论概率P就可以求得递增的C值\npublic decimal CfromP( decimal p )\n&#123;\n    decimal Cupper = p;\n    decimal Clower = 0m;\n    decimal Cmid;\n    decimal p1;\n    decimal p2 = 1m;\n    while(true)\n    &#123;\n        Cmid = ( Cupper + Clower ) / 2m;\n        p1 = PfromC( Cmid );\n        if ( Math.Abs( p1 - p2 ) &lt;= 0m ) break;\n\n        if ( p1 &gt; p )\n        &#123;\n            Cupper = Cmid;\n        &#125;\n        else\n        &#123;\n            Clower = Cmid;\n        &#125;\n\n        p2 = p1;\n    &#125;\n\n    return Cmid;\n&#125;\n\nprivate decimal PfromC( decimal C )\n&#123;\n    decimal pProcOnN = 0m;\n    decimal pProcByN = 0m;\n    decimal sumNpProcOnN = 0m;\n\n    int maxFails = (int)Math.Ceiling( 1m / C );\n    for (int N = 1; N &lt;= maxFails; ++N)\n    &#123;\n        pProcOnN = Math.Min( 1m, N * C ) * (1m - pProcByN);\n        pProcByN += pProcOnN;\n        sumNpProcOnN += N * pProcOnN;\n    &#125;\n\n    return ( 1m / sumNpProcOnN );\n&#125;\n</code></pre>\n<p>结果和dota2官方数据一致：</p>\n<pre><code>C(0.05) = 0.003801658303553139101756466\nC(0.10) = 0.014745844781072675877050816\nC(0.15) = 0.032220914373087674975117359\nC(0.20) = 0.055704042949781851858398652\nC(0.25) = 0.084744091852316990275274806\nC(0.30) = 0.118949192725403987583755553\nC(0.35) = 0.157983098125747077557540462\nC(0.40) = 0.201547413607754017070679639\nC(0.45) = 0.249306998440163189714677100\nC(0.50) = 0.302103025348741965169160432\nC(0.55) = 0.360397850933168697104686803\nC(0.60) = 0.422649730810374235490851220\nC(0.65) = 0.481125478337229174401911323\nC(0.70) = 0.571428571428571428571428572\nC(0.75) = 0.666666666666666666666666667\nC(0.80) = 0.750000000000000000000000000\nC(0.85) = 0.823529411764705882352941177\nC(0.90) = 0.888888888888888888888888889\nC(0.95) = 0.947368421052631578947368421`\n</code></pre>\n<blockquote>\n<p>假设一名英雄有15%的暴击率，连续N次不暴击，之后首次触发暴击所需普攻数<a href=\"https://zhuanlan.zhihu.com/p/509091713\">dota2中关于暴击&#x2F;眩晕伪随机概率的玄学及其应用 - 知乎 (zhihu.com)</a></p>\n</blockquote>\n<p><img src=\"https://pic4.zhimg.com/80/v2-9174147704e0534daf14018ddfce9317_1440w.webp\"></p>\n<pre><code class=\"text\">之前连续0次未触发,之后平均需要5.6996次攻击才能触发暴击/眩晕\n之前连续1次未触发,之后平均需要4.8261次攻击才能触发暴击/眩晕\n之前连续2次未触发,之后平均需要4.1568次攻击才能触发暴击/眩晕\n之前连续3次未触发,之后平均需要3.6702次攻击才能触发暴击/眩晕\n之前连续4次未触发,之后平均需要3.21次攻击才能触发暴击/眩晕\n之前连续5次未触发,之后平均需要2.8265次攻击才能触发暴击/眩晕\n之前连续6次未触发,之后平均需要2.4924次攻击才能触发暴击/眩晕\n之前连续7次未触发,之后平均需要2.1826次攻击才能触发暴击/眩晕\n</code></pre>\n<h4 id=\"游戏中NdS掷骰机制\"><a href=\"#游戏中NdS掷骰机制\" class=\"headerlink\" title=\"游戏中NdS掷骰机制\"></a><a href=\"http://www.redblobgames.com/articles/probability/damage-rolls.html\">游戏中NdS掷骰机制</a></h4><p><img src=\"https://gohoy.top/i/2023/09/04/vn2dmq-1.png\"></p>\n<p><strong>NdS</strong>表示投掷S面的骰子N次，累加结果。比如1d12表示投掷一个12面骰子一次，3d4表示投掷一个4面骰子3次。</p>\n<p><strong>机制1</strong>：可以通过此机制使概率出现更平稳（2d12）或者更看运气（12d2）来满足不同需要。</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn2k35-1.png\"></p>\n<p>从下面几个分布直方图中我们能看到取同样的随机数（0到24）可以分成2d12 3d8等很多种，掷骰次数越多得到的直方图越集中在12处。</p>\n<p>如：4d6的武器比3d8的武器输出更平稳，但3d8的武器造成高伤害的几率也更高。</p>\n<img src=\"https://gohoy.top/i/2023/09/04/vn2tr3-1.png\" title=\"\" alt=\"\" data-align=\"right\">\n\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn33qq-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn3api-1.png\"><img src=\"https://gohoy.top/i/2023/09/04/vn3hqm-1.png\"><img src=\"https://gohoy.top/i/2023/09/04/vn3mo9-1.png\"><img src=\"https://gohoy.top/i/2023/09/04/vn3xrs-1.png\"></p>\n<p><strong>机制2：</strong> 使概率分布不对称，得到更多偏小或偏大的值</p>\n<ul>\n<li>取两次掷骰中较大或较小的值</li>\n</ul>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn43g9-1.png\"></p>\n<p>图2.1.1                                                               2d12偏大</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn4eht-1.png\"></p>\n<p>图2.1.2                                                        2d12偏小</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn4icd-1.png\"></p>\n<ul>\n<li>取三次掷骰中较大或较小的两次结果之和</li>\n</ul>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn4z4w-1.png\"></p>\n<p>图2.2.1                                                         1d12</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn5agp-1.png\"></p>\n<p>图2.2.2                                                    2d12</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn5fqh-1.png\"></p>\n<p>偏移更细微些</p>\n<ul>\n<li>另一种是将三次掷骰中最小（大）的结果重新投掷</li>\n</ul>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn5n9h-1.png\"></p>\n<p>图3.1.1                                                           1d12偏大</p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vn5sr5-1.png\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上的概率模型可以用在很多场景：比如随机奖励，抽卡机制，暴击机制等。</p>\n<p>游戏一般都会对玩家的抽奖概率做保护机制，因此出现了“大保底””小保底“之类的名词。通过给玩家一个目标来激励玩家的抽奖消费策略。</p>\n<p>同时也警示我们，不要轻信网络上的抽奖活动或者中奖信息，防止被骗。</p>\n<p>另外：计算机在软件层面只能产生假随机。只有在硬件层面，通过量子力学或者噪声等方法才可能实现真正的真随机。</p>\n"},{"title":"花海吉他谱","_content":"\n<img src=\"http://gohoy.top/i/2023/08/30/nu8ayl-1.png\" title=\"\" alt=\"\" width=\"1082\">\n\n![](http://gohoy.top/i/2023/08/11/sgwwmc-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgze26-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgzotk-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sh8mdv-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sh8ys6-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sh98rx-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sh9n7v-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sha8lv-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sharvk-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shb4us-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shbf15-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shbwf3-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shcfc7-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shcrz4-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shd14n-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shdyaf-1.png)\n\n![](http://gohoy.top/i/2023/08/11/she52r-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shein0-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shf1u6-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shf6hr-1.png)\n","source":"_posts/花海吉他谱.md","raw":"---\ntitle: 花海吉他谱\ncategory: 吉他谱\ntag: \n - 吉他谱\n---\n\n<img src=\"http://gohoy.top/i/2023/08/30/nu8ayl-1.png\" title=\"\" alt=\"\" width=\"1082\">\n\n![](http://gohoy.top/i/2023/08/11/sgwwmc-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgze26-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgzotk-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sh8mdv-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sh8ys6-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sh98rx-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sh9n7v-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sha8lv-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sharvk-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shb4us-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shbf15-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shbwf3-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shcfc7-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shcrz4-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shd14n-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shdyaf-1.png)\n\n![](http://gohoy.top/i/2023/08/11/she52r-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shein0-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shf1u6-1.png)\n\n![](http://gohoy.top/i/2023/08/11/shf6hr-1.png)\n","slug":"花海吉他谱","published":1,"date":"2023-08-30T06:28:51.572Z","updated":"2023-08-30T06:41:55.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllyxpksx002014gfelpo9vkn","content":"<img src=\"http://gohoy.top/i/2023/08/30/nu8ayl-1.png\" title=\"\" alt=\"\" width=\"1082\">\n\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgwwmc-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgze26-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgzotk-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sh8mdv-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sh8ys6-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sh98rx-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sh9n7v-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sha8lv-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sharvk-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shb4us-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shbf15-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shbwf3-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shcfc7-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shcrz4-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shd14n-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shdyaf-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/she52r-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shein0-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shf1u6-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shf6hr-1.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<img src=\"http://gohoy.top/i/2023/08/30/nu8ayl-1.png\" title=\"\" alt=\"\" width=\"1082\">\n\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgwwmc-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgze26-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgzotk-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sh8mdv-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sh8ys6-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sh98rx-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sh9n7v-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sha8lv-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sharvk-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shb4us-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shbf15-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shbwf3-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shcfc7-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shcrz4-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shd14n-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shdyaf-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/she52r-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shein0-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shf1u6-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/shf6hr-1.png\"></p>\n"},{"title":"爱在西元前吉他谱","_content":"\n![](http://gohoy.top/i/2023/08/11/sga3p7-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sga8nt-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgag68-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgazrx-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgb1nn-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgbdea-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgblm9-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgbr5u-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgcdkv-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgcjmn-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgct5i-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgcyy9-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgdg4x-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgdnce-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgdyke-1.png)\n","source":"_posts/爱在西元前.md","raw":"---\ntitle: 爱在西元前吉他谱\ncategory: 吉他谱\ntag: \n - 吉他谱\n---\n\n![](http://gohoy.top/i/2023/08/11/sga3p7-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sga8nt-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgag68-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgazrx-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgb1nn-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgbdea-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgblm9-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgbr5u-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgcdkv-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgcjmn-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgct5i-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgcyy9-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgdg4x-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgdnce-1.png)\n\n![](http://gohoy.top/i/2023/08/11/sgdyke-1.png)\n","slug":"爱在西元前","published":1,"date":"2023-08-30T06:28:51.566Z","updated":"2023-08-30T06:52:21.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cllyxpksx002114gfg9afazsc","content":"<p><img src=\"http://gohoy.top/i/2023/08/11/sga3p7-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sga8nt-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgag68-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgazrx-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgb1nn-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgbdea-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgblm9-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgbr5u-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgcdkv-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgcjmn-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgct5i-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgcyy9-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgdg4x-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgdnce-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgdyke-1.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://gohoy.top/i/2023/08/11/sga3p7-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sga8nt-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgag68-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgazrx-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgb1nn-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgbdea-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgblm9-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgbr5u-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgcdkv-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgcjmn-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgct5i-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgcyy9-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgdg4x-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgdnce-1.png\"></p>\n<p><img src=\"http://gohoy.top/i/2023/08/11/sgdyke-1.png\"></p>\n"},{"title":"说好的幸福呢吉他谱","_content":"\n![](https://gohoy.top/i/2023/09/04/vofyp7-1.png)\n\n![](https://gohoy.top/i/2023/09/04/voh84i-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vohmx2-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vora5o-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vorrgi-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vospr9-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vot7aa-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vou63j-1.png)\n\n![](https://gohoy.top/i/2023/09/04/voua7k-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vovcpu-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vow2lz-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vowddr-1.png)\n\n![](https://gohoy.top/i/2023/09/04/voxwdn-1.png)\n\n![](https://gohoy.top/i/2023/09/04/voxbyl-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vozo2f-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vozrsw-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vozzek-1.png)\n","source":"_posts/说好的幸福呢.md","raw":"---\ntitle: 说好的幸福呢吉他谱\ncategory: 吉他谱\ntag: \n - 吉他谱\n---\n\n![](https://gohoy.top/i/2023/09/04/vofyp7-1.png)\n\n![](https://gohoy.top/i/2023/09/04/voh84i-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vohmx2-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vora5o-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vorrgi-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vospr9-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vot7aa-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vou63j-1.png)\n\n![](https://gohoy.top/i/2023/09/04/voua7k-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vovcpu-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vow2lz-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vowddr-1.png)\n\n![](https://gohoy.top/i/2023/09/04/voxwdn-1.png)\n\n![](https://gohoy.top/i/2023/09/04/voxbyl-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vozo2f-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vozrsw-1.png)\n\n![](https://gohoy.top/i/2023/09/04/vozzek-1.png)\n","slug":"说好的幸福呢","published":1,"date":"2023-08-30T06:28:51.577Z","updated":"2023-09-04T11:16:44.772Z","_id":"cllyxpksy002314gfc5wue59g","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://gohoy.top/i/2023/09/04/vofyp7-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/voh84i-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vohmx2-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vora5o-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vorrgi-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vospr9-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vot7aa-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vou63j-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/voua7k-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vovcpu-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vow2lz-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vowddr-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/voxwdn-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/voxbyl-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vozo2f-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vozrsw-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vozzek-1.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://gohoy.top/i/2023/09/04/vofyp7-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/voh84i-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vohmx2-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vora5o-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vorrgi-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vospr9-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vot7aa-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vou63j-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/voua7k-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vovcpu-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vow2lz-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vowddr-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/voxwdn-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/voxbyl-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vozo2f-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vozrsw-1.png\"></p>\n<p><img src=\"https://gohoy.top/i/2023/09/04/vozzek-1.png\"></p>\n"},{"title":"openEuler安装K8S文档","_content":"\n# 重装k8s服务器文档\n\n## 任务背景：项目计划在两台服务器开启k8s集群，来运行虚拟机和pod，目前其中一台还没有安装k8s，因此任务是在这台openeuler20.04lts服务器上安装k8s集群。\n\n## 依照之前安装k8s所写文档（k8s-centos）进行安装k8s\n\n### 关闭防火墙 或者 开启防火墙端口\n\n`sudo systemctl stop firewalld.service\nsudo systemctl disable firewalld.service`\n\n```shell\n# master\nfirewall-cmd --zone=public --add-port=6443/tcp --permanent # Kubernetes API server\n所有\nfirewall-cmd --zone=public --add-port=2379/tcp --permanent # etcd server client\nAPI kube-apiserver, etcd\nfirewall-cmd --zone=public --add-port=2380/tcp --permanent # etcd server client\nAPI kube-apiserver, etcd\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API 自身,\n控制面\nfirewall-cmd --zone=public --add-port=10259/tcp --permanent # kube-scheduler 自\n身\nfirewall-cmd --zone=public --add-port=10257/tcp --permanent # kube-controller\u0002manager 自身\nfirewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --add-masquerade --permanent # 端口转发\nfirewall-cmd --reload\nfirewall-cmd --list-all\nfirewall-cmd --list-all --zone=trusted\n# 工作节点\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API 自身,\n控制面\nfirewall-cmd --zone=public --add-port=30000-32767/tcp --permanent # NodePort\nServices† 所有\nfirewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --add-masquerade --permanent # 端口转发\nfirewall-cmd --reload\nfirewall-cmd --list-all\nfirewall-cmd --list-all --zone=trusted\n```\n\n### 关闭swap和selinux\n\n```shell\nfree -h //查看是否关闭\nsudo swapoff -a //暂时关闭\nsudo sed -i 's/.*swap.*/#&/' /etc/fstab //永久关闭\nfree -h\ngetenforce\ncat /etc/selinux/config\nsudo setenforce 0\nsudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config\ncat /etc/selinux/config\n```\n\n### 安装docker  和 containerd和runc组件\n\ndocker使用dnf可以直接安装\n\ncontainerd 建议从官网下载tar包或deb包安装。\n\nrunc 必须从官网下载最新版，因为dnf源中的runc版本过低，无法使用。runc的包名为libseccomp-devel\n\n### 配置docker cgroups和源\n\n```shell\n# 对docker换源和cgroup设置\ncat<<EOF | sudo tee /etc/docker/daemon.json\n{\n\"registry-mirrors\": [\"https://2u8f97e8.mirror.aliyuncs.com\"],\n\"exec-opts\": [\"native.cgroupdriver=systemd\"]\n}\nEOF\n```\n\n### 设置内核参数\n\n```shell\n# 设置所需的 sysctl 参数，参数在重新启动后保持不变\ncat <<EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-iptables = 1\nnet.bridge.bridge-nf-call-ip6tables = 1 //这两条让网络连接走iptables（禁用可以不设置）\nnet.ipv4.ip_forward = 1 //是否允许将一个网络接口收到的数据包转发到另一个网络接口\nEOF\n# 应用 sysctl 参数而不重新启动\nsudo sysctl --system\n```\n\n### 设置k8s仓库\n\n```shell\ncat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\n# 是否开启本仓库\nenabled=1\n# 是否检查 gpg 签名文件\ngpgcheck=0\n# 是否检查 gpg 签名文件\nrepo_gpgcheck=0\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg\nhttps://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nEOF\n```\n\n### 安装kubelet kubeadm kubectl\n\n```shell\nsudo yum install -y kubelet-1.26.2-0 kubeadm-1.26.2-0 kubectl-1.26.2-0 --\ndisableexcludes=kubernetes --nogpgcheck\n```\n\n版本号选择你要安装的版本号，work尽量和master保持一致（1.23.1）。\n\n### master中执行\n\n```shell\nkubeadm init --image-repository=registry.aliyuncs.com/google_containers\n# 指定集群的IP\n# kubeadm init --image-repository=registry.aliyuncs.com/google_containers --apiserver\u0002advertise-address=192.168.80.60\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n# 或者在环境变量中添加：export KUBECONFIG=/etc/kubernetes/admin.conf\n# 添加完环境变量后，刷新环境变量：source /etc/profile\nkubectl cluster-info\n# 初始化失败后，可进行重置，重置命令：kubeadm reset -\n# 执行成功后，会出现类似下列内容：\n# kubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n# --discovery-token-ca-cert-hash\nsha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107\n# 查看join命令\n# kubeadm token create --print-join-command\n```\n\n### work节点上执行\n\n```shell\n# 运行的内容来自上方执行结果\nkubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n--discovery-token-ca-cert-hash\nsha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107\n```\n\n```shell\ncp /etc/kubenetes/*.config ~/.kube/config\n```\n\n之后使用kubectl get node 可以看到node的状态为not ready\n\n### 配置work网络（网络有问题的节点都需要进行）\n\n```shell\nyum install -y wget\nwget --no-check-certificate\nhttps://projectcalico.docs.tigera.io/archive/v3.25/manifests/calico.yaml\n```\n\n```shell\n# 在 - name: CLUSTER_TYPE 下方添加如下内容\n- name: CLUSTER_TYPE\nvalue: \"k8s,bgp\"\n# 下方为新增内容\n- name: IP_AUTODETECTION_METHOD\nvalue: \"interface=网卡名称\"\n```\n\n```shell\n# 配置网络\nkubectl apply -f calico.yaml\n```\n\n之后等网络配置完成。\n\n## 遇到的问题：\n\n### 安装程序的时候提示根目录空间占用100%，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm -rf删除了这些日志/var/log/pcp/pmlogger/openEuler1/。\n\n#### 关于pcp：\n\n- Performance Co-Pilot (`pcp`) 提供了支持系统级性能监控和管理的框架和服务。它为系统中的所有性能数据提供了统一的抽象，以及用于询问、检索和处理该数据的许多工具。\n- 这些生成的log，在openeuler系统没有设置自动清理，导致了日志积累。\n\n### 使用kubeadm join报错runtime not running或者 no such file or dictionary\n\n原因：现在kubelet默认runtime是containerd，一般的原因都是没有正常安装containerd造成的\n\n解决方法：安装containerd\n\n### join后总是显示节点notReady\n\n原因：docker的一些容器启动错误，去docker查看问题所在\n\n解决方法：docker start 一个容器，查看报错\n\n### docker启动容器报错runc error\n\n原因：runc错误\n\n解决方法：卸载本地的 libseccomp-devel包，重装最新版本（runc包含在这个包中，yum仓库版本不够新）\n\n### kubectl get 命令报错 The connection to the server localhost:8080 was refused – did you specify the right host or port?\n\n原因：kubectl 无法获取到集群信息，一般都是因为配置文件~/.kube/下没有配置文件\n\n解决方法：首先当你kubeadm join成功后，在/etc/kubenetes/下有一个conf文件，将它复制为~/.kube/config即可解决。\n\n### calico镜像pull缓慢或出错\n\n将containerd 源从\n`registry.cn-hangzhou.aliyuncs.com/google_containers/pause`\n\n换成\n``registry.aliyuncs.com/k8sxio/pause`\n","source":"_posts/重装k8s服务器文档.md","raw":"---\ntitle: openEuler安装K8S文档\ncategory: K8S\ntag: \n - K8S\n - openEuler\n - 教程\n - arm64\n---\n\n# 重装k8s服务器文档\n\n## 任务背景：项目计划在两台服务器开启k8s集群，来运行虚拟机和pod，目前其中一台还没有安装k8s，因此任务是在这台openeuler20.04lts服务器上安装k8s集群。\n\n## 依照之前安装k8s所写文档（k8s-centos）进行安装k8s\n\n### 关闭防火墙 或者 开启防火墙端口\n\n`sudo systemctl stop firewalld.service\nsudo systemctl disable firewalld.service`\n\n```shell\n# master\nfirewall-cmd --zone=public --add-port=6443/tcp --permanent # Kubernetes API server\n所有\nfirewall-cmd --zone=public --add-port=2379/tcp --permanent # etcd server client\nAPI kube-apiserver, etcd\nfirewall-cmd --zone=public --add-port=2380/tcp --permanent # etcd server client\nAPI kube-apiserver, etcd\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API 自身,\n控制面\nfirewall-cmd --zone=public --add-port=10259/tcp --permanent # kube-scheduler 自\n身\nfirewall-cmd --zone=public --add-port=10257/tcp --permanent # kube-controller\u0002manager 自身\nfirewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --add-masquerade --permanent # 端口转发\nfirewall-cmd --reload\nfirewall-cmd --list-all\nfirewall-cmd --list-all --zone=trusted\n# 工作节点\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API 自身,\n控制面\nfirewall-cmd --zone=public --add-port=30000-32767/tcp --permanent # NodePort\nServices† 所有\nfirewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --add-masquerade --permanent # 端口转发\nfirewall-cmd --reload\nfirewall-cmd --list-all\nfirewall-cmd --list-all --zone=trusted\n```\n\n### 关闭swap和selinux\n\n```shell\nfree -h //查看是否关闭\nsudo swapoff -a //暂时关闭\nsudo sed -i 's/.*swap.*/#&/' /etc/fstab //永久关闭\nfree -h\ngetenforce\ncat /etc/selinux/config\nsudo setenforce 0\nsudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config\ncat /etc/selinux/config\n```\n\n### 安装docker  和 containerd和runc组件\n\ndocker使用dnf可以直接安装\n\ncontainerd 建议从官网下载tar包或deb包安装。\n\nrunc 必须从官网下载最新版，因为dnf源中的runc版本过低，无法使用。runc的包名为libseccomp-devel\n\n### 配置docker cgroups和源\n\n```shell\n# 对docker换源和cgroup设置\ncat<<EOF | sudo tee /etc/docker/daemon.json\n{\n\"registry-mirrors\": [\"https://2u8f97e8.mirror.aliyuncs.com\"],\n\"exec-opts\": [\"native.cgroupdriver=systemd\"]\n}\nEOF\n```\n\n### 设置内核参数\n\n```shell\n# 设置所需的 sysctl 参数，参数在重新启动后保持不变\ncat <<EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-iptables = 1\nnet.bridge.bridge-nf-call-ip6tables = 1 //这两条让网络连接走iptables（禁用可以不设置）\nnet.ipv4.ip_forward = 1 //是否允许将一个网络接口收到的数据包转发到另一个网络接口\nEOF\n# 应用 sysctl 参数而不重新启动\nsudo sysctl --system\n```\n\n### 设置k8s仓库\n\n```shell\ncat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\n# 是否开启本仓库\nenabled=1\n# 是否检查 gpg 签名文件\ngpgcheck=0\n# 是否检查 gpg 签名文件\nrepo_gpgcheck=0\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg\nhttps://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nEOF\n```\n\n### 安装kubelet kubeadm kubectl\n\n```shell\nsudo yum install -y kubelet-1.26.2-0 kubeadm-1.26.2-0 kubectl-1.26.2-0 --\ndisableexcludes=kubernetes --nogpgcheck\n```\n\n版本号选择你要安装的版本号，work尽量和master保持一致（1.23.1）。\n\n### master中执行\n\n```shell\nkubeadm init --image-repository=registry.aliyuncs.com/google_containers\n# 指定集群的IP\n# kubeadm init --image-repository=registry.aliyuncs.com/google_containers --apiserver\u0002advertise-address=192.168.80.60\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n# 或者在环境变量中添加：export KUBECONFIG=/etc/kubernetes/admin.conf\n# 添加完环境变量后，刷新环境变量：source /etc/profile\nkubectl cluster-info\n# 初始化失败后，可进行重置，重置命令：kubeadm reset -\n# 执行成功后，会出现类似下列内容：\n# kubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n# --discovery-token-ca-cert-hash\nsha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107\n# 查看join命令\n# kubeadm token create --print-join-command\n```\n\n### work节点上执行\n\n```shell\n# 运行的内容来自上方执行结果\nkubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n--discovery-token-ca-cert-hash\nsha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107\n```\n\n```shell\ncp /etc/kubenetes/*.config ~/.kube/config\n```\n\n之后使用kubectl get node 可以看到node的状态为not ready\n\n### 配置work网络（网络有问题的节点都需要进行）\n\n```shell\nyum install -y wget\nwget --no-check-certificate\nhttps://projectcalico.docs.tigera.io/archive/v3.25/manifests/calico.yaml\n```\n\n```shell\n# 在 - name: CLUSTER_TYPE 下方添加如下内容\n- name: CLUSTER_TYPE\nvalue: \"k8s,bgp\"\n# 下方为新增内容\n- name: IP_AUTODETECTION_METHOD\nvalue: \"interface=网卡名称\"\n```\n\n```shell\n# 配置网络\nkubectl apply -f calico.yaml\n```\n\n之后等网络配置完成。\n\n## 遇到的问题：\n\n### 安装程序的时候提示根目录空间占用100%，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm -rf删除了这些日志/var/log/pcp/pmlogger/openEuler1/。\n\n#### 关于pcp：\n\n- Performance Co-Pilot (`pcp`) 提供了支持系统级性能监控和管理的框架和服务。它为系统中的所有性能数据提供了统一的抽象，以及用于询问、检索和处理该数据的许多工具。\n- 这些生成的log，在openeuler系统没有设置自动清理，导致了日志积累。\n\n### 使用kubeadm join报错runtime not running或者 no such file or dictionary\n\n原因：现在kubelet默认runtime是containerd，一般的原因都是没有正常安装containerd造成的\n\n解决方法：安装containerd\n\n### join后总是显示节点notReady\n\n原因：docker的一些容器启动错误，去docker查看问题所在\n\n解决方法：docker start 一个容器，查看报错\n\n### docker启动容器报错runc error\n\n原因：runc错误\n\n解决方法：卸载本地的 libseccomp-devel包，重装最新版本（runc包含在这个包中，yum仓库版本不够新）\n\n### kubectl get 命令报错 The connection to the server localhost:8080 was refused – did you specify the right host or port?\n\n原因：kubectl 无法获取到集群信息，一般都是因为配置文件~/.kube/下没有配置文件\n\n解决方法：首先当你kubeadm join成功后，在/etc/kubenetes/下有一个conf文件，将它复制为~/.kube/config即可解决。\n\n### calico镜像pull缓慢或出错\n\n将containerd 源从\n`registry.cn-hangzhou.aliyuncs.com/google_containers/pause`\n\n换成\n``registry.aliyuncs.com/k8sxio/pause`\n","slug":"重装k8s服务器文档","published":1,"date":"2023-08-30T06:28:51.587Z","updated":"2023-09-11T13:39:27.487Z","_id":"cllyxpksz002514gf0uux1lvp","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"重装k8s服务器文档\"><a href=\"#重装k8s服务器文档\" class=\"headerlink\" title=\"重装k8s服务器文档\"></a>重装k8s服务器文档</h1><h2 id=\"任务背景：项目计划在两台服务器开启k8s集群，来运行虚拟机和pod，目前其中一台还没有安装k8s，因此任务是在这台openeuler20-04lts服务器上安装k8s集群。\"><a href=\"#任务背景：项目计划在两台服务器开启k8s集群，来运行虚拟机和pod，目前其中一台还没有安装k8s，因此任务是在这台openeuler20-04lts服务器上安装k8s集群。\" class=\"headerlink\" title=\"任务背景：项目计划在两台服务器开启k8s集群，来运行虚拟机和pod，目前其中一台还没有安装k8s，因此任务是在这台openeuler20.04lts服务器上安装k8s集群。\"></a>任务背景：项目计划在两台服务器开启k8s集群，来运行虚拟机和pod，目前其中一台还没有安装k8s，因此任务是在这台openeuler20.04lts服务器上安装k8s集群。</h2><h2 id=\"依照之前安装k8s所写文档（k8s-centos）进行安装k8s\"><a href=\"#依照之前安装k8s所写文档（k8s-centos）进行安装k8s\" class=\"headerlink\" title=\"依照之前安装k8s所写文档（k8s-centos）进行安装k8s\"></a>依照之前安装k8s所写文档（k8s-centos）进行安装k8s</h2><h3 id=\"关闭防火墙-或者-开启防火墙端口\"><a href=\"#关闭防火墙-或者-开启防火墙端口\" class=\"headerlink\" title=\"关闭防火墙 或者 开启防火墙端口\"></a>关闭防火墙 或者 开启防火墙端口</h3><p><code>sudo systemctl stop firewalld.service sudo systemctl disable firewalld.service</code></p>\n<pre><code class=\"shell\"># master\nfirewall-cmd --zone=public --add-port=6443/tcp --permanent # Kubernetes API server\n所有\nfirewall-cmd --zone=public --add-port=2379/tcp --permanent # etcd server client\nAPI kube-apiserver, etcd\nfirewall-cmd --zone=public --add-port=2380/tcp --permanent # etcd server client\nAPI kube-apiserver, etcd\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API 自身,\n控制面\nfirewall-cmd --zone=public --add-port=10259/tcp --permanent # kube-scheduler 自\n身\nfirewall-cmd --zone=public --add-port=10257/tcp --permanent # kube-controller\u0002manager 自身\nfirewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --add-masquerade --permanent # 端口转发\nfirewall-cmd --reload\nfirewall-cmd --list-all\nfirewall-cmd --list-all --zone=trusted\n# 工作节点\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API 自身,\n控制面\nfirewall-cmd --zone=public --add-port=30000-32767/tcp --permanent # NodePort\nServices† 所有\nfirewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --add-masquerade --permanent # 端口转发\nfirewall-cmd --reload\nfirewall-cmd --list-all\nfirewall-cmd --list-all --zone=trusted\n</code></pre>\n<h3 id=\"关闭swap和selinux\"><a href=\"#关闭swap和selinux\" class=\"headerlink\" title=\"关闭swap和selinux\"></a>关闭swap和selinux</h3><pre><code class=\"shell\">free -h //查看是否关闭\nsudo swapoff -a //暂时关闭\nsudo sed -i &#39;s/.*swap.*/#&amp;/&#39; /etc/fstab //永久关闭\nfree -h\ngetenforce\ncat /etc/selinux/config\nsudo setenforce 0\nsudo sed -i &#39;s/^SELINUX=enforcing$/SELINUX=permissive/&#39; /etc/selinux/config\ncat /etc/selinux/config\n</code></pre>\n<h3 id=\"安装docker-和-containerd和runc组件\"><a href=\"#安装docker-和-containerd和runc组件\" class=\"headerlink\" title=\"安装docker  和 containerd和runc组件\"></a>安装docker  和 containerd和runc组件</h3><p>docker使用dnf可以直接安装</p>\n<p>containerd 建议从官网下载tar包或deb包安装。</p>\n<p>runc 必须从官网下载最新版，因为dnf源中的runc版本过低，无法使用。runc的包名为libseccomp-devel</p>\n<h3 id=\"配置docker-cgroups和源\"><a href=\"#配置docker-cgroups和源\" class=\"headerlink\" title=\"配置docker cgroups和源\"></a>配置docker cgroups和源</h3><pre><code class=\"shell\"># 对docker换源和cgroup设置\ncat&lt;&lt;EOF | sudo tee /etc/docker/daemon.json\n&#123;\n&quot;registry-mirrors&quot;: [&quot;https://2u8f97e8.mirror.aliyuncs.com&quot;],\n&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]\n&#125;\nEOF\n</code></pre>\n<h3 id=\"设置内核参数\"><a href=\"#设置内核参数\" class=\"headerlink\" title=\"设置内核参数\"></a>设置内核参数</h3><pre><code class=\"shell\"># 设置所需的 sysctl 参数，参数在重新启动后保持不变\ncat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-iptables = 1\nnet.bridge.bridge-nf-call-ip6tables = 1 //这两条让网络连接走iptables（禁用可以不设置）\nnet.ipv4.ip_forward = 1 //是否允许将一个网络接口收到的数据包转发到另一个网络接口\nEOF\n# 应用 sysctl 参数而不重新启动\nsudo sysctl --system\n</code></pre>\n<h3 id=\"设置k8s仓库\"><a href=\"#设置k8s仓库\" class=\"headerlink\" title=\"设置k8s仓库\"></a>设置k8s仓库</h3><pre><code class=\"shell\">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\n# 是否开启本仓库\nenabled=1\n# 是否检查 gpg 签名文件\ngpgcheck=0\n# 是否检查 gpg 签名文件\nrepo_gpgcheck=0\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg\nhttps://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nEOF\n</code></pre>\n<h3 id=\"安装kubelet-kubeadm-kubectl\"><a href=\"#安装kubelet-kubeadm-kubectl\" class=\"headerlink\" title=\"安装kubelet kubeadm kubectl\"></a>安装kubelet kubeadm kubectl</h3><pre><code class=\"shell\">sudo yum install -y kubelet-1.26.2-0 kubeadm-1.26.2-0 kubectl-1.26.2-0 --\ndisableexcludes=kubernetes --nogpgcheck\n</code></pre>\n<p>版本号选择你要安装的版本号，work尽量和master保持一致（1.23.1）。</p>\n<h3 id=\"master中执行\"><a href=\"#master中执行\" class=\"headerlink\" title=\"master中执行\"></a>master中执行</h3><pre><code class=\"shell\">kubeadm init --image-repository=registry.aliyuncs.com/google_containers\n# 指定集群的IP\n# kubeadm init --image-repository=registry.aliyuncs.com/google_containers --apiserver\u0002advertise-address=192.168.80.60\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n# 或者在环境变量中添加：export KUBECONFIG=/etc/kubernetes/admin.conf\n# 添加完环境变量后，刷新环境变量：source /etc/profile\nkubectl cluster-info\n# 初始化失败后，可进行重置，重置命令：kubeadm reset -\n# 执行成功后，会出现类似下列内容：\n# kubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n# --discovery-token-ca-cert-hash\nsha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107\n# 查看join命令\n# kubeadm token create --print-join-command\n</code></pre>\n<h3 id=\"work节点上执行\"><a href=\"#work节点上执行\" class=\"headerlink\" title=\"work节点上执行\"></a>work节点上执行</h3><pre><code class=\"shell\"># 运行的内容来自上方执行结果\nkubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n--discovery-token-ca-cert-hash\nsha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107\n</code></pre>\n<pre><code class=\"shell\">cp /etc/kubenetes/*.config ~/.kube/config\n</code></pre>\n<p>之后使用kubectl get node 可以看到node的状态为not ready</p>\n<h3 id=\"配置work网络（网络有问题的节点都需要进行）\"><a href=\"#配置work网络（网络有问题的节点都需要进行）\" class=\"headerlink\" title=\"配置work网络（网络有问题的节点都需要进行）\"></a>配置work网络（网络有问题的节点都需要进行）</h3><pre><code class=\"shell\">yum install -y wget\nwget --no-check-certificate\nhttps://projectcalico.docs.tigera.io/archive/v3.25/manifests/calico.yaml\n</code></pre>\n<pre><code class=\"shell\"># 在 - name: CLUSTER_TYPE 下方添加如下内容\n- name: CLUSTER_TYPE\nvalue: &quot;k8s,bgp&quot;\n# 下方为新增内容\n- name: IP_AUTODETECTION_METHOD\nvalue: &quot;interface=网卡名称&quot;\n</code></pre>\n<pre><code class=\"shell\"># 配置网络\nkubectl apply -f calico.yaml\n</code></pre>\n<p>之后等网络配置完成。</p>\n<h2 id=\"遇到的问题：\"><a href=\"#遇到的问题：\" class=\"headerlink\" title=\"遇到的问题：\"></a>遇到的问题：</h2><h3 id=\"安装程序的时候提示根目录空间占用100-，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm-rf删除了这些日志-var-log-pcp-pmlogger-openEuler1-。\"><a href=\"#安装程序的时候提示根目录空间占用100-，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm-rf删除了这些日志-var-log-pcp-pmlogger-openEuler1-。\" class=\"headerlink\" title=\"安装程序的时候提示根目录空间占用100%，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm -rf删除了这些日志&#x2F;var&#x2F;log&#x2F;pcp&#x2F;pmlogger&#x2F;openEuler1&#x2F;。\"></a>安装程序的时候提示根目录空间占用100%，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm -rf删除了这些日志&#x2F;var&#x2F;log&#x2F;pcp&#x2F;pmlogger&#x2F;openEuler1&#x2F;。</h3><h4 id=\"关于pcp：\"><a href=\"#关于pcp：\" class=\"headerlink\" title=\"关于pcp：\"></a>关于pcp：</h4><ul>\n<li>Performance Co-Pilot (<code>pcp</code>) 提供了支持系统级性能监控和管理的框架和服务。它为系统中的所有性能数据提供了统一的抽象，以及用于询问、检索和处理该数据的许多工具。</li>\n<li>这些生成的log，在openeuler系统没有设置自动清理，导致了日志积累。</li>\n</ul>\n<h3 id=\"使用kubeadm-join报错runtime-not-running或者-no-such-file-or-dictionary\"><a href=\"#使用kubeadm-join报错runtime-not-running或者-no-such-file-or-dictionary\" class=\"headerlink\" title=\"使用kubeadm join报错runtime not running或者 no such file or dictionary\"></a>使用kubeadm join报错runtime not running或者 no such file or dictionary</h3><p>原因：现在kubelet默认runtime是containerd，一般的原因都是没有正常安装containerd造成的</p>\n<p>解决方法：安装containerd</p>\n<h3 id=\"join后总是显示节点notReady\"><a href=\"#join后总是显示节点notReady\" class=\"headerlink\" title=\"join后总是显示节点notReady\"></a>join后总是显示节点notReady</h3><p>原因：docker的一些容器启动错误，去docker查看问题所在</p>\n<p>解决方法：docker start 一个容器，查看报错</p>\n<h3 id=\"docker启动容器报错runc-error\"><a href=\"#docker启动容器报错runc-error\" class=\"headerlink\" title=\"docker启动容器报错runc error\"></a>docker启动容器报错runc error</h3><p>原因：runc错误</p>\n<p>解决方法：卸载本地的 libseccomp-devel包，重装最新版本（runc包含在这个包中，yum仓库版本不够新）</p>\n<h3 id=\"kubectl-get-命令报错-The-connection-to-the-server-localhost-8080-was-refused-–-did-you-specify-the-right-host-or-port\"><a href=\"#kubectl-get-命令报错-The-connection-to-the-server-localhost-8080-was-refused-–-did-you-specify-the-right-host-or-port\" class=\"headerlink\" title=\"kubectl get 命令报错 The connection to the server localhost:8080 was refused – did you specify the right host or port?\"></a>kubectl get 命令报错 The connection to the server localhost:8080 was refused – did you specify the right host or port?</h3><p>原因：kubectl 无法获取到集群信息，一般都是因为配置文件~&#x2F;.kube&#x2F;下没有配置文件</p>\n<p>解决方法：首先当你kubeadm join成功后，在&#x2F;etc&#x2F;kubenetes&#x2F;下有一个conf文件，将它复制为~&#x2F;.kube&#x2F;config即可解决。</p>\n<h3 id=\"calico镜像pull缓慢或出错\"><a href=\"#calico镜像pull缓慢或出错\" class=\"headerlink\" title=\"calico镜像pull缓慢或出错\"></a>calico镜像pull缓慢或出错</h3><p>将containerd 源从<br><code>registry.cn-hangzhou.aliyuncs.com/google_containers/pause</code></p>\n<p>换成<br>&#96;&#96;registry.aliyuncs.com&#x2F;k8sxio&#x2F;pause&#96;</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"重装k8s服务器文档\"><a href=\"#重装k8s服务器文档\" class=\"headerlink\" title=\"重装k8s服务器文档\"></a>重装k8s服务器文档</h1><h2 id=\"任务背景：项目计划在两台服务器开启k8s集群，来运行虚拟机和pod，目前其中一台还没有安装k8s，因此任务是在这台openeuler20-04lts服务器上安装k8s集群。\"><a href=\"#任务背景：项目计划在两台服务器开启k8s集群，来运行虚拟机和pod，目前其中一台还没有安装k8s，因此任务是在这台openeuler20-04lts服务器上安装k8s集群。\" class=\"headerlink\" title=\"任务背景：项目计划在两台服务器开启k8s集群，来运行虚拟机和pod，目前其中一台还没有安装k8s，因此任务是在这台openeuler20.04lts服务器上安装k8s集群。\"></a>任务背景：项目计划在两台服务器开启k8s集群，来运行虚拟机和pod，目前其中一台还没有安装k8s，因此任务是在这台openeuler20.04lts服务器上安装k8s集群。</h2><h2 id=\"依照之前安装k8s所写文档（k8s-centos）进行安装k8s\"><a href=\"#依照之前安装k8s所写文档（k8s-centos）进行安装k8s\" class=\"headerlink\" title=\"依照之前安装k8s所写文档（k8s-centos）进行安装k8s\"></a>依照之前安装k8s所写文档（k8s-centos）进行安装k8s</h2><h3 id=\"关闭防火墙-或者-开启防火墙端口\"><a href=\"#关闭防火墙-或者-开启防火墙端口\" class=\"headerlink\" title=\"关闭防火墙 或者 开启防火墙端口\"></a>关闭防火墙 或者 开启防火墙端口</h3><p><code>sudo systemctl stop firewalld.service sudo systemctl disable firewalld.service</code></p>\n<pre><code class=\"shell\"># master\nfirewall-cmd --zone=public --add-port=6443/tcp --permanent # Kubernetes API server\n所有\nfirewall-cmd --zone=public --add-port=2379/tcp --permanent # etcd server client\nAPI kube-apiserver, etcd\nfirewall-cmd --zone=public --add-port=2380/tcp --permanent # etcd server client\nAPI kube-apiserver, etcd\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API 自身,\n控制面\nfirewall-cmd --zone=public --add-port=10259/tcp --permanent # kube-scheduler 自\n身\nfirewall-cmd --zone=public --add-port=10257/tcp --permanent # kube-controller\u0002manager 自身\nfirewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --add-masquerade --permanent # 端口转发\nfirewall-cmd --reload\nfirewall-cmd --list-all\nfirewall-cmd --list-all --zone=trusted\n# 工作节点\nfirewall-cmd --zone=public --add-port=10250/tcp --permanent # Kubelet API 自身,\n控制面\nfirewall-cmd --zone=public --add-port=30000-32767/tcp --permanent # NodePort\nServices† 所有\nfirewall-cmd --zone=trusted --add-source=192.168.111.200 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.201 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --zone=trusted --add-source=192.168.111.202 --permanent # 信任集群中各\n个节点的IP\nfirewall-cmd --add-masquerade --permanent # 端口转发\nfirewall-cmd --reload\nfirewall-cmd --list-all\nfirewall-cmd --list-all --zone=trusted\n</code></pre>\n<h3 id=\"关闭swap和selinux\"><a href=\"#关闭swap和selinux\" class=\"headerlink\" title=\"关闭swap和selinux\"></a>关闭swap和selinux</h3><pre><code class=\"shell\">free -h //查看是否关闭\nsudo swapoff -a //暂时关闭\nsudo sed -i &#39;s/.*swap.*/#&amp;/&#39; /etc/fstab //永久关闭\nfree -h\ngetenforce\ncat /etc/selinux/config\nsudo setenforce 0\nsudo sed -i &#39;s/^SELINUX=enforcing$/SELINUX=permissive/&#39; /etc/selinux/config\ncat /etc/selinux/config\n</code></pre>\n<h3 id=\"安装docker-和-containerd和runc组件\"><a href=\"#安装docker-和-containerd和runc组件\" class=\"headerlink\" title=\"安装docker  和 containerd和runc组件\"></a>安装docker  和 containerd和runc组件</h3><p>docker使用dnf可以直接安装</p>\n<p>containerd 建议从官网下载tar包或deb包安装。</p>\n<p>runc 必须从官网下载最新版，因为dnf源中的runc版本过低，无法使用。runc的包名为libseccomp-devel</p>\n<h3 id=\"配置docker-cgroups和源\"><a href=\"#配置docker-cgroups和源\" class=\"headerlink\" title=\"配置docker cgroups和源\"></a>配置docker cgroups和源</h3><pre><code class=\"shell\"># 对docker换源和cgroup设置\ncat&lt;&lt;EOF | sudo tee /etc/docker/daemon.json\n&#123;\n&quot;registry-mirrors&quot;: [&quot;https://2u8f97e8.mirror.aliyuncs.com&quot;],\n&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]\n&#125;\nEOF\n</code></pre>\n<h3 id=\"设置内核参数\"><a href=\"#设置内核参数\" class=\"headerlink\" title=\"设置内核参数\"></a>设置内核参数</h3><pre><code class=\"shell\"># 设置所需的 sysctl 参数，参数在重新启动后保持不变\ncat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-iptables = 1\nnet.bridge.bridge-nf-call-ip6tables = 1 //这两条让网络连接走iptables（禁用可以不设置）\nnet.ipv4.ip_forward = 1 //是否允许将一个网络接口收到的数据包转发到另一个网络接口\nEOF\n# 应用 sysctl 参数而不重新启动\nsudo sysctl --system\n</code></pre>\n<h3 id=\"设置k8s仓库\"><a href=\"#设置k8s仓库\" class=\"headerlink\" title=\"设置k8s仓库\"></a>设置k8s仓库</h3><pre><code class=\"shell\">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\n# 是否开启本仓库\nenabled=1\n# 是否检查 gpg 签名文件\ngpgcheck=0\n# 是否检查 gpg 签名文件\nrepo_gpgcheck=0\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg\nhttps://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nEOF\n</code></pre>\n<h3 id=\"安装kubelet-kubeadm-kubectl\"><a href=\"#安装kubelet-kubeadm-kubectl\" class=\"headerlink\" title=\"安装kubelet kubeadm kubectl\"></a>安装kubelet kubeadm kubectl</h3><pre><code class=\"shell\">sudo yum install -y kubelet-1.26.2-0 kubeadm-1.26.2-0 kubectl-1.26.2-0 --\ndisableexcludes=kubernetes --nogpgcheck\n</code></pre>\n<p>版本号选择你要安装的版本号，work尽量和master保持一致（1.23.1）。</p>\n<h3 id=\"master中执行\"><a href=\"#master中执行\" class=\"headerlink\" title=\"master中执行\"></a>master中执行</h3><pre><code class=\"shell\">kubeadm init --image-repository=registry.aliyuncs.com/google_containers\n# 指定集群的IP\n# kubeadm init --image-repository=registry.aliyuncs.com/google_containers --apiserver\u0002advertise-address=192.168.80.60\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n# 或者在环境变量中添加：export KUBECONFIG=/etc/kubernetes/admin.conf\n# 添加完环境变量后，刷新环境变量：source /etc/profile\nkubectl cluster-info\n# 初始化失败后，可进行重置，重置命令：kubeadm reset -\n# 执行成功后，会出现类似下列内容：\n# kubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n# --discovery-token-ca-cert-hash\nsha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107\n# 查看join命令\n# kubeadm token create --print-join-command\n</code></pre>\n<h3 id=\"work节点上执行\"><a href=\"#work节点上执行\" class=\"headerlink\" title=\"work节点上执行\"></a>work节点上执行</h3><pre><code class=\"shell\"># 运行的内容来自上方执行结果\nkubeadm join 192.168.80.60:6443 --token f9lvrz.59mykzssqw6vjh32 \\\n--discovery-token-ca-cert-hash\nsha256:4e23156e2f71c5df52dfd2b9b198cce5db27c47707564684ea74986836900107\n</code></pre>\n<pre><code class=\"shell\">cp /etc/kubenetes/*.config ~/.kube/config\n</code></pre>\n<p>之后使用kubectl get node 可以看到node的状态为not ready</p>\n<h3 id=\"配置work网络（网络有问题的节点都需要进行）\"><a href=\"#配置work网络（网络有问题的节点都需要进行）\" class=\"headerlink\" title=\"配置work网络（网络有问题的节点都需要进行）\"></a>配置work网络（网络有问题的节点都需要进行）</h3><pre><code class=\"shell\">yum install -y wget\nwget --no-check-certificate\nhttps://projectcalico.docs.tigera.io/archive/v3.25/manifests/calico.yaml\n</code></pre>\n<pre><code class=\"shell\"># 在 - name: CLUSTER_TYPE 下方添加如下内容\n- name: CLUSTER_TYPE\nvalue: &quot;k8s,bgp&quot;\n# 下方为新增内容\n- name: IP_AUTODETECTION_METHOD\nvalue: &quot;interface=网卡名称&quot;\n</code></pre>\n<pre><code class=\"shell\"># 配置网络\nkubectl apply -f calico.yaml\n</code></pre>\n<p>之后等网络配置完成。</p>\n<h2 id=\"遇到的问题：\"><a href=\"#遇到的问题：\" class=\"headerlink\" title=\"遇到的问题：\"></a>遇到的问题：</h2><h3 id=\"安装程序的时候提示根目录空间占用100-，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm-rf删除了这些日志-var-log-pcp-pmlogger-openEuler1-。\"><a href=\"#安装程序的时候提示根目录空间占用100-，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm-rf删除了这些日志-var-log-pcp-pmlogger-openEuler1-。\" class=\"headerlink\" title=\"安装程序的时候提示根目录空间占用100%，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm -rf删除了这些日志&#x2F;var&#x2F;log&#x2F;pcp&#x2F;pmlogger&#x2F;openEuler1&#x2F;。\"></a>安装程序的时候提示根目录空间占用100%，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm -rf删除了这些日志&#x2F;var&#x2F;log&#x2F;pcp&#x2F;pmlogger&#x2F;openEuler1&#x2F;。</h3><h4 id=\"关于pcp：\"><a href=\"#关于pcp：\" class=\"headerlink\" title=\"关于pcp：\"></a>关于pcp：</h4><ul>\n<li>Performance Co-Pilot (<code>pcp</code>) 提供了支持系统级性能监控和管理的框架和服务。它为系统中的所有性能数据提供了统一的抽象，以及用于询问、检索和处理该数据的许多工具。</li>\n<li>这些生成的log，在openeuler系统没有设置自动清理，导致了日志积累。</li>\n</ul>\n<h3 id=\"使用kubeadm-join报错runtime-not-running或者-no-such-file-or-dictionary\"><a href=\"#使用kubeadm-join报错runtime-not-running或者-no-such-file-or-dictionary\" class=\"headerlink\" title=\"使用kubeadm join报错runtime not running或者 no such file or dictionary\"></a>使用kubeadm join报错runtime not running或者 no such file or dictionary</h3><p>原因：现在kubelet默认runtime是containerd，一般的原因都是没有正常安装containerd造成的</p>\n<p>解决方法：安装containerd</p>\n<h3 id=\"join后总是显示节点notReady\"><a href=\"#join后总是显示节点notReady\" class=\"headerlink\" title=\"join后总是显示节点notReady\"></a>join后总是显示节点notReady</h3><p>原因：docker的一些容器启动错误，去docker查看问题所在</p>\n<p>解决方法：docker start 一个容器，查看报错</p>\n<h3 id=\"docker启动容器报错runc-error\"><a href=\"#docker启动容器报错runc-error\" class=\"headerlink\" title=\"docker启动容器报错runc error\"></a>docker启动容器报错runc error</h3><p>原因：runc错误</p>\n<p>解决方法：卸载本地的 libseccomp-devel包，重装最新版本（runc包含在这个包中，yum仓库版本不够新）</p>\n<h3 id=\"kubectl-get-命令报错-The-connection-to-the-server-localhost-8080-was-refused-–-did-you-specify-the-right-host-or-port\"><a href=\"#kubectl-get-命令报错-The-connection-to-the-server-localhost-8080-was-refused-–-did-you-specify-the-right-host-or-port\" class=\"headerlink\" title=\"kubectl get 命令报错 The connection to the server localhost:8080 was refused – did you specify the right host or port?\"></a>kubectl get 命令报错 The connection to the server localhost:8080 was refused – did you specify the right host or port?</h3><p>原因：kubectl 无法获取到集群信息，一般都是因为配置文件~&#x2F;.kube&#x2F;下没有配置文件</p>\n<p>解决方法：首先当你kubeadm join成功后，在&#x2F;etc&#x2F;kubenetes&#x2F;下有一个conf文件，将它复制为~&#x2F;.kube&#x2F;config即可解决。</p>\n<h3 id=\"calico镜像pull缓慢或出错\"><a href=\"#calico镜像pull缓慢或出错\" class=\"headerlink\" title=\"calico镜像pull缓慢或出错\"></a>calico镜像pull缓慢或出错</h3><p>将containerd 源从<br><code>registry.cn-hangzhou.aliyuncs.com/google_containers/pause</code></p>\n<p>换成<br>&#96;&#96;registry.aliyuncs.com&#x2F;k8sxio&#x2F;pause&#96;</p>\n"},{"title":"Java面经记录","_content":"\n# 面经\n\n## Java基础知识\n\n### 为什么说Java是编译和解释的语言\n\nJava需要把代码编译成.class的字节码文件，然后再解释成机器码。\n\n### 静态方法中为什么不能调用非静态方法\n\n因为静态方法在类创建的时候生成，非静态方法在实例化对象之后才生成。\n\n### 重载和重写\n\n重载：同方法名，不同参数\n\n重写：子类重写父类的方法，方法名参数相同，构造方法无法重写\n\n### 可变长参数public void test(String ...args)\n\n可以接收不同长度的参数，重载的时候优先匹配固定长度参数的方法。\n\n### 对象实体和对象引用\n\nnew 来创建一个对象实体，一个对象实体可以有多个对象引用。一个对象引用可以指向一个对象实体。\n\n对象实体存在堆内存中（类和对象都存放在堆内存中）\n\n对象引用存放在栈内存中\n\n### 对象默认有无参构造，但创建有参构造后要手动创建无参构造。\n\n### 多态\n\n子类在调用父类的方法的时候，只有在运行的时候，才知道调用的是哪个方法（父类的还是子类的），这个方法具有多态性\n\n### 接口和抽象类的区别\n\n* 相同点：\n  * 都不能被实例化\n  * 都可以包含抽象方法\n  * 都可以有默认实现的方法，接口中可以定义default方法来实现\n* 不同点\n  * 接口主要是对对象的约束，约束对象的行为（实现接口的方法）\n  * 抽象类主要是代码的复用性的规定\n  * 一个类只可以继承一个类，但可以实现多个接口\n  * 接口中 的成员变量只能是public static final 类型，有初值，不可变\n  * 抽象类中的成员变量默认为default，可在子类中重新定义和赋值\n\n### 深拷贝和浅拷贝\n\n浅拷贝：在对上创建一个新对象，如果被拷贝的是引用类型，则会直接复制它引用的地址\n\n深拷贝：复制整个对象，包含内部对象\n\n### Object 的常用方法\n\n<details><summary>点击展开代码</summary><pre><code>/**\n * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\n */\npublic final native Class<?> getClass()\n/**\n * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\n */\npublic native int hashCode()\n/**\n * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\n */\npublic boolean equals(Object obj)\n/**\n * native 方法，用于创建并返回当前对象的一份拷贝。\n */\nprotected native Object clone() throws CloneNotSupportedException\n/**\n * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\n */\npublic String toString()\n/**\n * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n */\npublic final native void notify()\n/**\n * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n */\npublic final native void notifyAll()\n/**\n * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\n */\npublic final native void wait(long timeout) throws InterruptedException\n/**\n * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。\n */\npublic final void wait(long timeout, int nanos) throws InterruptedException\n/**\n * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n */\npublic final void wait() throws InterruptedException\n/**\n * 实例被垃圾回收器回收的时候触发的操作\n */\nprotected void finalize() throws Throwable { }</code></pre></details>\n\nhashcode 和 equals 都是判断对象是否相同的方法\n\nhashcode 可能会碰撞，equals 是比较地址但效率较低\n\n重写equals也应当重写hashcode方法。\n\n### String StringBuffer StringBuilder 的区别\n\n* String 对象不可变，String a = \"test\";  a = \"test1\" 。更改a的值的时候，是创建了一个新的String对象，将地址赋给a。是线程安全的\n\n* StringBuffer 和 StringBuilder 更改值，不用新建对象。\n\n* StringBuffer 使用同步锁保证线程安全\n\n* StringBuilder 是线程不安全的，效率比StringBUffer快10%-15%\n\n### String拼接、赋值和intern方法\n\n* 在Java9之前，String 用加号连接的方法是使用StringBuilder.append().toString()方法构建的。在之后更新了方法，可以放心使用+连接，性能也不错\n* String s = new String(\"abc\"); 这段代码可能会创建 1-2 个字符串对象。 先在字符串常量池创建一个字符串对象abc（如果已存在则不需要再创建），然后复制一份到堆内存中。\n* String intern 方法：将引用保存到字符串常量池中（如果已有则不再保存），并且返回这个对象\n\n### 字符串常量池\n\n## 常用数据结构源码解析\n\n### hashmap\n\n* 底层是数组+链表+红黑树，非线程安全\n\n* 可存储null的key和value\n\n* 初始大小16，扩容到当前的二倍\n\n* 获取Key的方法：\n\n  * ```java\n    static final int hash(Object key) {\n      int h;\n      // key.hashCode()：返回散列值也就是hashcode\n      // ^：按位异或\n      // >>>:无符号右移，忽略符号位，空位都以0补齐\n      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n    ```\n\n* 元素添加：\n\n  * 获取数组的index：key对hashmap的length取模（将key和length-1与，比%取模的性能好）\n  * 如果这个index没有元素，直接添加\n  * 如果有元素则比较key，如果key相同则覆盖。\n  * 如果是hash碰撞，则判断是否是树节点，是就调用putTreeVal加入树节点，否则加入链表尾部\n\n* hash碰撞使用拉链法\n\n  * 在hash碰撞的节点创建一个链表，把碰撞的值都放在链表中\n  * 链表元素超过8个，将链表切换成红黑树\n\n* 扩容条件是存放的元素数量超过`容量*负载因子`\n\n  * 负载因子**loadFactor** 是控制数组存放数据的疏密程度\n    * loadFactor越趋近1，数组中存储的元素就越多，碰撞的元素在链表的长度就越多，查询性能下降\n    * loadFactor越趋近0，hashMap扩容次数增加，rehash消耗性能\n    * 官方给出的默认为0.75\n  * resize就是扩容之后重新计算index和hash碰撞\n    * 底层就是新开一个数组，将元素重新放入新数组\n\n### ArrayList\n\n* `ArrayList` 继承于 `AbstractList` ，实现了 `List`, `RandomAccess`, `Cloneable`, `java.io.Serializable` 这些接口。线程不安全。\n  * `List` : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。\n  * `RandomAccess` ：表明它可以快速进行随机访问，get(index)\n  * `Cloneable` ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。\n  * `Serializable` : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。\n\n* 可以添加null值。\n\n* 底层是Object数组。\n\n* 时间复杂度：add() O(1) ;   add(index,val) O(n) ;\n\n* 空间占用主要是末尾预留的空间。\n\n* 在添加大量元素的时候，可以提前使用ensureCapacity(N)方法预留空间，减少空间分配次数，节约性能。\n\n* 当添加元素大于容量的时候，触发扩容\n  * 扩容：每次newSize= oldSize+oldSize/2 相当于1.5倍\n\n### LinkedList\n\n* `LinkedList` 继承了 `AbstractSequentialList` ，而 `AbstractSequentialList` 又继承于 `AbstractList` 。\n* `LinkedList` 实现了`List`,`Deque`,`Cloneable`,`Seralizable`\n  * `Deque`：表明它具有双端队列特性，便于两端插入和删除\n* 底层是双向链表\n* 时间复杂度：add() O(1); add(index,val) O(n) \n* 空间占用主要是除了data之外的索引等数据\n* 遍历常用for-each\n* 基本上不用LinkedList，都用ArrayList，性能一般更好一些\n\n### ConcurrentHashMap\n\n## 并发编程\n\n### synchronized关键字的底层原理是什么\n\n2.1.1synchronized是做什么的\n\n**给线程加锁**，加锁目标是一个类或一个对象。\n\n2.1.2实现原理\n\n加锁指令：monitorenter（加锁） monitorexit（释放锁）\n\n一个对象或类关联有一个monitor（计数器：正在使用的线程数，**类似信号量**）\n\n### CAS的理解和底层实现原理\n\n多个线程要访问同一个数据会出现并发安全问题。\n\n`AtomicInterger`并发包的原子类，使用CAS实现。\n\n2.2.1线程操作AtomicInterger基本流程：\n\n线程1想要修改值，会\n\n* 先读取旧值\n* 在修改前再次读取这个值\n* 如果没人修改，则使用CAS进行修改这个值。\n* 如果第二次读取的值和旧值不同，则CAS失败。\n\n2.2.2CAS\n\nCAS：compare and set\n\n在硬件级别保是原子操作，同一时间只有一个线程可以执行CAS。\n\n### ConcurrentHashMap实现线程安全的底层原理\n\n2.3.1对hashmap简单的操作，不需要进行synchronized\n\n一般的操作都是hashmap底层数组的不同的元素进行操作，无需加锁\n\nConcurrentHashmap默认实现了线程安全。\n\n2.3.2在jdk1.7以及之前，对ConcurrentHashmap底层的数组分段加锁。\n\n**一段数组加一个锁**，如果操作的是不同不同段的数组，则不互相影响\n\n2.3.3在jdk1.8以及之后，不再数组分段，**对数组中每一个元素都加了一个锁**。\n\n将锁的粒度细化。\n\n### JDK中的AQS的实现原理\n\n`ReentrantLock `类底层是AQS（Abstract Queue Synchronizer）\n\n可以使用这个类生成一个锁lock，可以进行lock.lock() lock.unlock()实现互斥。\n\n2.4.1 AQS会有一个等待队列，存储没有得到锁的线程，待锁释放后，按顺序为等待队列的线程提供锁\n\n<img src=\"http://gohoy.top/i/2023/07/31/ui6crn-1.png\" alt=\"image-20230731160209376\" style=\"zoom:80%;\" />\n\n2.4.2如果在线程1执行完毕，唤醒线程2的过程中，如果有线程3想要加锁\n\n* 非公平锁：ReentrantLock lock = new ReentrantLock()；\n  * 线程3可能会成功得到锁，达到插队。\n* 公平锁：ReentrantLock lock = new ReentrantLock(true);\n  * 如果等待队列有线程，线程3会进入等待队列。\n\n### 线程池的底层工作原理\n\n2.5.1线程池：提供一定量的线程，线程执行完成任务后，不销毁自己，等待下一次任务：\n\n**避免重复创建和销毁线程，造成性能浪费**\n\n创建线程池：\n\n```java\nExecutorService threadPool = Executor.newFixedThreadPool(10)  //(corePoolSize = 10)\nthreadPool.submit(new Callable() {\n\tpublic void run(){}\n});\n```\n\n有新任务的时候\n\n* 如果线程池的线程数量小于容量，则直接创建一个新的线程执行任务。\n* 如果满了，则放在任务队列中。\n\n当线程完成自己的任务的时候，会去任务队列中获取任务，如果没有任务，会阻塞，不会销毁。\n\n###  线程池的核心配置参数\n\n代表线程池的类是ThreadPoolExecutor\n\n```java\nreturn new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>())\n```\n\n* `corePoolSize：3`\n  * 一般最大线程数只有3\n* `maximumPoolSize：200`\n  * 当任务队列满了，可以最多额外创建到200个，执行任务并从任务队列获取任务\n* `keepAliveTime：60s`\n  * 任务队列空了60s后，额外线程自动会销毁掉\n* `new ArrayBlockingQueue<Runnable>(200)`\n  * 任务队列\n\n如果额外线程也满了，会报异常。可以自定义RejectedExecutionHandler策略来应对这种情况：持久化被reject的任务，等负载低了再加载执行。\n\n### 如果在线程池中使用无界阻塞队列会发生什么问题\n\n#### 面试题1：如果使用无界阻塞队列调用远程服务，远程服务异常，会不会导致内存异常飙升\n\n调用超时，队列变得越来越大，内存会飙升，可能会导致OOM。\n\n### 线程池队列满了之后，会发生什么\n\n* 如果给maximumPoolSize设置太大，可能会导致系统崩溃。因为线程会占用一定内存，也会增加cpu负载。\n* 如果给maximumPoolSize设置太小，可能会导致任务reject。\n\n### 如果机器突然宕机，线程池的阻塞队列的任务怎么办\n\n**都会丢失**\n\n解决办法：在数据库对任务信息进行持久化。\n\n## 谈谈对Java内存模型的理解\n\n```java\npublic class HelloWorld {\n    private int data;\n    public void increment(){\n        data++;\n    }\n}\nHelloWorld helloWorld = new HelloWorld(); //对象存放在堆内存，包含对象中的实例变量\n//线程1\nnew Thread(){\n\tpublic void run(){\n        helloWorld.increment();\n    }\n}.start()\n//线程2\nnew Thread(){\n\tpublic void run(){\n        helloWorld.increment();\n    }\n}.start()\n   \n```\n\n常量：主存（内存）\n\n线程的工作内存：cpu缓存\n\n常量操作：read load use assign store write\n\n<img src=\"http://gohoy.top/i/2023/07/31/ui6jyh-1.png\" alt=\"image-20230731165920298\" style=\"zoom: 80%;\" />\n\n### 可见性、原子性、有序性\n\n* 可见性\n  * 没有可见性：线程1更新了数据，但是线程2看到的还是工作内存中旧的数据\n  * 有可见性：数据更新之后，线程1会强制使线程2重新读取修改后的数据。\n* 原子性\n  * 一次只有一个线程进入临界区。data++必须是独立执行的。\n* 有序性\n  * 在任务需要的资源准备完全之后，执行该线程任务。\n\n### 从底层角度聊volatile关键字原理\n\nvolatile：用来解决**可见性和有序性**，对原子性的保证很有限。（对64位的long型有一定原子性保证）\n\n* 实现可见性\n  * **当加上volatile的变量改变时，会使其他线程工作内存的过期变量失效。**\n* 保证有序性\n  * 保证写在读之前\n\n### 指令重排和happens-before原则\n\n指令重排有可能导致有序性失效。\n\nhappens-before原则：\n\n* 线程内按照代码顺序，写在前面的代码先行发生在卸载后面的代码。\n* 锁定操作：对锁的unlock操作先行发生在lock操作\n* volatile变量原则：写操作在读操作之前\n* 传递原则：A先于B，B先于C，则A先于C\n* 线程启动原则：线程的启动thread.star()先于线程中的其他操作。还有interrupt\n* 线程终结原则：线程的所有操作都先于线程的终止检测，使用thread.jion()结束。\n* 对象终结原则：一个对象的初始化完成在finalize()方法之前。\n\n### volatile底层如何基于内存屏障保证可见性和有序性\n\n对volatile的值的操作代码前后加上内存屏障。\n\n内存屏障：禁止重排序\n\n## Spring\n\n### Spring的IOC\n\n如果没有IOC：tomcat+servlet：tomcat 监听端口来将请求转发给servlet来处理，耦合严重，需要变动时，修改很麻烦。\n\nIOC：**依赖注入，控制反转，容器根据xml配置或者注解来对bean对象之间的引用关系进行依赖注入**\n\n底层核心技术：反射。根据类来自动构建对应的对象。\n\n类与类彻底解耦。\n\n![image-20230801142412643](http://gohoy.top/i/2023/08/01/njxvd8-1.png)\n\n\n\n###  Spring的AOP\n\nMySQL：事务：一次开启一个事务，其中进行多次增删改查。如果有一条失败了，会回滚事务，把这个事务中所有的sql语句都恢复。\n\nAOP:做一个切面Aspect，给所有类似servicexxx代码之前都会开启一个事务，在这些方法运行完毕之后，根据是否抛出异常，去回滚或者提交事务。\n\n核心技术：动态代理\n\n**Spring会给正在运行的类生成动态代理类，包含我们写的类。然后在代理类中给逻辑前后加上事务。**\n\n如何限定AOP。\n\nTODO\n\n### 了解过cglib动态代理吗，他和jdk动态代理的区别是什么\n\njdk动态代理，有接口的时候使用，生成一个实现这些同样接口的对象。\n\n没有接口会使用cglib来生成你的类的子类，覆盖你的类的方法，在方法中加入增强的代码。\n\n### spring事务的实现原理是什么，事务传播机制是什么\n\n不同事务之间不互相影响\n\n@Transactional(propagation = Propagation.REQUIRED)会开启一个事务\n\n* Propagation_REQUIRED：如果当前没有事务，创建一个事务，多个调用加入到一个事务中。\n* Propagation_SUPPORT：之前有事务则加入，没有则不开启。\n* Propagation_MANDATORY：有事务加入，没有则报错。\n* Propagation_RESQUIRES_NEW：强制开启一个新事务。\n* Propagation_NOT_SUPPORTED：不使用事务，有事务会挂起\n* Propagation_NEVER：不允许使用事务，有事务会报错\n* Propagation_NESTED：嵌套事务，外层事务回滚会导致内存事务也回滚，内层不影响外层。\n\n### Springboot 的核心架构\n\n自动装配依赖。不需要像spring一样自己配置xml文件，引入jar包。减少了配置。\n\n### Spring 核心源码\n\nSpring bean 生命周期：\n\n* 创建bean\n  * 实例化一个bean\n  * 依赖注入\n    * 把这个bean的依赖的bean实例化，也进行依赖注入。注入方法：构造函数，setter方法。\n  * 处理Aware接口\n    * 如果这个bean实现了Aware相关的接口，Spring容器会把自己的信息注入给bean中。\n  * BeanPostProcesser\n    * 在bean实例初始化之前和之后可以执行的方法。\n  * init初始化方法\n* 销毁\n  * DisposableBean接口，会调用这个接口实现的destroy方法\n  * 最后，如果配置了destroy-method方法，会调用这个方法\n\n### Spring中的设计模式\n\n工厂，单例，代理\n\n工厂模式：使用工厂类来创建类。\n\n单例模式：每个bean在系统运行期间只会创建一个实例对象。\n\n代理模式：AOP\n\n### SpringMVC架构\n\n* tomcat 监听端口，将请求转发给SpringMVC的DispathcherServlet\n* 然后SpringMVC再根据url将请求转发给对应的controller\n* 返回json给前端，前端符合渲染\n\n###  SpringCloud核心架构\n\n这些框架\n\n## JVM\n\n###  JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进\n\n* 栈内存：每个线程独有\n* 堆内存：存放对象、实例\n* 永久代区域：我们写的类\n\nJava8以后永久代变成metaspace\n\n常量区放在了堆里面\n\n### JVM如何运行起来的，如何创建各种对象\n\n**线程执行main函数同时创建对象**\n\nSpring容器创建一些bean对象\n\n\n\n把执行的方法和局部变量放在栈帧。\n\n###  JVM什么时候会触发垃圾回收\n\n内存分代：年轻代（eden：s1： s2，  8：1：1 ）和老年代\n\n年轻代和老年代统称为堆\n\n新生成的对象实例存放在年轻代。\n\n* ygc：Eden区满了。进行youngGC\n  * 没有引用的对象（类）被回收\n\n年轻代垃圾回收算法：\n\n* 复制算法：因为年轻代中大多数都是垃圾对象，所以把存活对象复制到s1中，一键全部清除Eden区。\n  * 把s1和Eden中的存活对象复制到s2，把s1和Eden区全部清除\n\n###  什么时候对象会转移到老年代\n\n如果存活了多次垃圾回收过程，就会转移到老年代\n\n如果s区放不下，会把一些存活的对象直接放到老年代中。\n\n对于大对象会直接放到老年代中，防止ygc反复复制大对象。\n\n### 常用的垃圾回收器，老年代如何回收\n\n老年代中大多数是长期存活的对象，所以使用标记-清理方法：把所有存活的对象压缩到连续的位置，然后统一清理，可以防止内存碎片问题。\n\n常用的垃圾回收器：\n\n* CMS+parnew jdk8-jdk9\n* g1 jdk11 \n* ZGC\n\n###  生产环境如何设置jvm参数的，如何检查jvm的运行情况\n\ntomcat的配置脚本，catalina脚本设置。\n\n如果使用jar启动，再java命令后直接加上参数\n\n参数：\n\n* 内存区域大小的分配：\n  * 栈大小\n  * metaspace大小\n  * eden  survivor\n  * 堆大小\n  * 年轻代、老年代\n* 垃圾回收器\n  * 年轻代和老年代用了什么回收器\n  * 是否有特殊参数，作用是什么\n\njstat压测，QPS,接口性能\n\n###  JVM GC优化\n\n自己动手进行压测，调试一下\n\n###  发生OOM之后，应该如何排查和处理线上系统的OOM问题\n\n在jvm设置参数，发生oom之后保存快照。\n\n找出占用内存最大的对象和创建它的代码，进行调优。\n\n## 网络\n\n###  TCP/IP的四层模型和七层网络模型\n\nTCP/IP四层：数据链路层、网络层、传输层、应用层\n\n* 物理层：硬件部分\n* 数据链路层：将0/1信号分组，确定来源去向\n  * 以太网协议：一组信号是一个网络帧。每帧有两个部分：表头和数据，表头保存说明性的东西，比如发送者，接收者，数据类型等。通过网卡来发送接收数据，mac地址是网卡的id。\n  * mac：前6个16进制是厂商编号，后6个编号是网卡流水号。\n* 网络层：\n  * IP协议\n  * 判断是不是一个子网：使用ip的二进制和子网掩码进行与运算，看结果前三个部分如果是一样的就是子网。\n  * 不在一个子网需要一个路由器，路由器判断数据包的目标mac是不是自己的子网内的mac，是则转发。\n  * ARP cache 会让每一个电脑都缓存到子网中所以电脑的ip和mac对应关系。\n  * 路由器就可以看做是一个网关\n* 传输层TCP协议：仅仅规定了基于端口的点对点通信协议，包含如何建立连接，读取和发送信息。要基于TCP 开发，实际上是使用socket开发。\n* 应用层：最常见的是http\n\nOSI七层：物理层、会话层、表示层 + 四层模型\n\nDNS：domain name server ，先通过dns服务器把域名翻译成IP。\n\n### 浏览器访问baidu.com会发生什么\n\n* 域名解析为IP\n* 把请求打包成http包\n* 把http数据包包装成tcp数据包，tcp数据头包含接收者和发送者的端口号\n* 然后把全部数据包包装到ip数据包，ip数据头中包含发送者和接收者的ip\n* 然后以太网会把这个数据包封装到以太网数据包中，加上以太网头，其中包含有发送者和接收者的网卡mac地址。\n  * 以太网一次传输字节有限，可能需要切割为多个包。\n  * 根据IP头序号来合成一个包。\n* 然后通过多个路由转发到百度的子网中。\n\n### TCP三次握手和四次挥手的流程，为什么不是五次或者两次？\n\n* 建立连接的三次握手：\n  * 客户端发送syn（同步），表示自己进入了syn_send状态\n  * 服务端恢复syn+ack（确认）表示确认收到同步请求，并且自己进入syn_recevie状态\n  * 客户端发送ack，表示确认建立连接。当服务端接收到这个包的时候，连接正式建立\n* 为什么不是两次握手\n  * 如果网络问题，遇到不想要的连接，三次连接可以让客户端发送给服务器复位信息，释放资源\n* 结束连接的四次挥手：\n  * 客户端发送FIN（结束）\n  * 服务端发送ACK（收到），这段时间有可能传输还没有完全完毕，等待全部完毕后再发送FIN。\n  * 服务端发送FIN（结束）\n  * 客户端发送ACK（收到）：服务端收到这个请求后立刻关闭，客户端会等待一段时间，保证服务端确实接收到这个包\n\n 2 3次挥手好像在某些情况可以合并？\n\n### 说一下http长连接的原理\n\n**http本身没有长连接，都是tcp的长连接和短链接**\n\nhttp协议规范：请求头，请求体什么的\n\nhttp1.0 都是短链接，一次请求后直接断开tcp连接，需要指定keep-alive才能建立长连接\n\nhttp1.1 默认是长连接\n\nhttp2.0支持多路复用，一个tcp可以并行发送多个请求以及接收响应。\n\nhttp3.0 QUIC 建立在udp之上。\n\n###  https http+ssl/tsl\n\n使用证书加密\n\n* 非对称加密：rsa\n  * 网站给浏览器发送证书（由权威机构颁发），浏览器验证合法性\n  * 浏览器生成随机密码，用随机密码加密随机密码的hash，并且用证书的公钥加密这个随机密码，\n  * 网站用证书的私钥解密这个随机面膜，再用随机密码解密得到hash，计算自己得到的密码的hash进行对比，如果完全相同，则可以使用\n  * 之后用这个随机密码来实现加密通信。\n\n## MySQL\n\n### 引擎：mysiam innodb\n\n* mysiam：不支持事务，不支持外键约束。索引和数据文件分开，可以在内存缓存更多索引，查询性能会更好，适用于少量插入，大量查询\n  * hadoop报表系统，用mysql mysiam比较适合，但是数据量太大超过500w以上就也不能用mysql了。\n* innodb（默认）：支持事务，外键约束，高并发，高可用，大数据量\n\n### Mysql索引原理和数据结构。\n\n索引：默认b+树\n\n* b-树\n  * 每个节点都存储对应的data\n* b+树\n  * 只有叶子节点存储对应的data\n\nMysiam的索引：叶子节点存储的是索引的物理地址。然后用物理地址去数据文件找数据。\n\nInnodb的索引：表要求必须要有主键，默认会为主键建立一个索引，节点data包含所有数据（一个记录，整行），叫做聚簇索引。如果你使用name来找数据，那么从name索引中找到的data是主键（id），再用id从聚簇索引找data。\n\n###  索引的使用规则\n\n怎么建立索引？\n\n**最左前缀匹配原则：**\n\n创建联合索引：create index(shop_id,product_id,gmt_create)\n\n如果你使用 shop_id 和 gmt_create来查找，那么不会直接通过这个联合索引查找，而是通过使用shop_id筛选出来一些数据，之后扫描gmt_create字段符合要求过滤。（性能也还行）。\n\n**但如果没有最左边的任何字段，就没法用这个索引**，比如直接通过product_id查找，这个是没有用到这个索引的。\n\n范围列匹配，最左前缀范围查找会用索引，之后的不会用索引了。\n\n调用了函数的sql语句不使用索引\n\n**建立尽量少的索引，10条以内为佳**\n\n**尽量选唯一字段进行建立索引**。选择的字段 去重后数量/总数量 ，结果要是小，则说明这个索引用处不大。\n\n### 事务的几个特点\n\n**ACID**\n\n* Atomic：原子性，同时执行的sql要么一起成功，要么一起失败\n* Consistency：一致性，事务之前前后数据都应该是正确的\n* Isolation：隔离性，多个事务之间不互相干扰\n* Durability：持久性\n\n### 隔离级别\n\n* 读未提交：事务A读取到事务B还没有提交的数据\n* 读已提交：事务A读取到原来的数据，然后事务B提交修改，事务A再次读取，读到不一样的数据。（不可重复读）\n* 可重复读：事务A读取到原来的数据，然后事务B提交修改，事务A再次读取，读到的还是事务A最开始读取到的数据。（可重复读）\n* 幻读（不是隔离级别）：事务A查询所有数据，准备插入一一条数据，事务B插入了一行数据，事务B提交插入。事务A想要插入数据，发现这个数据已经存在（被事务B插入）。\n* 串行化（为了解决幻读）：事务A查询所有数据，事务B想要插入一行数据会被拒绝。事务A提交后，事务B才能进行插入数据。\n\n**MySQL默认级别：可重复读。**\n\n**实现可重复读的机制**：MVCC机制 multi-version concurrency control\n\n* 事务id是全局唯一且递增的，\n\n* 查询事务只会找比自己事务id小的 创建事务。\n\n  * 创建事务id<=当前事务id\n\n  * 当前事务id<删除事务id\n\n* 不同事务修改某行数据，会多出来一行，id相同。\n\n### 数据库锁\n\n**自动加锁**\n\n表锁 行锁 页锁\n\n* myisam会加表锁。锁表的时候查询会报504\n\n行锁：innodb：共享锁（s）和排他锁（x）\n\n* 共享锁和排他锁不能同时加\n* select 不加锁因为MVCC有快照，增删改会加一个行锁排他锁。\n\n**手动加锁**\n\n加共享锁：select * from table where id = 1 lock in share mode\n\n加排他锁：select * from table where id =1 for update\n\n**悲观锁**：进行操作都加上排他锁\n\n**乐观锁**：加上版本号字段，在事务修改期间如果版本号不同，则这次修改失败，需要重新读取操作。\n\n**死锁**：dba查看死锁日志。\n\n### MySQL调优的常用手段\n\n* 保持sql简单，建议使用单表查询\n  * 优化索引\n  * 查看sql的执行计划：explain select * from table \n\n###  E-R图\n\nentities-relationship图\n\n关系：操作数是关系，重复行的对应关系（投影）要去掉。剩下的是关系：一对多，一对一，多对多等\n\n\n\n##  socket\n\n直接使用tcp进行通信，就是socket编程\n\n可以认为socket处于传输层。或者是介于传输层和应用层直接。\n\nsocket 就是封装了tcp的编程规范\n\n## 进程通信和线程切换\n\n### 进程通信\n\n9.1.1管道 pipe\n\n只有父子进程（fork得到的）才能使用这个管道进行通信。\n\n9.1.2命名管道\n\n无亲缘关系的管道可以使用命名管道通信\n\n9.1.3消息队列\n\n9.1.4共享内存\n\n### 线程如何切换\n\n时间片轮换\n\n优先级调度等\n\n## nio，bio，aio都是什么，有什么区别。nio的原理是什么\n\n### bio通信原理\n\n服务端使用ServerSocket为每一个客户端建立一个线程用于通信。只要客户端还和服务端有连接，这个线程都要等待。\n\n问题：超过几千客户端就不能够正常运行了\n\n###  nio通信原理\n\n每有一个客户端和服务端建立连接，都会创建一个channel，这些channel都会注册在selector中，这个selector只有一个线程。会不断轮询这些channel。，如果有请求过来，会创建一个线程来处理这个请求。处理完成后这个线程会被销毁。\n\n可以对处理请求的线程创建一个线程池。\n\n在工作线程和channel 直接可以维护一个cache\n\n工作线程从channel 中读取数据，给channel写数据，是同步的\n\n###  aio\n\n对nio有优化：工作进程从channel读数据的时候，会绑定一个buffer，让操作系统来完成读操作，读完了来通知这个线程。\n\n写的时候也是把写的过程交给操作系统。\n\n###  同步阻塞、同步非阻塞、异步非阻塞\n\nBIO是同步阻塞，针对的是对磁盘文件的io读写。读写过程中线程阻塞\n\nNIO是同步非阻塞，在操作系统读写数据的时候，线程可以做其他事情，但是也需要不断轮询判断读写完成了没有。\n\nAIO 是异步非阻塞，发起文件读写的操作之后，交给操作系统，操作系统执行完毕之后，会通知这个线程。\n\n###  BIO NIO AIO demo代码\n\nTOREAD\n\n## 线上服务器问题\n\n### 线上CPU占用100%，排查步骤：\n\n* top -c 输入P ，按照cpu进行排序\n* top -Hp pid ，可以看到这个进程的负载\n* 把线程pid换成16进制pidhex，如何使用jstack pid | grep pidhex -C5 --color 就可以定位到线程中哪行代码的cpu占用最高。\n\n### 如果线上进程kill不掉怎么办\n\nps aux 查看是否有僵尸进程 zombie\n\nps -ef  | grep 僵尸进程id ，得到父进程id\n\n然后kill 父进程之后kill子进程。\n\n### 磁盘马上占满了怎么办\n\n是否是日志占满空间了？\n\n经历：安装程序的时候提示根目录空间占用100%，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm -rf删除了这些日志/var/log/pcp/pmlogger/openEuler1/。\n\n关于pcp：\n\n- Performance Co-Pilot (`pcp`) 提供了支持系统级性能监控和管理的框架和服务。它为系统中的所有性能数据提供了统一的抽象，以及用于询问、检索和处理该数据的许多工具。 \t\n- 这些生成的log，在openeuler系统没有设置自动清理，导致了日志积累。 \t\n\nfind / -size+100M | xargs ls -lh  找大于100m的文件\n\n## Java语言特性\n\n### 参数传递\n\n* Java 中将实参传递给方法（或函数）的方式是 **值传递**：\n  - 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。\n  - 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本\n* 想要通过传值来修改原来的值\n  * 通过数组\n  * 通过类\n  * 或者其他可变的引用类型\n* 不可变的引用类型\n  * String\n  * Integer\n  * BigDecimal\n  * LocalDate、LocalTime、LocalDateTime、Duration，Period\n\n### 序列化\n\n* 序列化协议属于应用层或者传输层\n\n* 序列化的对象：实现Serializable 接口的类、实例变量的值、非静态成员变量\n\n* serialVersionUID：用来判断对象版本。手动设置这个变量可以解决对象版本兼容问题。\n\n* Kryo用来序列化Java代码性能高。\n\n  * ```java\n    import com.esotericsoftware.kryo.Kryo;\n    import com.esotericsoftware.kryo.io.Input;\n    import com.esotericsoftware.kryo.io.Output;\n    \n    import java.io.*;\n    \n    public class KryoSerializationExample {\n        public static void main(String[] args) {\n            // 创建 Kryo 对象\n            Kryo kryo = new Kryo();\n    \n            // 创建要序列化的对象\n            Person person = new Person(\"Alice\", 30);\n    \n            // 序列化\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            Output output = new Output(outputStream);\n            kryo.writeObject(output, person);\n            output.close();\n    \n            // 将序列化的数据保存到文件\n            try (FileOutputStream fileOutputStream = new FileOutputStream(\"person.dat\")) {\n                outputStream.writeTo(fileOutputStream);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n    \n            // 反序列化\n            try (FileInputStream fileInputStream = new FileInputStream(\"person.dat\")) {\n                // 创建 Kryo 输入流\n                Input input = new Input(fileInputStream);\n    \n                // 从输入流中反序列化对象\n                Person deserializedPerson = kryo.readObject(input, Person.class);\n                input.close();\n    \n                // 使用反序列化后的对象\n                System.out.println(\"姓名: \" + deserializedPerson.getName());\n                System.out.println(\"年龄: \" + deserializedPerson.getAge());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    ```\n\n### 泛型和通配符\n\n1. 泛型（Generics）：泛型允许在编译时指定类、接口或方法操作的数据类型，以提供类型安全和代码重用。通过使用泛型，可以在编译时捕获类型错误，并避免在运行时出现类型转换错误。\n   - 定义泛型类：使用 `<T>` 来表示类型参数，可以在类名后面声明一个泛型类型。例如：`class MyClass<T> { ... }`。\n   - 定义泛型方法：使用 `<T>` 来表示类型参数，可以在方法返回类型前声明一个泛型类型。例如：`<T> T myMethod(T obj) { ... }`。\n   - 约定\n     - `E`：表示集合中的元素类型。\n     - `K`：表示映射中的键类型。\n     - `V`：表示映射中的值类型。\n     - `T`：表示任意类型。\n     - `S`、`U`、`V`：用于表示第二、第三和第四类型参数。\n2. 类型通配符（Wildcard）：类型通配符用问号 `?` 表示，用于灵活处理不同类型的泛型对象。通配符可以用于泛型类、泛型方法和通配符限定。\n   - 通配符限定上界：`? extends Type`，表示泛型参数是 Type 类型或其子类。例如：`List<? extends Number>` 表示一个只能接受 Number 及其子类的 List。\n   - 通配符限定下界：`? super Type`，表示泛型参数是 Type 类型或其父类。例如：`List<? super Integer>` 表示一个只能接受 Integer 及其父类的 List。\n   - 无限制通配符：`?`，表示可以是任意类型。例如：`List<?>` 表示一个可以接受任意类型的 List。\n\n### 反射\n\n##### 基本操作\n\n```java\n//获取类\nClass<?> myClass = MyClass.class;\nClass<?> myClass = Class.forName(\"com.example.MyClass\");\n//获取构造函数\nConstructor<?> constructor = myClass.getDeclaredConstructor(parameterTypes);\n//创建对象\nObject myObject = constructor.newInstance(arguments);\n//获取方法\nMethod method = myClass.getDeclaredMethod(\"methodName\", parameterTypes);\n//调用方法\nmethod.invoke(myObject, arguments);\n//获取字段\nField field = myClass.getDeclaredField(\"fieldName\");\n//获取字段的值\nObject fieldValue = field.get(myObject);\n//设置字段的值\nfield.set(myObject, value);\n//对于私有方法或字段，可能需要使用setAccessible(true)来绕过访问限制。\n```\n\n### 代理模式\n\n##### 1.静态代理：\n\n就是把在调用类的前后在执行一些步骤。\n\n```java\npublic class SmsProxy implements SmsService {\n\n    private final SmsService smsService;\n\n    public SmsProxy(SmsService smsService) {\n        this.smsService = smsService;\n    }\n\n    @Override\n    public String send(String message) {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(\"before method send()\");\n        smsService.send(message);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(\"after method send()\");\n        return null;\n    }\n}\n\n```\n\n##### 2.动态代理\n\n**2.1JDK代理：在 Java 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心。**\n\n```java\n//调用proxy的方法newProxyInstance\nProxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),new DebugInvocationHandler(target));\n//DebugInvocationHandler 是自定义的proxy方法，需要实现InvocationHandler接口的invoke方法，实际上是调用了这里的invoke方法\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\npublic class DebugInvocationHandler implements InvocationHandler {\n    private final Object target;\n    public DebugInvocationHandler(Object target) {\n        this.target = target;\n    }\n    @Override\n    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        System.out.println(\"before Method\"+ method.getName());\n        Object result = method.invoke(target, objects);\n        System.out.println(\"after Method\"+ method.getName());\n        return result;\n    }\n}\n```\n\nJDK 动态代理有一个最致命的问题是其**只能代理实现了接口的类**。\n\n为了解决这个问题，我们可以用 CGLIB 动态代理机制。\n\n**2.2CGLIB代理**\n\n* 在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。\n\n* maven依赖：\n\n  * ```xml\n    <dependency>\n      <groupId>cglib</groupId>\n      <artifactId>cglib</artifactId>\n      <version>3.3.0</version>\n    </dependency>\n    ```\n\n* ```java\n  //代理工厂中生成一个 enhancer对象，这个对象拥有下列属性，其中DebugMethodInterceptor拦截器是自定义的最终执行的方法\n  public class CglibProxyFactory {\n      public static Object getProxy(Class<?> clazz){\n          Enhancer enhancer = new Enhancer();\n          enhancer.setClassLoader(clazz.getClassLoader());\n          enhancer.setSuperclass(clazz);\n          enhancer.setCallback(new DebugMethodInterceptor());\n          return enhancer.create();\n      }\n  }\n  //DebugMethodInterceptor 实现MethodInterceptor接口，重写intercept方法，这个方法相当于前面的invoke\n  public class DebugMethodInterceptor implements MethodInterceptor {\n      @Override\n      public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n          //调用方法之前，我们可以添加自己的操作\n          System.out.println(\"before method \" + method.getName());\n          Object object = methodProxy.invokeSuper(o, objects);\n          //调用方法之后，我们同样可以添加自己的操作\n          System.out.println(\"after method \" + method.getName());\n          return object;\n      }\n  }\n  \n  ```\n\n**2.3二者的区别**\n\njdk动态代理，有接口的时候使用，生成一个实现这些同样接口的对象。\n\n没有接口会使用cglib来生成你的类的子类，覆盖你的类的方法，在方法中加入增强的代码。\n\n###  BigDecimal常见方法\n\n我们在使用 `BigDecimal` 时，为了防止精度丢失，推荐使用它的`BigDecimal(String val)`构造方法或者 `BigDecimal.valueOf(double val)` 静态方法来创建对象。\n\n**使用BigDecimal(double val)会丢失精度**\n\n方法：\n\n* add：加\n* subtract：减\n* multiple：乘\n* divide：除\n  * 除的时候尽量使用三个参数的版本：指定保留规则RoundingMode \n* compareTo：`a.compareTo(b)` : 返回 -1 表示 `a` 小于 `b`，0 表示 `a` 等于 `b` ， 1 表示 `a` 大于 `b`。\n  * 比较不能使用equals，因为equals比较会同时比较精度，1.0和1.00不相同\n* setScale：保留小数\n\n工具类：\n\n<details><summary>点击查看代码</summary>\n <pre><code>\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n/**\n * 简化BigDecimal计算的小工具类\n */\npublic class BigDecimalUtil {\n    /**\n     * 默认除法运算精度\n     */\n    private static final int DEF_DIV_SCALE = 10;\n    private BigDecimalUtil() {\n    }\n    /**\n     * 提供精确的加法运算。\n     *\n     * @param v1 被加数\n     * @param v2 加数\n     * @return 两个参数的和\n     */\n    public static double add(double v1, double v2) {\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.add(b2).doubleValue();\n    }\n    /**\n     * 提供精确的减法运算。\n     *\n     * @param v1 被减数\n     * @param v2 减数\n     * @return 两个参数的差\n     */\n    public static double subtract(double v1, double v2) {\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.subtract(b2).doubleValue();\n    }\n    /**\n     * 提供精确的乘法运算。\n     *\n     * @param v1 被乘数\n     * @param v2 乘数\n     * @return 两个参数的积\n     */\n    public static double multiply(double v1, double v2) {\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.multiply(b2).doubleValue();\n    }\n    /**\n     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到\n     * 小数点以后10位，以后的数字四舍五入。\n     *\n     * @param v1 被除数\n     * @param v2 除数\n     * @return 两个参数的商\n     */\n    public static double divide(double v1, double v2) {\n        return divide(v1, v2, DEF_DIV_SCALE);\n    }\n    /**\n     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指\n     * 定精度，以后的数字四舍五入。\n     *\n     * @param v1    被除数\n     * @param v2    除数\n     * @param scale 表示表示需要精确到小数点以后几位。\n     * @return 两个参数的商\n     */\n    public static double divide(double v1, double v2, int scale) {\n        if (scale < 0) {\n            throw new IllegalArgumentException(\n                    \"The scale must be a positive integer or zero\");\n        }\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.divide(b2, scale, RoundingMode.HALF_EVEN).doubleValue();\n    }\n    /**\n     * 提供精确的小数位四舍五入处理。\n     *\n     * @param v     需要四舍五入的数字\n     * @param scale 小数点后保留几位\n     * @return 四舍五入后的结果\n     */\n    public static double round(double v, int scale) {\n        if (scale < 0) {\n            throw new IllegalArgumentException(\n                    \"The scale must be a positive integer or zero\");\n        }\n        BigDecimal b = BigDecimal.valueOf(v);\n        BigDecimal one = new BigDecimal(\"1\");\n        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();\n    }\n    /**\n     * 提供精确的类型转换(Float)\n     *\n     * @param v 需要被转换的数字\n     * @return 返回转换结果\n     */\n    public static float convertToFloat(double v) {\n        BigDecimal b = new BigDecimal(v);\n        return b.floatValue();\n    }\n    /**\n     * 提供精确的类型转换(Int)不进行四舍五入\n     *\n     * @param v 需要被转换的数字\n     * @return 返回转换结果\n     */\n    public static int convertsToInt(double v) {\n        BigDecimal b = new BigDecimal(v);\n        return b.intValue();\n    }\n    /**\n     * 提供精确的类型转换(Long)\n     *\n     * @param v 需要被转换的数字\n     * @return 返回转换结果\n     */\n    public static long convertsToLong(double v) {\n        BigDecimal b = new BigDecimal(v);\n        return b.longValue();\n    }\n    /**\n     * 返回两个数中大的一个值\n     *\n     * @param v1 需要被对比的第一个数\n     * @param v2 需要被对比的第二个数\n     * @return 返回两个数中大的一个值\n     */\n    public static double returnMax(double v1, double v2) {\n        BigDecimal b1 = new BigDecimal(v1);\n        BigDecimal b2 = new BigDecimal(v2);\n        return b1.max(b2).doubleValue();\n    }\n    /**\n     * 返回两个数中小的一个值\n     *\n     * @param v1 需要被对比的第一个数\n     * @param v2 需要被对比的第二个数\n     * @return 返回两个数中小的一个值\n     */\n    public static double returnMin(double v1, double v2) {\n        BigDecimal b1 = new BigDecimal(v1);\n        BigDecimal b2 = new BigDecimal(v2);\n        return b1.min(b2).doubleValue();\n    }\n    /**\n     * 精确对比两个数字\n     *\n     * @param v1 需要被对比的第一个数\n     * @param v2 需要被对比的第二个数\n     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1\n     */\n    public static int compareTo(double v1, double v2) {\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.compareTo(b2);\n    }\n}\n    </code></pre>\n</details>\n\n###  [Unsafe类](https://javaguide.cn/java/basis/unsafe.html)\n\n在JUC高并发编程中主要使用，用来执行本地方法（native方法）。\n\nnative方法的执行绕过了Java本身的界限。能直接接触到操作系统底层的某些功能，因此并不安全。\n\n可以实现的功能：\n\n1. 内存操作\n2. 内存屏障\n3. 对象操作\n4. 数据操作\n5. CAS 操作\n6. 线程调度\n7. Class 操作\n8. 系统信息\n\n因为其不安全性，并不推荐使用。\n\n### SPI机制\n\n### 语法糖\n\n\n\n\n\n\n\n\n\n","source":"_posts/面经.md","raw":"---\ntitle: Java面经记录\ncategory: Java\ntag: \n - Java\n - 面经\n - 八股文\n---\n\n# 面经\n\n## Java基础知识\n\n### 为什么说Java是编译和解释的语言\n\nJava需要把代码编译成.class的字节码文件，然后再解释成机器码。\n\n### 静态方法中为什么不能调用非静态方法\n\n因为静态方法在类创建的时候生成，非静态方法在实例化对象之后才生成。\n\n### 重载和重写\n\n重载：同方法名，不同参数\n\n重写：子类重写父类的方法，方法名参数相同，构造方法无法重写\n\n### 可变长参数public void test(String ...args)\n\n可以接收不同长度的参数，重载的时候优先匹配固定长度参数的方法。\n\n### 对象实体和对象引用\n\nnew 来创建一个对象实体，一个对象实体可以有多个对象引用。一个对象引用可以指向一个对象实体。\n\n对象实体存在堆内存中（类和对象都存放在堆内存中）\n\n对象引用存放在栈内存中\n\n### 对象默认有无参构造，但创建有参构造后要手动创建无参构造。\n\n### 多态\n\n子类在调用父类的方法的时候，只有在运行的时候，才知道调用的是哪个方法（父类的还是子类的），这个方法具有多态性\n\n### 接口和抽象类的区别\n\n* 相同点：\n  * 都不能被实例化\n  * 都可以包含抽象方法\n  * 都可以有默认实现的方法，接口中可以定义default方法来实现\n* 不同点\n  * 接口主要是对对象的约束，约束对象的行为（实现接口的方法）\n  * 抽象类主要是代码的复用性的规定\n  * 一个类只可以继承一个类，但可以实现多个接口\n  * 接口中 的成员变量只能是public static final 类型，有初值，不可变\n  * 抽象类中的成员变量默认为default，可在子类中重新定义和赋值\n\n### 深拷贝和浅拷贝\n\n浅拷贝：在对上创建一个新对象，如果被拷贝的是引用类型，则会直接复制它引用的地址\n\n深拷贝：复制整个对象，包含内部对象\n\n### Object 的常用方法\n\n<details><summary>点击展开代码</summary><pre><code>/**\n * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\n */\npublic final native Class<?> getClass()\n/**\n * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\n */\npublic native int hashCode()\n/**\n * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\n */\npublic boolean equals(Object obj)\n/**\n * native 方法，用于创建并返回当前对象的一份拷贝。\n */\nprotected native Object clone() throws CloneNotSupportedException\n/**\n * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\n */\npublic String toString()\n/**\n * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n */\npublic final native void notify()\n/**\n * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n */\npublic final native void notifyAll()\n/**\n * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\n */\npublic final native void wait(long timeout) throws InterruptedException\n/**\n * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。\n */\npublic final void wait(long timeout, int nanos) throws InterruptedException\n/**\n * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n */\npublic final void wait() throws InterruptedException\n/**\n * 实例被垃圾回收器回收的时候触发的操作\n */\nprotected void finalize() throws Throwable { }</code></pre></details>\n\nhashcode 和 equals 都是判断对象是否相同的方法\n\nhashcode 可能会碰撞，equals 是比较地址但效率较低\n\n重写equals也应当重写hashcode方法。\n\n### String StringBuffer StringBuilder 的区别\n\n* String 对象不可变，String a = \"test\";  a = \"test1\" 。更改a的值的时候，是创建了一个新的String对象，将地址赋给a。是线程安全的\n\n* StringBuffer 和 StringBuilder 更改值，不用新建对象。\n\n* StringBuffer 使用同步锁保证线程安全\n\n* StringBuilder 是线程不安全的，效率比StringBUffer快10%-15%\n\n### String拼接、赋值和intern方法\n\n* 在Java9之前，String 用加号连接的方法是使用StringBuilder.append().toString()方法构建的。在之后更新了方法，可以放心使用+连接，性能也不错\n* String s = new String(\"abc\"); 这段代码可能会创建 1-2 个字符串对象。 先在字符串常量池创建一个字符串对象abc（如果已存在则不需要再创建），然后复制一份到堆内存中。\n* String intern 方法：将引用保存到字符串常量池中（如果已有则不再保存），并且返回这个对象\n\n### 字符串常量池\n\n## 常用数据结构源码解析\n\n### hashmap\n\n* 底层是数组+链表+红黑树，非线程安全\n\n* 可存储null的key和value\n\n* 初始大小16，扩容到当前的二倍\n\n* 获取Key的方法：\n\n  * ```java\n    static final int hash(Object key) {\n      int h;\n      // key.hashCode()：返回散列值也就是hashcode\n      // ^：按位异或\n      // >>>:无符号右移，忽略符号位，空位都以0补齐\n      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n    ```\n\n* 元素添加：\n\n  * 获取数组的index：key对hashmap的length取模（将key和length-1与，比%取模的性能好）\n  * 如果这个index没有元素，直接添加\n  * 如果有元素则比较key，如果key相同则覆盖。\n  * 如果是hash碰撞，则判断是否是树节点，是就调用putTreeVal加入树节点，否则加入链表尾部\n\n* hash碰撞使用拉链法\n\n  * 在hash碰撞的节点创建一个链表，把碰撞的值都放在链表中\n  * 链表元素超过8个，将链表切换成红黑树\n\n* 扩容条件是存放的元素数量超过`容量*负载因子`\n\n  * 负载因子**loadFactor** 是控制数组存放数据的疏密程度\n    * loadFactor越趋近1，数组中存储的元素就越多，碰撞的元素在链表的长度就越多，查询性能下降\n    * loadFactor越趋近0，hashMap扩容次数增加，rehash消耗性能\n    * 官方给出的默认为0.75\n  * resize就是扩容之后重新计算index和hash碰撞\n    * 底层就是新开一个数组，将元素重新放入新数组\n\n### ArrayList\n\n* `ArrayList` 继承于 `AbstractList` ，实现了 `List`, `RandomAccess`, `Cloneable`, `java.io.Serializable` 这些接口。线程不安全。\n  * `List` : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。\n  * `RandomAccess` ：表明它可以快速进行随机访问，get(index)\n  * `Cloneable` ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。\n  * `Serializable` : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。\n\n* 可以添加null值。\n\n* 底层是Object数组。\n\n* 时间复杂度：add() O(1) ;   add(index,val) O(n) ;\n\n* 空间占用主要是末尾预留的空间。\n\n* 在添加大量元素的时候，可以提前使用ensureCapacity(N)方法预留空间，减少空间分配次数，节约性能。\n\n* 当添加元素大于容量的时候，触发扩容\n  * 扩容：每次newSize= oldSize+oldSize/2 相当于1.5倍\n\n### LinkedList\n\n* `LinkedList` 继承了 `AbstractSequentialList` ，而 `AbstractSequentialList` 又继承于 `AbstractList` 。\n* `LinkedList` 实现了`List`,`Deque`,`Cloneable`,`Seralizable`\n  * `Deque`：表明它具有双端队列特性，便于两端插入和删除\n* 底层是双向链表\n* 时间复杂度：add() O(1); add(index,val) O(n) \n* 空间占用主要是除了data之外的索引等数据\n* 遍历常用for-each\n* 基本上不用LinkedList，都用ArrayList，性能一般更好一些\n\n### ConcurrentHashMap\n\n## 并发编程\n\n### synchronized关键字的底层原理是什么\n\n2.1.1synchronized是做什么的\n\n**给线程加锁**，加锁目标是一个类或一个对象。\n\n2.1.2实现原理\n\n加锁指令：monitorenter（加锁） monitorexit（释放锁）\n\n一个对象或类关联有一个monitor（计数器：正在使用的线程数，**类似信号量**）\n\n### CAS的理解和底层实现原理\n\n多个线程要访问同一个数据会出现并发安全问题。\n\n`AtomicInterger`并发包的原子类，使用CAS实现。\n\n2.2.1线程操作AtomicInterger基本流程：\n\n线程1想要修改值，会\n\n* 先读取旧值\n* 在修改前再次读取这个值\n* 如果没人修改，则使用CAS进行修改这个值。\n* 如果第二次读取的值和旧值不同，则CAS失败。\n\n2.2.2CAS\n\nCAS：compare and set\n\n在硬件级别保是原子操作，同一时间只有一个线程可以执行CAS。\n\n### ConcurrentHashMap实现线程安全的底层原理\n\n2.3.1对hashmap简单的操作，不需要进行synchronized\n\n一般的操作都是hashmap底层数组的不同的元素进行操作，无需加锁\n\nConcurrentHashmap默认实现了线程安全。\n\n2.3.2在jdk1.7以及之前，对ConcurrentHashmap底层的数组分段加锁。\n\n**一段数组加一个锁**，如果操作的是不同不同段的数组，则不互相影响\n\n2.3.3在jdk1.8以及之后，不再数组分段，**对数组中每一个元素都加了一个锁**。\n\n将锁的粒度细化。\n\n### JDK中的AQS的实现原理\n\n`ReentrantLock `类底层是AQS（Abstract Queue Synchronizer）\n\n可以使用这个类生成一个锁lock，可以进行lock.lock() lock.unlock()实现互斥。\n\n2.4.1 AQS会有一个等待队列，存储没有得到锁的线程，待锁释放后，按顺序为等待队列的线程提供锁\n\n<img src=\"http://gohoy.top/i/2023/07/31/ui6crn-1.png\" alt=\"image-20230731160209376\" style=\"zoom:80%;\" />\n\n2.4.2如果在线程1执行完毕，唤醒线程2的过程中，如果有线程3想要加锁\n\n* 非公平锁：ReentrantLock lock = new ReentrantLock()；\n  * 线程3可能会成功得到锁，达到插队。\n* 公平锁：ReentrantLock lock = new ReentrantLock(true);\n  * 如果等待队列有线程，线程3会进入等待队列。\n\n### 线程池的底层工作原理\n\n2.5.1线程池：提供一定量的线程，线程执行完成任务后，不销毁自己，等待下一次任务：\n\n**避免重复创建和销毁线程，造成性能浪费**\n\n创建线程池：\n\n```java\nExecutorService threadPool = Executor.newFixedThreadPool(10)  //(corePoolSize = 10)\nthreadPool.submit(new Callable() {\n\tpublic void run(){}\n});\n```\n\n有新任务的时候\n\n* 如果线程池的线程数量小于容量，则直接创建一个新的线程执行任务。\n* 如果满了，则放在任务队列中。\n\n当线程完成自己的任务的时候，会去任务队列中获取任务，如果没有任务，会阻塞，不会销毁。\n\n###  线程池的核心配置参数\n\n代表线程池的类是ThreadPoolExecutor\n\n```java\nreturn new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>())\n```\n\n* `corePoolSize：3`\n  * 一般最大线程数只有3\n* `maximumPoolSize：200`\n  * 当任务队列满了，可以最多额外创建到200个，执行任务并从任务队列获取任务\n* `keepAliveTime：60s`\n  * 任务队列空了60s后，额外线程自动会销毁掉\n* `new ArrayBlockingQueue<Runnable>(200)`\n  * 任务队列\n\n如果额外线程也满了，会报异常。可以自定义RejectedExecutionHandler策略来应对这种情况：持久化被reject的任务，等负载低了再加载执行。\n\n### 如果在线程池中使用无界阻塞队列会发生什么问题\n\n#### 面试题1：如果使用无界阻塞队列调用远程服务，远程服务异常，会不会导致内存异常飙升\n\n调用超时，队列变得越来越大，内存会飙升，可能会导致OOM。\n\n### 线程池队列满了之后，会发生什么\n\n* 如果给maximumPoolSize设置太大，可能会导致系统崩溃。因为线程会占用一定内存，也会增加cpu负载。\n* 如果给maximumPoolSize设置太小，可能会导致任务reject。\n\n### 如果机器突然宕机，线程池的阻塞队列的任务怎么办\n\n**都会丢失**\n\n解决办法：在数据库对任务信息进行持久化。\n\n## 谈谈对Java内存模型的理解\n\n```java\npublic class HelloWorld {\n    private int data;\n    public void increment(){\n        data++;\n    }\n}\nHelloWorld helloWorld = new HelloWorld(); //对象存放在堆内存，包含对象中的实例变量\n//线程1\nnew Thread(){\n\tpublic void run(){\n        helloWorld.increment();\n    }\n}.start()\n//线程2\nnew Thread(){\n\tpublic void run(){\n        helloWorld.increment();\n    }\n}.start()\n   \n```\n\n常量：主存（内存）\n\n线程的工作内存：cpu缓存\n\n常量操作：read load use assign store write\n\n<img src=\"http://gohoy.top/i/2023/07/31/ui6jyh-1.png\" alt=\"image-20230731165920298\" style=\"zoom: 80%;\" />\n\n### 可见性、原子性、有序性\n\n* 可见性\n  * 没有可见性：线程1更新了数据，但是线程2看到的还是工作内存中旧的数据\n  * 有可见性：数据更新之后，线程1会强制使线程2重新读取修改后的数据。\n* 原子性\n  * 一次只有一个线程进入临界区。data++必须是独立执行的。\n* 有序性\n  * 在任务需要的资源准备完全之后，执行该线程任务。\n\n### 从底层角度聊volatile关键字原理\n\nvolatile：用来解决**可见性和有序性**，对原子性的保证很有限。（对64位的long型有一定原子性保证）\n\n* 实现可见性\n  * **当加上volatile的变量改变时，会使其他线程工作内存的过期变量失效。**\n* 保证有序性\n  * 保证写在读之前\n\n### 指令重排和happens-before原则\n\n指令重排有可能导致有序性失效。\n\nhappens-before原则：\n\n* 线程内按照代码顺序，写在前面的代码先行发生在卸载后面的代码。\n* 锁定操作：对锁的unlock操作先行发生在lock操作\n* volatile变量原则：写操作在读操作之前\n* 传递原则：A先于B，B先于C，则A先于C\n* 线程启动原则：线程的启动thread.star()先于线程中的其他操作。还有interrupt\n* 线程终结原则：线程的所有操作都先于线程的终止检测，使用thread.jion()结束。\n* 对象终结原则：一个对象的初始化完成在finalize()方法之前。\n\n### volatile底层如何基于内存屏障保证可见性和有序性\n\n对volatile的值的操作代码前后加上内存屏障。\n\n内存屏障：禁止重排序\n\n## Spring\n\n### Spring的IOC\n\n如果没有IOC：tomcat+servlet：tomcat 监听端口来将请求转发给servlet来处理，耦合严重，需要变动时，修改很麻烦。\n\nIOC：**依赖注入，控制反转，容器根据xml配置或者注解来对bean对象之间的引用关系进行依赖注入**\n\n底层核心技术：反射。根据类来自动构建对应的对象。\n\n类与类彻底解耦。\n\n![image-20230801142412643](http://gohoy.top/i/2023/08/01/njxvd8-1.png)\n\n\n\n###  Spring的AOP\n\nMySQL：事务：一次开启一个事务，其中进行多次增删改查。如果有一条失败了，会回滚事务，把这个事务中所有的sql语句都恢复。\n\nAOP:做一个切面Aspect，给所有类似servicexxx代码之前都会开启一个事务，在这些方法运行完毕之后，根据是否抛出异常，去回滚或者提交事务。\n\n核心技术：动态代理\n\n**Spring会给正在运行的类生成动态代理类，包含我们写的类。然后在代理类中给逻辑前后加上事务。**\n\n如何限定AOP。\n\nTODO\n\n### 了解过cglib动态代理吗，他和jdk动态代理的区别是什么\n\njdk动态代理，有接口的时候使用，生成一个实现这些同样接口的对象。\n\n没有接口会使用cglib来生成你的类的子类，覆盖你的类的方法，在方法中加入增强的代码。\n\n### spring事务的实现原理是什么，事务传播机制是什么\n\n不同事务之间不互相影响\n\n@Transactional(propagation = Propagation.REQUIRED)会开启一个事务\n\n* Propagation_REQUIRED：如果当前没有事务，创建一个事务，多个调用加入到一个事务中。\n* Propagation_SUPPORT：之前有事务则加入，没有则不开启。\n* Propagation_MANDATORY：有事务加入，没有则报错。\n* Propagation_RESQUIRES_NEW：强制开启一个新事务。\n* Propagation_NOT_SUPPORTED：不使用事务，有事务会挂起\n* Propagation_NEVER：不允许使用事务，有事务会报错\n* Propagation_NESTED：嵌套事务，外层事务回滚会导致内存事务也回滚，内层不影响外层。\n\n### Springboot 的核心架构\n\n自动装配依赖。不需要像spring一样自己配置xml文件，引入jar包。减少了配置。\n\n### Spring 核心源码\n\nSpring bean 生命周期：\n\n* 创建bean\n  * 实例化一个bean\n  * 依赖注入\n    * 把这个bean的依赖的bean实例化，也进行依赖注入。注入方法：构造函数，setter方法。\n  * 处理Aware接口\n    * 如果这个bean实现了Aware相关的接口，Spring容器会把自己的信息注入给bean中。\n  * BeanPostProcesser\n    * 在bean实例初始化之前和之后可以执行的方法。\n  * init初始化方法\n* 销毁\n  * DisposableBean接口，会调用这个接口实现的destroy方法\n  * 最后，如果配置了destroy-method方法，会调用这个方法\n\n### Spring中的设计模式\n\n工厂，单例，代理\n\n工厂模式：使用工厂类来创建类。\n\n单例模式：每个bean在系统运行期间只会创建一个实例对象。\n\n代理模式：AOP\n\n### SpringMVC架构\n\n* tomcat 监听端口，将请求转发给SpringMVC的DispathcherServlet\n* 然后SpringMVC再根据url将请求转发给对应的controller\n* 返回json给前端，前端符合渲染\n\n###  SpringCloud核心架构\n\n这些框架\n\n## JVM\n\n###  JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进\n\n* 栈内存：每个线程独有\n* 堆内存：存放对象、实例\n* 永久代区域：我们写的类\n\nJava8以后永久代变成metaspace\n\n常量区放在了堆里面\n\n### JVM如何运行起来的，如何创建各种对象\n\n**线程执行main函数同时创建对象**\n\nSpring容器创建一些bean对象\n\n\n\n把执行的方法和局部变量放在栈帧。\n\n###  JVM什么时候会触发垃圾回收\n\n内存分代：年轻代（eden：s1： s2，  8：1：1 ）和老年代\n\n年轻代和老年代统称为堆\n\n新生成的对象实例存放在年轻代。\n\n* ygc：Eden区满了。进行youngGC\n  * 没有引用的对象（类）被回收\n\n年轻代垃圾回收算法：\n\n* 复制算法：因为年轻代中大多数都是垃圾对象，所以把存活对象复制到s1中，一键全部清除Eden区。\n  * 把s1和Eden中的存活对象复制到s2，把s1和Eden区全部清除\n\n###  什么时候对象会转移到老年代\n\n如果存活了多次垃圾回收过程，就会转移到老年代\n\n如果s区放不下，会把一些存活的对象直接放到老年代中。\n\n对于大对象会直接放到老年代中，防止ygc反复复制大对象。\n\n### 常用的垃圾回收器，老年代如何回收\n\n老年代中大多数是长期存活的对象，所以使用标记-清理方法：把所有存活的对象压缩到连续的位置，然后统一清理，可以防止内存碎片问题。\n\n常用的垃圾回收器：\n\n* CMS+parnew jdk8-jdk9\n* g1 jdk11 \n* ZGC\n\n###  生产环境如何设置jvm参数的，如何检查jvm的运行情况\n\ntomcat的配置脚本，catalina脚本设置。\n\n如果使用jar启动，再java命令后直接加上参数\n\n参数：\n\n* 内存区域大小的分配：\n  * 栈大小\n  * metaspace大小\n  * eden  survivor\n  * 堆大小\n  * 年轻代、老年代\n* 垃圾回收器\n  * 年轻代和老年代用了什么回收器\n  * 是否有特殊参数，作用是什么\n\njstat压测，QPS,接口性能\n\n###  JVM GC优化\n\n自己动手进行压测，调试一下\n\n###  发生OOM之后，应该如何排查和处理线上系统的OOM问题\n\n在jvm设置参数，发生oom之后保存快照。\n\n找出占用内存最大的对象和创建它的代码，进行调优。\n\n## 网络\n\n###  TCP/IP的四层模型和七层网络模型\n\nTCP/IP四层：数据链路层、网络层、传输层、应用层\n\n* 物理层：硬件部分\n* 数据链路层：将0/1信号分组，确定来源去向\n  * 以太网协议：一组信号是一个网络帧。每帧有两个部分：表头和数据，表头保存说明性的东西，比如发送者，接收者，数据类型等。通过网卡来发送接收数据，mac地址是网卡的id。\n  * mac：前6个16进制是厂商编号，后6个编号是网卡流水号。\n* 网络层：\n  * IP协议\n  * 判断是不是一个子网：使用ip的二进制和子网掩码进行与运算，看结果前三个部分如果是一样的就是子网。\n  * 不在一个子网需要一个路由器，路由器判断数据包的目标mac是不是自己的子网内的mac，是则转发。\n  * ARP cache 会让每一个电脑都缓存到子网中所以电脑的ip和mac对应关系。\n  * 路由器就可以看做是一个网关\n* 传输层TCP协议：仅仅规定了基于端口的点对点通信协议，包含如何建立连接，读取和发送信息。要基于TCP 开发，实际上是使用socket开发。\n* 应用层：最常见的是http\n\nOSI七层：物理层、会话层、表示层 + 四层模型\n\nDNS：domain name server ，先通过dns服务器把域名翻译成IP。\n\n### 浏览器访问baidu.com会发生什么\n\n* 域名解析为IP\n* 把请求打包成http包\n* 把http数据包包装成tcp数据包，tcp数据头包含接收者和发送者的端口号\n* 然后把全部数据包包装到ip数据包，ip数据头中包含发送者和接收者的ip\n* 然后以太网会把这个数据包封装到以太网数据包中，加上以太网头，其中包含有发送者和接收者的网卡mac地址。\n  * 以太网一次传输字节有限，可能需要切割为多个包。\n  * 根据IP头序号来合成一个包。\n* 然后通过多个路由转发到百度的子网中。\n\n### TCP三次握手和四次挥手的流程，为什么不是五次或者两次？\n\n* 建立连接的三次握手：\n  * 客户端发送syn（同步），表示自己进入了syn_send状态\n  * 服务端恢复syn+ack（确认）表示确认收到同步请求，并且自己进入syn_recevie状态\n  * 客户端发送ack，表示确认建立连接。当服务端接收到这个包的时候，连接正式建立\n* 为什么不是两次握手\n  * 如果网络问题，遇到不想要的连接，三次连接可以让客户端发送给服务器复位信息，释放资源\n* 结束连接的四次挥手：\n  * 客户端发送FIN（结束）\n  * 服务端发送ACK（收到），这段时间有可能传输还没有完全完毕，等待全部完毕后再发送FIN。\n  * 服务端发送FIN（结束）\n  * 客户端发送ACK（收到）：服务端收到这个请求后立刻关闭，客户端会等待一段时间，保证服务端确实接收到这个包\n\n 2 3次挥手好像在某些情况可以合并？\n\n### 说一下http长连接的原理\n\n**http本身没有长连接，都是tcp的长连接和短链接**\n\nhttp协议规范：请求头，请求体什么的\n\nhttp1.0 都是短链接，一次请求后直接断开tcp连接，需要指定keep-alive才能建立长连接\n\nhttp1.1 默认是长连接\n\nhttp2.0支持多路复用，一个tcp可以并行发送多个请求以及接收响应。\n\nhttp3.0 QUIC 建立在udp之上。\n\n###  https http+ssl/tsl\n\n使用证书加密\n\n* 非对称加密：rsa\n  * 网站给浏览器发送证书（由权威机构颁发），浏览器验证合法性\n  * 浏览器生成随机密码，用随机密码加密随机密码的hash，并且用证书的公钥加密这个随机密码，\n  * 网站用证书的私钥解密这个随机面膜，再用随机密码解密得到hash，计算自己得到的密码的hash进行对比，如果完全相同，则可以使用\n  * 之后用这个随机密码来实现加密通信。\n\n## MySQL\n\n### 引擎：mysiam innodb\n\n* mysiam：不支持事务，不支持外键约束。索引和数据文件分开，可以在内存缓存更多索引，查询性能会更好，适用于少量插入，大量查询\n  * hadoop报表系统，用mysql mysiam比较适合，但是数据量太大超过500w以上就也不能用mysql了。\n* innodb（默认）：支持事务，外键约束，高并发，高可用，大数据量\n\n### Mysql索引原理和数据结构。\n\n索引：默认b+树\n\n* b-树\n  * 每个节点都存储对应的data\n* b+树\n  * 只有叶子节点存储对应的data\n\nMysiam的索引：叶子节点存储的是索引的物理地址。然后用物理地址去数据文件找数据。\n\nInnodb的索引：表要求必须要有主键，默认会为主键建立一个索引，节点data包含所有数据（一个记录，整行），叫做聚簇索引。如果你使用name来找数据，那么从name索引中找到的data是主键（id），再用id从聚簇索引找data。\n\n###  索引的使用规则\n\n怎么建立索引？\n\n**最左前缀匹配原则：**\n\n创建联合索引：create index(shop_id,product_id,gmt_create)\n\n如果你使用 shop_id 和 gmt_create来查找，那么不会直接通过这个联合索引查找，而是通过使用shop_id筛选出来一些数据，之后扫描gmt_create字段符合要求过滤。（性能也还行）。\n\n**但如果没有最左边的任何字段，就没法用这个索引**，比如直接通过product_id查找，这个是没有用到这个索引的。\n\n范围列匹配，最左前缀范围查找会用索引，之后的不会用索引了。\n\n调用了函数的sql语句不使用索引\n\n**建立尽量少的索引，10条以内为佳**\n\n**尽量选唯一字段进行建立索引**。选择的字段 去重后数量/总数量 ，结果要是小，则说明这个索引用处不大。\n\n### 事务的几个特点\n\n**ACID**\n\n* Atomic：原子性，同时执行的sql要么一起成功，要么一起失败\n* Consistency：一致性，事务之前前后数据都应该是正确的\n* Isolation：隔离性，多个事务之间不互相干扰\n* Durability：持久性\n\n### 隔离级别\n\n* 读未提交：事务A读取到事务B还没有提交的数据\n* 读已提交：事务A读取到原来的数据，然后事务B提交修改，事务A再次读取，读到不一样的数据。（不可重复读）\n* 可重复读：事务A读取到原来的数据，然后事务B提交修改，事务A再次读取，读到的还是事务A最开始读取到的数据。（可重复读）\n* 幻读（不是隔离级别）：事务A查询所有数据，准备插入一一条数据，事务B插入了一行数据，事务B提交插入。事务A想要插入数据，发现这个数据已经存在（被事务B插入）。\n* 串行化（为了解决幻读）：事务A查询所有数据，事务B想要插入一行数据会被拒绝。事务A提交后，事务B才能进行插入数据。\n\n**MySQL默认级别：可重复读。**\n\n**实现可重复读的机制**：MVCC机制 multi-version concurrency control\n\n* 事务id是全局唯一且递增的，\n\n* 查询事务只会找比自己事务id小的 创建事务。\n\n  * 创建事务id<=当前事务id\n\n  * 当前事务id<删除事务id\n\n* 不同事务修改某行数据，会多出来一行，id相同。\n\n### 数据库锁\n\n**自动加锁**\n\n表锁 行锁 页锁\n\n* myisam会加表锁。锁表的时候查询会报504\n\n行锁：innodb：共享锁（s）和排他锁（x）\n\n* 共享锁和排他锁不能同时加\n* select 不加锁因为MVCC有快照，增删改会加一个行锁排他锁。\n\n**手动加锁**\n\n加共享锁：select * from table where id = 1 lock in share mode\n\n加排他锁：select * from table where id =1 for update\n\n**悲观锁**：进行操作都加上排他锁\n\n**乐观锁**：加上版本号字段，在事务修改期间如果版本号不同，则这次修改失败，需要重新读取操作。\n\n**死锁**：dba查看死锁日志。\n\n### MySQL调优的常用手段\n\n* 保持sql简单，建议使用单表查询\n  * 优化索引\n  * 查看sql的执行计划：explain select * from table \n\n###  E-R图\n\nentities-relationship图\n\n关系：操作数是关系，重复行的对应关系（投影）要去掉。剩下的是关系：一对多，一对一，多对多等\n\n\n\n##  socket\n\n直接使用tcp进行通信，就是socket编程\n\n可以认为socket处于传输层。或者是介于传输层和应用层直接。\n\nsocket 就是封装了tcp的编程规范\n\n## 进程通信和线程切换\n\n### 进程通信\n\n9.1.1管道 pipe\n\n只有父子进程（fork得到的）才能使用这个管道进行通信。\n\n9.1.2命名管道\n\n无亲缘关系的管道可以使用命名管道通信\n\n9.1.3消息队列\n\n9.1.4共享内存\n\n### 线程如何切换\n\n时间片轮换\n\n优先级调度等\n\n## nio，bio，aio都是什么，有什么区别。nio的原理是什么\n\n### bio通信原理\n\n服务端使用ServerSocket为每一个客户端建立一个线程用于通信。只要客户端还和服务端有连接，这个线程都要等待。\n\n问题：超过几千客户端就不能够正常运行了\n\n###  nio通信原理\n\n每有一个客户端和服务端建立连接，都会创建一个channel，这些channel都会注册在selector中，这个selector只有一个线程。会不断轮询这些channel。，如果有请求过来，会创建一个线程来处理这个请求。处理完成后这个线程会被销毁。\n\n可以对处理请求的线程创建一个线程池。\n\n在工作线程和channel 直接可以维护一个cache\n\n工作线程从channel 中读取数据，给channel写数据，是同步的\n\n###  aio\n\n对nio有优化：工作进程从channel读数据的时候，会绑定一个buffer，让操作系统来完成读操作，读完了来通知这个线程。\n\n写的时候也是把写的过程交给操作系统。\n\n###  同步阻塞、同步非阻塞、异步非阻塞\n\nBIO是同步阻塞，针对的是对磁盘文件的io读写。读写过程中线程阻塞\n\nNIO是同步非阻塞，在操作系统读写数据的时候，线程可以做其他事情，但是也需要不断轮询判断读写完成了没有。\n\nAIO 是异步非阻塞，发起文件读写的操作之后，交给操作系统，操作系统执行完毕之后，会通知这个线程。\n\n###  BIO NIO AIO demo代码\n\nTOREAD\n\n## 线上服务器问题\n\n### 线上CPU占用100%，排查步骤：\n\n* top -c 输入P ，按照cpu进行排序\n* top -Hp pid ，可以看到这个进程的负载\n* 把线程pid换成16进制pidhex，如何使用jstack pid | grep pidhex -C5 --color 就可以定位到线程中哪行代码的cpu占用最高。\n\n### 如果线上进程kill不掉怎么办\n\nps aux 查看是否有僵尸进程 zombie\n\nps -ef  | grep 僵尸进程id ，得到父进程id\n\n然后kill 父进程之后kill子进程。\n\n### 磁盘马上占满了怎么办\n\n是否是日志占满空间了？\n\n经历：安装程序的时候提示根目录空间占用100%，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm -rf删除了这些日志/var/log/pcp/pmlogger/openEuler1/。\n\n关于pcp：\n\n- Performance Co-Pilot (`pcp`) 提供了支持系统级性能监控和管理的框架和服务。它为系统中的所有性能数据提供了统一的抽象，以及用于询问、检索和处理该数据的许多工具。 \t\n- 这些生成的log，在openeuler系统没有设置自动清理，导致了日志积累。 \t\n\nfind / -size+100M | xargs ls -lh  找大于100m的文件\n\n## Java语言特性\n\n### 参数传递\n\n* Java 中将实参传递给方法（或函数）的方式是 **值传递**：\n  - 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。\n  - 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本\n* 想要通过传值来修改原来的值\n  * 通过数组\n  * 通过类\n  * 或者其他可变的引用类型\n* 不可变的引用类型\n  * String\n  * Integer\n  * BigDecimal\n  * LocalDate、LocalTime、LocalDateTime、Duration，Period\n\n### 序列化\n\n* 序列化协议属于应用层或者传输层\n\n* 序列化的对象：实现Serializable 接口的类、实例变量的值、非静态成员变量\n\n* serialVersionUID：用来判断对象版本。手动设置这个变量可以解决对象版本兼容问题。\n\n* Kryo用来序列化Java代码性能高。\n\n  * ```java\n    import com.esotericsoftware.kryo.Kryo;\n    import com.esotericsoftware.kryo.io.Input;\n    import com.esotericsoftware.kryo.io.Output;\n    \n    import java.io.*;\n    \n    public class KryoSerializationExample {\n        public static void main(String[] args) {\n            // 创建 Kryo 对象\n            Kryo kryo = new Kryo();\n    \n            // 创建要序列化的对象\n            Person person = new Person(\"Alice\", 30);\n    \n            // 序列化\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            Output output = new Output(outputStream);\n            kryo.writeObject(output, person);\n            output.close();\n    \n            // 将序列化的数据保存到文件\n            try (FileOutputStream fileOutputStream = new FileOutputStream(\"person.dat\")) {\n                outputStream.writeTo(fileOutputStream);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n    \n            // 反序列化\n            try (FileInputStream fileInputStream = new FileInputStream(\"person.dat\")) {\n                // 创建 Kryo 输入流\n                Input input = new Input(fileInputStream);\n    \n                // 从输入流中反序列化对象\n                Person deserializedPerson = kryo.readObject(input, Person.class);\n                input.close();\n    \n                // 使用反序列化后的对象\n                System.out.println(\"姓名: \" + deserializedPerson.getName());\n                System.out.println(\"年龄: \" + deserializedPerson.getAge());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    ```\n\n### 泛型和通配符\n\n1. 泛型（Generics）：泛型允许在编译时指定类、接口或方法操作的数据类型，以提供类型安全和代码重用。通过使用泛型，可以在编译时捕获类型错误，并避免在运行时出现类型转换错误。\n   - 定义泛型类：使用 `<T>` 来表示类型参数，可以在类名后面声明一个泛型类型。例如：`class MyClass<T> { ... }`。\n   - 定义泛型方法：使用 `<T>` 来表示类型参数，可以在方法返回类型前声明一个泛型类型。例如：`<T> T myMethod(T obj) { ... }`。\n   - 约定\n     - `E`：表示集合中的元素类型。\n     - `K`：表示映射中的键类型。\n     - `V`：表示映射中的值类型。\n     - `T`：表示任意类型。\n     - `S`、`U`、`V`：用于表示第二、第三和第四类型参数。\n2. 类型通配符（Wildcard）：类型通配符用问号 `?` 表示，用于灵活处理不同类型的泛型对象。通配符可以用于泛型类、泛型方法和通配符限定。\n   - 通配符限定上界：`? extends Type`，表示泛型参数是 Type 类型或其子类。例如：`List<? extends Number>` 表示一个只能接受 Number 及其子类的 List。\n   - 通配符限定下界：`? super Type`，表示泛型参数是 Type 类型或其父类。例如：`List<? super Integer>` 表示一个只能接受 Integer 及其父类的 List。\n   - 无限制通配符：`?`，表示可以是任意类型。例如：`List<?>` 表示一个可以接受任意类型的 List。\n\n### 反射\n\n##### 基本操作\n\n```java\n//获取类\nClass<?> myClass = MyClass.class;\nClass<?> myClass = Class.forName(\"com.example.MyClass\");\n//获取构造函数\nConstructor<?> constructor = myClass.getDeclaredConstructor(parameterTypes);\n//创建对象\nObject myObject = constructor.newInstance(arguments);\n//获取方法\nMethod method = myClass.getDeclaredMethod(\"methodName\", parameterTypes);\n//调用方法\nmethod.invoke(myObject, arguments);\n//获取字段\nField field = myClass.getDeclaredField(\"fieldName\");\n//获取字段的值\nObject fieldValue = field.get(myObject);\n//设置字段的值\nfield.set(myObject, value);\n//对于私有方法或字段，可能需要使用setAccessible(true)来绕过访问限制。\n```\n\n### 代理模式\n\n##### 1.静态代理：\n\n就是把在调用类的前后在执行一些步骤。\n\n```java\npublic class SmsProxy implements SmsService {\n\n    private final SmsService smsService;\n\n    public SmsProxy(SmsService smsService) {\n        this.smsService = smsService;\n    }\n\n    @Override\n    public String send(String message) {\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(\"before method send()\");\n        smsService.send(message);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(\"after method send()\");\n        return null;\n    }\n}\n\n```\n\n##### 2.动态代理\n\n**2.1JDK代理：在 Java 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心。**\n\n```java\n//调用proxy的方法newProxyInstance\nProxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),new DebugInvocationHandler(target));\n//DebugInvocationHandler 是自定义的proxy方法，需要实现InvocationHandler接口的invoke方法，实际上是调用了这里的invoke方法\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\npublic class DebugInvocationHandler implements InvocationHandler {\n    private final Object target;\n    public DebugInvocationHandler(Object target) {\n        this.target = target;\n    }\n    @Override\n    public Object invoke(Object o, Method method, Object[] objects) throws Throwable {\n        System.out.println(\"before Method\"+ method.getName());\n        Object result = method.invoke(target, objects);\n        System.out.println(\"after Method\"+ method.getName());\n        return result;\n    }\n}\n```\n\nJDK 动态代理有一个最致命的问题是其**只能代理实现了接口的类**。\n\n为了解决这个问题，我们可以用 CGLIB 动态代理机制。\n\n**2.2CGLIB代理**\n\n* 在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。\n\n* maven依赖：\n\n  * ```xml\n    <dependency>\n      <groupId>cglib</groupId>\n      <artifactId>cglib</artifactId>\n      <version>3.3.0</version>\n    </dependency>\n    ```\n\n* ```java\n  //代理工厂中生成一个 enhancer对象，这个对象拥有下列属性，其中DebugMethodInterceptor拦截器是自定义的最终执行的方法\n  public class CglibProxyFactory {\n      public static Object getProxy(Class<?> clazz){\n          Enhancer enhancer = new Enhancer();\n          enhancer.setClassLoader(clazz.getClassLoader());\n          enhancer.setSuperclass(clazz);\n          enhancer.setCallback(new DebugMethodInterceptor());\n          return enhancer.create();\n      }\n  }\n  //DebugMethodInterceptor 实现MethodInterceptor接口，重写intercept方法，这个方法相当于前面的invoke\n  public class DebugMethodInterceptor implements MethodInterceptor {\n      @Override\n      public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n          //调用方法之前，我们可以添加自己的操作\n          System.out.println(\"before method \" + method.getName());\n          Object object = methodProxy.invokeSuper(o, objects);\n          //调用方法之后，我们同样可以添加自己的操作\n          System.out.println(\"after method \" + method.getName());\n          return object;\n      }\n  }\n  \n  ```\n\n**2.3二者的区别**\n\njdk动态代理，有接口的时候使用，生成一个实现这些同样接口的对象。\n\n没有接口会使用cglib来生成你的类的子类，覆盖你的类的方法，在方法中加入增强的代码。\n\n###  BigDecimal常见方法\n\n我们在使用 `BigDecimal` 时，为了防止精度丢失，推荐使用它的`BigDecimal(String val)`构造方法或者 `BigDecimal.valueOf(double val)` 静态方法来创建对象。\n\n**使用BigDecimal(double val)会丢失精度**\n\n方法：\n\n* add：加\n* subtract：减\n* multiple：乘\n* divide：除\n  * 除的时候尽量使用三个参数的版本：指定保留规则RoundingMode \n* compareTo：`a.compareTo(b)` : 返回 -1 表示 `a` 小于 `b`，0 表示 `a` 等于 `b` ， 1 表示 `a` 大于 `b`。\n  * 比较不能使用equals，因为equals比较会同时比较精度，1.0和1.00不相同\n* setScale：保留小数\n\n工具类：\n\n<details><summary>点击查看代码</summary>\n <pre><code>\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n/**\n * 简化BigDecimal计算的小工具类\n */\npublic class BigDecimalUtil {\n    /**\n     * 默认除法运算精度\n     */\n    private static final int DEF_DIV_SCALE = 10;\n    private BigDecimalUtil() {\n    }\n    /**\n     * 提供精确的加法运算。\n     *\n     * @param v1 被加数\n     * @param v2 加数\n     * @return 两个参数的和\n     */\n    public static double add(double v1, double v2) {\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.add(b2).doubleValue();\n    }\n    /**\n     * 提供精确的减法运算。\n     *\n     * @param v1 被减数\n     * @param v2 减数\n     * @return 两个参数的差\n     */\n    public static double subtract(double v1, double v2) {\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.subtract(b2).doubleValue();\n    }\n    /**\n     * 提供精确的乘法运算。\n     *\n     * @param v1 被乘数\n     * @param v2 乘数\n     * @return 两个参数的积\n     */\n    public static double multiply(double v1, double v2) {\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.multiply(b2).doubleValue();\n    }\n    /**\n     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到\n     * 小数点以后10位，以后的数字四舍五入。\n     *\n     * @param v1 被除数\n     * @param v2 除数\n     * @return 两个参数的商\n     */\n    public static double divide(double v1, double v2) {\n        return divide(v1, v2, DEF_DIV_SCALE);\n    }\n    /**\n     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指\n     * 定精度，以后的数字四舍五入。\n     *\n     * @param v1    被除数\n     * @param v2    除数\n     * @param scale 表示表示需要精确到小数点以后几位。\n     * @return 两个参数的商\n     */\n    public static double divide(double v1, double v2, int scale) {\n        if (scale < 0) {\n            throw new IllegalArgumentException(\n                    \"The scale must be a positive integer or zero\");\n        }\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.divide(b2, scale, RoundingMode.HALF_EVEN).doubleValue();\n    }\n    /**\n     * 提供精确的小数位四舍五入处理。\n     *\n     * @param v     需要四舍五入的数字\n     * @param scale 小数点后保留几位\n     * @return 四舍五入后的结果\n     */\n    public static double round(double v, int scale) {\n        if (scale < 0) {\n            throw new IllegalArgumentException(\n                    \"The scale must be a positive integer or zero\");\n        }\n        BigDecimal b = BigDecimal.valueOf(v);\n        BigDecimal one = new BigDecimal(\"1\");\n        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();\n    }\n    /**\n     * 提供精确的类型转换(Float)\n     *\n     * @param v 需要被转换的数字\n     * @return 返回转换结果\n     */\n    public static float convertToFloat(double v) {\n        BigDecimal b = new BigDecimal(v);\n        return b.floatValue();\n    }\n    /**\n     * 提供精确的类型转换(Int)不进行四舍五入\n     *\n     * @param v 需要被转换的数字\n     * @return 返回转换结果\n     */\n    public static int convertsToInt(double v) {\n        BigDecimal b = new BigDecimal(v);\n        return b.intValue();\n    }\n    /**\n     * 提供精确的类型转换(Long)\n     *\n     * @param v 需要被转换的数字\n     * @return 返回转换结果\n     */\n    public static long convertsToLong(double v) {\n        BigDecimal b = new BigDecimal(v);\n        return b.longValue();\n    }\n    /**\n     * 返回两个数中大的一个值\n     *\n     * @param v1 需要被对比的第一个数\n     * @param v2 需要被对比的第二个数\n     * @return 返回两个数中大的一个值\n     */\n    public static double returnMax(double v1, double v2) {\n        BigDecimal b1 = new BigDecimal(v1);\n        BigDecimal b2 = new BigDecimal(v2);\n        return b1.max(b2).doubleValue();\n    }\n    /**\n     * 返回两个数中小的一个值\n     *\n     * @param v1 需要被对比的第一个数\n     * @param v2 需要被对比的第二个数\n     * @return 返回两个数中小的一个值\n     */\n    public static double returnMin(double v1, double v2) {\n        BigDecimal b1 = new BigDecimal(v1);\n        BigDecimal b2 = new BigDecimal(v2);\n        return b1.min(b2).doubleValue();\n    }\n    /**\n     * 精确对比两个数字\n     *\n     * @param v1 需要被对比的第一个数\n     * @param v2 需要被对比的第二个数\n     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1\n     */\n    public static int compareTo(double v1, double v2) {\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.compareTo(b2);\n    }\n}\n    </code></pre>\n</details>\n\n###  [Unsafe类](https://javaguide.cn/java/basis/unsafe.html)\n\n在JUC高并发编程中主要使用，用来执行本地方法（native方法）。\n\nnative方法的执行绕过了Java本身的界限。能直接接触到操作系统底层的某些功能，因此并不安全。\n\n可以实现的功能：\n\n1. 内存操作\n2. 内存屏障\n3. 对象操作\n4. 数据操作\n5. CAS 操作\n6. 线程调度\n7. Class 操作\n8. 系统信息\n\n因为其不安全性，并不推荐使用。\n\n### SPI机制\n\n### 语法糖\n\n\n\n\n\n\n\n\n\n","slug":"面经","published":1,"date":"2023-08-30T06:50:59.727Z","updated":"2023-09-11T14:56:41.421Z","_id":"cllyxpkt0002814gf847k5sk6","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"面经\"><a href=\"#面经\" class=\"headerlink\" title=\"面经\"></a>面经</h1><h2 id=\"Java基础知识\"><a href=\"#Java基础知识\" class=\"headerlink\" title=\"Java基础知识\"></a>Java基础知识</h2><h3 id=\"为什么说Java是编译和解释的语言\"><a href=\"#为什么说Java是编译和解释的语言\" class=\"headerlink\" title=\"为什么说Java是编译和解释的语言\"></a>为什么说Java是编译和解释的语言</h3><p>Java需要把代码编译成.class的字节码文件，然后再解释成机器码。</p>\n<h3 id=\"静态方法中为什么不能调用非静态方法\"><a href=\"#静态方法中为什么不能调用非静态方法\" class=\"headerlink\" title=\"静态方法中为什么不能调用非静态方法\"></a>静态方法中为什么不能调用非静态方法</h3><p>因为静态方法在类创建的时候生成，非静态方法在实例化对象之后才生成。</p>\n<h3 id=\"重载和重写\"><a href=\"#重载和重写\" class=\"headerlink\" title=\"重载和重写\"></a>重载和重写</h3><p>重载：同方法名，不同参数</p>\n<p>重写：子类重写父类的方法，方法名参数相同，构造方法无法重写</p>\n<h3 id=\"可变长参数public-void-test-String-…args\"><a href=\"#可变长参数public-void-test-String-…args\" class=\"headerlink\" title=\"可变长参数public void test(String …args)\"></a>可变长参数public void test(String …args)</h3><p>可以接收不同长度的参数，重载的时候优先匹配固定长度参数的方法。</p>\n<h3 id=\"对象实体和对象引用\"><a href=\"#对象实体和对象引用\" class=\"headerlink\" title=\"对象实体和对象引用\"></a>对象实体和对象引用</h3><p>new 来创建一个对象实体，一个对象实体可以有多个对象引用。一个对象引用可以指向一个对象实体。</p>\n<p>对象实体存在堆内存中（类和对象都存放在堆内存中）</p>\n<p>对象引用存放在栈内存中</p>\n<h3 id=\"对象默认有无参构造，但创建有参构造后要手动创建无参构造。\"><a href=\"#对象默认有无参构造，但创建有参构造后要手动创建无参构造。\" class=\"headerlink\" title=\"对象默认有无参构造，但创建有参构造后要手动创建无参构造。\"></a>对象默认有无参构造，但创建有参构造后要手动创建无参构造。</h3><h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>子类在调用父类的方法的时候，只有在运行的时候，才知道调用的是哪个方法（父类的还是子类的），这个方法具有多态性</p>\n<h3 id=\"接口和抽象类的区别\"><a href=\"#接口和抽象类的区别\" class=\"headerlink\" title=\"接口和抽象类的区别\"></a>接口和抽象类的区别</h3><ul>\n<li>相同点：<ul>\n<li>都不能被实例化</li>\n<li>都可以包含抽象方法</li>\n<li>都可以有默认实现的方法，接口中可以定义default方法来实现</li>\n</ul>\n</li>\n<li>不同点<ul>\n<li>接口主要是对对象的约束，约束对象的行为（实现接口的方法）</li>\n<li>抽象类主要是代码的复用性的规定</li>\n<li>一个类只可以继承一个类，但可以实现多个接口</li>\n<li>接口中 的成员变量只能是public static final 类型，有初值，不可变</li>\n<li>抽象类中的成员变量默认为default，可在子类中重新定义和赋值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a>深拷贝和浅拷贝</h3><p>浅拷贝：在对上创建一个新对象，如果被拷贝的是引用类型，则会直接复制它引用的地址</p>\n<p>深拷贝：复制整个对象，包含内部对象</p>\n<h3 id=\"Object-的常用方法\"><a href=\"#Object-的常用方法\" class=\"headerlink\" title=\"Object 的常用方法\"></a>Object 的常用方法</h3><details><summary>点击展开代码</summary><pre><code>/**\n * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\n */\npublic final native Class<?> getClass()\n/**\n * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\n */\npublic native int hashCode()\n/**\n * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\n */\npublic boolean equals(Object obj)\n/**\n * native 方法，用于创建并返回当前对象的一份拷贝。\n */\nprotected native Object clone() throws CloneNotSupportedException\n/**\n * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\n */\npublic String toString()\n/**\n * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n */\npublic final native void notify()\n/**\n * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n */\npublic final native void notifyAll()\n/**\n * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\n */\npublic final native void wait(long timeout) throws InterruptedException\n/**\n * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。\n */\npublic final void wait(long timeout, int nanos) throws InterruptedException\n/**\n * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n */\npublic final void wait() throws InterruptedException\n/**\n * 实例被垃圾回收器回收的时候触发的操作\n */\nprotected void finalize() throws Throwable &#123; &#125;</code></pre></details>\n\n<p>hashcode 和 equals 都是判断对象是否相同的方法</p>\n<p>hashcode 可能会碰撞，equals 是比较地址但效率较低</p>\n<p>重写equals也应当重写hashcode方法。</p>\n<h3 id=\"String-StringBuffer-StringBuilder-的区别\"><a href=\"#String-StringBuffer-StringBuilder-的区别\" class=\"headerlink\" title=\"String StringBuffer StringBuilder 的区别\"></a>String StringBuffer StringBuilder 的区别</h3><ul>\n<li><p>String 对象不可变，String a &#x3D; “test”;  a &#x3D; “test1” 。更改a的值的时候，是创建了一个新的String对象，将地址赋给a。是线程安全的</p>\n</li>\n<li><p>StringBuffer 和 StringBuilder 更改值，不用新建对象。</p>\n</li>\n<li><p>StringBuffer 使用同步锁保证线程安全</p>\n</li>\n<li><p>StringBuilder 是线程不安全的，效率比StringBUffer快10%-15%</p>\n</li>\n</ul>\n<h3 id=\"String拼接、赋值和intern方法\"><a href=\"#String拼接、赋值和intern方法\" class=\"headerlink\" title=\"String拼接、赋值和intern方法\"></a>String拼接、赋值和intern方法</h3><ul>\n<li>在Java9之前，String 用加号连接的方法是使用StringBuilder.append().toString()方法构建的。在之后更新了方法，可以放心使用+连接，性能也不错</li>\n<li>String s &#x3D; new String(“abc”); 这段代码可能会创建 1-2 个字符串对象。 先在字符串常量池创建一个字符串对象abc（如果已存在则不需要再创建），然后复制一份到堆内存中。</li>\n<li>String intern 方法：将引用保存到字符串常量池中（如果已有则不再保存），并且返回这个对象</li>\n</ul>\n<h3 id=\"字符串常量池\"><a href=\"#字符串常量池\" class=\"headerlink\" title=\"字符串常量池\"></a>字符串常量池</h3><h2 id=\"常用数据结构源码解析\"><a href=\"#常用数据结构源码解析\" class=\"headerlink\" title=\"常用数据结构源码解析\"></a>常用数据结构源码解析</h2><h3 id=\"hashmap\"><a href=\"#hashmap\" class=\"headerlink\" title=\"hashmap\"></a>hashmap</h3><ul>\n<li><p>底层是数组+链表+红黑树，非线程安全</p>\n</li>\n<li><p>可存储null的key和value</p>\n</li>\n<li><p>初始大小16，扩容到当前的二倍</p>\n</li>\n<li><p>获取Key的方法：</p>\n<ul>\n<li><pre><code class=\"java\">static final int hash(Object key) &#123;\n  int h;\n  // key.hashCode()：返回散列值也就是hashcode\n  // ^：按位异或\n  // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐\n  return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>元素添加：</p>\n<ul>\n<li>获取数组的index：key对hashmap的length取模（将key和length-1与，比%取模的性能好）</li>\n<li>如果这个index没有元素，直接添加</li>\n<li>如果有元素则比较key，如果key相同则覆盖。</li>\n<li>如果是hash碰撞，则判断是否是树节点，是就调用putTreeVal加入树节点，否则加入链表尾部</li>\n</ul>\n</li>\n<li><p>hash碰撞使用拉链法</p>\n<ul>\n<li>在hash碰撞的节点创建一个链表，把碰撞的值都放在链表中</li>\n<li>链表元素超过8个，将链表切换成红黑树</li>\n</ul>\n</li>\n<li><p>扩容条件是存放的元素数量超过<code>容量*负载因子</code></p>\n<ul>\n<li>负载因子<strong>loadFactor</strong> 是控制数组存放数据的疏密程度<ul>\n<li>loadFactor越趋近1，数组中存储的元素就越多，碰撞的元素在链表的长度就越多，查询性能下降</li>\n<li>loadFactor越趋近0，hashMap扩容次数增加，rehash消耗性能</li>\n<li>官方给出的默认为0.75</li>\n</ul>\n</li>\n<li>resize就是扩容之后重新计算index和hash碰撞<ul>\n<li>底层就是新开一个数组，将元素重新放入新数组</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><ul>\n<li><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。线程不安全。</p>\n<ul>\n<li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>\n<li><code>RandomAccess</code> ：表明它可以快速进行随机访问，get(index)</li>\n<li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>\n<li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>\n</ul>\n</li>\n<li><p>可以添加null值。</p>\n</li>\n<li><p>底层是Object数组。</p>\n</li>\n<li><p>时间复杂度：add() O(1) ;   add(index,val) O(n) ;</p>\n</li>\n<li><p>空间占用主要是末尾预留的空间。</p>\n</li>\n<li><p>在添加大量元素的时候，可以提前使用ensureCapacity(N)方法预留空间，减少空间分配次数，节约性能。</p>\n</li>\n<li><p>当添加元素大于容量的时候，触发扩容</p>\n<ul>\n<li>扩容：每次newSize&#x3D; oldSize+oldSize&#x2F;2 相当于1.5倍</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><ul>\n<li><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</li>\n<li><code>LinkedList</code> 实现了<code>List</code>,<code>Deque</code>,<code>Cloneable</code>,<code>Seralizable</code><ul>\n<li><code>Deque</code>：表明它具有双端队列特性，便于两端插入和删除</li>\n</ul>\n</li>\n<li>底层是双向链表</li>\n<li>时间复杂度：add() O(1); add(index,val) O(n) </li>\n<li>空间占用主要是除了data之外的索引等数据</li>\n<li>遍历常用for-each</li>\n<li>基本上不用LinkedList，都用ArrayList，性能一般更好一些</li>\n</ul>\n<h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><h2 id=\"并发编程\"><a href=\"#并发编程\" class=\"headerlink\" title=\"并发编程\"></a>并发编程</h2><h3 id=\"synchronized关键字的底层原理是什么\"><a href=\"#synchronized关键字的底层原理是什么\" class=\"headerlink\" title=\"synchronized关键字的底层原理是什么\"></a>synchronized关键字的底层原理是什么</h3><p>2.1.1synchronized是做什么的</p>\n<p><strong>给线程加锁</strong>，加锁目标是一个类或一个对象。</p>\n<p>2.1.2实现原理</p>\n<p>加锁指令：monitorenter（加锁） monitorexit（释放锁）</p>\n<p>一个对象或类关联有一个monitor（计数器：正在使用的线程数，<strong>类似信号量</strong>）</p>\n<h3 id=\"CAS的理解和底层实现原理\"><a href=\"#CAS的理解和底层实现原理\" class=\"headerlink\" title=\"CAS的理解和底层实现原理\"></a>CAS的理解和底层实现原理</h3><p>多个线程要访问同一个数据会出现并发安全问题。</p>\n<p><code>AtomicInterger</code>并发包的原子类，使用CAS实现。</p>\n<p>2.2.1线程操作AtomicInterger基本流程：</p>\n<p>线程1想要修改值，会</p>\n<ul>\n<li>先读取旧值</li>\n<li>在修改前再次读取这个值</li>\n<li>如果没人修改，则使用CAS进行修改这个值。</li>\n<li>如果第二次读取的值和旧值不同，则CAS失败。</li>\n</ul>\n<p>2.2.2CAS</p>\n<p>CAS：compare and set</p>\n<p>在硬件级别保是原子操作，同一时间只有一个线程可以执行CAS。</p>\n<h3 id=\"ConcurrentHashMap实现线程安全的底层原理\"><a href=\"#ConcurrentHashMap实现线程安全的底层原理\" class=\"headerlink\" title=\"ConcurrentHashMap实现线程安全的底层原理\"></a>ConcurrentHashMap实现线程安全的底层原理</h3><p>2.3.1对hashmap简单的操作，不需要进行synchronized</p>\n<p>一般的操作都是hashmap底层数组的不同的元素进行操作，无需加锁</p>\n<p>ConcurrentHashmap默认实现了线程安全。</p>\n<p>2.3.2在jdk1.7以及之前，对ConcurrentHashmap底层的数组分段加锁。</p>\n<p><strong>一段数组加一个锁</strong>，如果操作的是不同不同段的数组，则不互相影响</p>\n<p>2.3.3在jdk1.8以及之后，不再数组分段，<strong>对数组中每一个元素都加了一个锁</strong>。</p>\n<p>将锁的粒度细化。</p>\n<h3 id=\"JDK中的AQS的实现原理\"><a href=\"#JDK中的AQS的实现原理\" class=\"headerlink\" title=\"JDK中的AQS的实现原理\"></a>JDK中的AQS的实现原理</h3><p><code>ReentrantLock </code>类底层是AQS（Abstract Queue Synchronizer）</p>\n<p>可以使用这个类生成一个锁lock，可以进行lock.lock() lock.unlock()实现互斥。</p>\n<p>2.4.1 AQS会有一个等待队列，存储没有得到锁的线程，待锁释放后，按顺序为等待队列的线程提供锁</p>\n<img src=\"http://gohoy.top/i/2023/07/31/ui6crn-1.png\" alt=\"image-20230731160209376\" style=\"zoom:80%;\" />\n\n<p>2.4.2如果在线程1执行完毕，唤醒线程2的过程中，如果有线程3想要加锁</p>\n<ul>\n<li>非公平锁：ReentrantLock lock &#x3D; new ReentrantLock()；<ul>\n<li>线程3可能会成功得到锁，达到插队。</li>\n</ul>\n</li>\n<li>公平锁：ReentrantLock lock &#x3D; new ReentrantLock(true);<ul>\n<li>如果等待队列有线程，线程3会进入等待队列。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程池的底层工作原理\"><a href=\"#线程池的底层工作原理\" class=\"headerlink\" title=\"线程池的底层工作原理\"></a>线程池的底层工作原理</h3><p>2.5.1线程池：提供一定量的线程，线程执行完成任务后，不销毁自己，等待下一次任务：</p>\n<p><strong>避免重复创建和销毁线程，造成性能浪费</strong></p>\n<p>创建线程池：</p>\n<pre><code class=\"java\">ExecutorService threadPool = Executor.newFixedThreadPool(10)  //(corePoolSize = 10)\nthreadPool.submit(new Callable() &#123;\n    public void run()&#123;&#125;\n&#125;);\n</code></pre>\n<p>有新任务的时候</p>\n<ul>\n<li>如果线程池的线程数量小于容量，则直接创建一个新的线程执行任务。</li>\n<li>如果满了，则放在任务队列中。</li>\n</ul>\n<p>当线程完成自己的任务的时候，会去任务队列中获取任务，如果没有任务，会阻塞，不会销毁。</p>\n<h3 id=\"线程池的核心配置参数\"><a href=\"#线程池的核心配置参数\" class=\"headerlink\" title=\"线程池的核心配置参数\"></a>线程池的核心配置参数</h3><p>代表线程池的类是ThreadPoolExecutor</p>\n<pre><code class=\"java\">return new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;())\n</code></pre>\n<ul>\n<li><code>corePoolSize：3</code><ul>\n<li>一般最大线程数只有3</li>\n</ul>\n</li>\n<li><code>maximumPoolSize：200</code><ul>\n<li>当任务队列满了，可以最多额外创建到200个，执行任务并从任务队列获取任务</li>\n</ul>\n</li>\n<li><code>keepAliveTime：60s</code><ul>\n<li>任务队列空了60s后，额外线程自动会销毁掉</li>\n</ul>\n</li>\n<li><code>new ArrayBlockingQueue&lt;Runnable&gt;(200)</code><ul>\n<li>任务队列</li>\n</ul>\n</li>\n</ul>\n<p>如果额外线程也满了，会报异常。可以自定义RejectedExecutionHandler策略来应对这种情况：持久化被reject的任务，等负载低了再加载执行。</p>\n<h3 id=\"如果在线程池中使用无界阻塞队列会发生什么问题\"><a href=\"#如果在线程池中使用无界阻塞队列会发生什么问题\" class=\"headerlink\" title=\"如果在线程池中使用无界阻塞队列会发生什么问题\"></a>如果在线程池中使用无界阻塞队列会发生什么问题</h3><h4 id=\"面试题1：如果使用无界阻塞队列调用远程服务，远程服务异常，会不会导致内存异常飙升\"><a href=\"#面试题1：如果使用无界阻塞队列调用远程服务，远程服务异常，会不会导致内存异常飙升\" class=\"headerlink\" title=\"面试题1：如果使用无界阻塞队列调用远程服务，远程服务异常，会不会导致内存异常飙升\"></a>面试题1：如果使用无界阻塞队列调用远程服务，远程服务异常，会不会导致内存异常飙升</h4><p>调用超时，队列变得越来越大，内存会飙升，可能会导致OOM。</p>\n<h3 id=\"线程池队列满了之后，会发生什么\"><a href=\"#线程池队列满了之后，会发生什么\" class=\"headerlink\" title=\"线程池队列满了之后，会发生什么\"></a>线程池队列满了之后，会发生什么</h3><ul>\n<li>如果给maximumPoolSize设置太大，可能会导致系统崩溃。因为线程会占用一定内存，也会增加cpu负载。</li>\n<li>如果给maximumPoolSize设置太小，可能会导致任务reject。</li>\n</ul>\n<h3 id=\"如果机器突然宕机，线程池的阻塞队列的任务怎么办\"><a href=\"#如果机器突然宕机，线程池的阻塞队列的任务怎么办\" class=\"headerlink\" title=\"如果机器突然宕机，线程池的阻塞队列的任务怎么办\"></a>如果机器突然宕机，线程池的阻塞队列的任务怎么办</h3><p><strong>都会丢失</strong></p>\n<p>解决办法：在数据库对任务信息进行持久化。</p>\n<h2 id=\"谈谈对Java内存模型的理解\"><a href=\"#谈谈对Java内存模型的理解\" class=\"headerlink\" title=\"谈谈对Java内存模型的理解\"></a>谈谈对Java内存模型的理解</h2><pre><code class=\"java\">public class HelloWorld &#123;\n    private int data;\n    public void increment()&#123;\n        data++;\n    &#125;\n&#125;\nHelloWorld helloWorld = new HelloWorld(); //对象存放在堆内存，包含对象中的实例变量\n//线程1\nnew Thread()&#123;\n    public void run()&#123;\n        helloWorld.increment();\n    &#125;\n&#125;.start()\n//线程2\nnew Thread()&#123;\n    public void run()&#123;\n        helloWorld.increment();\n    &#125;\n&#125;.start()\n   \n</code></pre>\n<p>常量：主存（内存）</p>\n<p>线程的工作内存：cpu缓存</p>\n<p>常量操作：read load use assign store write</p>\n<img src=\"http://gohoy.top/i/2023/07/31/ui6jyh-1.png\" alt=\"image-20230731165920298\" style=\"zoom: 80%;\" />\n\n<h3 id=\"可见性、原子性、有序性\"><a href=\"#可见性、原子性、有序性\" class=\"headerlink\" title=\"可见性、原子性、有序性\"></a>可见性、原子性、有序性</h3><ul>\n<li>可见性<ul>\n<li>没有可见性：线程1更新了数据，但是线程2看到的还是工作内存中旧的数据</li>\n<li>有可见性：数据更新之后，线程1会强制使线程2重新读取修改后的数据。</li>\n</ul>\n</li>\n<li>原子性<ul>\n<li>一次只有一个线程进入临界区。data++必须是独立执行的。</li>\n</ul>\n</li>\n<li>有序性<ul>\n<li>在任务需要的资源准备完全之后，执行该线程任务。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"从底层角度聊volatile关键字原理\"><a href=\"#从底层角度聊volatile关键字原理\" class=\"headerlink\" title=\"从底层角度聊volatile关键字原理\"></a>从底层角度聊volatile关键字原理</h3><p>volatile：用来解决<strong>可见性和有序性</strong>，对原子性的保证很有限。（对64位的long型有一定原子性保证）</p>\n<ul>\n<li>实现可见性<ul>\n<li><strong>当加上volatile的变量改变时，会使其他线程工作内存的过期变量失效。</strong></li>\n</ul>\n</li>\n<li>保证有序性<ul>\n<li>保证写在读之前</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"指令重排和happens-before原则\"><a href=\"#指令重排和happens-before原则\" class=\"headerlink\" title=\"指令重排和happens-before原则\"></a>指令重排和happens-before原则</h3><p>指令重排有可能导致有序性失效。</p>\n<p>happens-before原则：</p>\n<ul>\n<li>线程内按照代码顺序，写在前面的代码先行发生在卸载后面的代码。</li>\n<li>锁定操作：对锁的unlock操作先行发生在lock操作</li>\n<li>volatile变量原则：写操作在读操作之前</li>\n<li>传递原则：A先于B，B先于C，则A先于C</li>\n<li>线程启动原则：线程的启动thread.star()先于线程中的其他操作。还有interrupt</li>\n<li>线程终结原则：线程的所有操作都先于线程的终止检测，使用thread.jion()结束。</li>\n<li>对象终结原则：一个对象的初始化完成在finalize()方法之前。</li>\n</ul>\n<h3 id=\"volatile底层如何基于内存屏障保证可见性和有序性\"><a href=\"#volatile底层如何基于内存屏障保证可见性和有序性\" class=\"headerlink\" title=\"volatile底层如何基于内存屏障保证可见性和有序性\"></a>volatile底层如何基于内存屏障保证可见性和有序性</h3><p>对volatile的值的操作代码前后加上内存屏障。</p>\n<p>内存屏障：禁止重排序</p>\n<h2 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h2><h3 id=\"Spring的IOC\"><a href=\"#Spring的IOC\" class=\"headerlink\" title=\"Spring的IOC\"></a>Spring的IOC</h3><p>如果没有IOC：tomcat+servlet：tomcat 监听端口来将请求转发给servlet来处理，耦合严重，需要变动时，修改很麻烦。</p>\n<p>IOC：<strong>依赖注入，控制反转，容器根据xml配置或者注解来对bean对象之间的引用关系进行依赖注入</strong></p>\n<p>底层核心技术：反射。根据类来自动构建对应的对象。</p>\n<p>类与类彻底解耦。</p>\n<p><img src=\"http://gohoy.top/i/2023/08/01/njxvd8-1.png\" alt=\"image-20230801142412643\"></p>\n<h3 id=\"Spring的AOP\"><a href=\"#Spring的AOP\" class=\"headerlink\" title=\"Spring的AOP\"></a>Spring的AOP</h3><p>MySQL：事务：一次开启一个事务，其中进行多次增删改查。如果有一条失败了，会回滚事务，把这个事务中所有的sql语句都恢复。</p>\n<p>AOP:做一个切面Aspect，给所有类似servicexxx代码之前都会开启一个事务，在这些方法运行完毕之后，根据是否抛出异常，去回滚或者提交事务。</p>\n<p>核心技术：动态代理</p>\n<p><strong>Spring会给正在运行的类生成动态代理类，包含我们写的类。然后在代理类中给逻辑前后加上事务。</strong></p>\n<p>如何限定AOP。</p>\n<p>TODO</p>\n<h3 id=\"了解过cglib动态代理吗，他和jdk动态代理的区别是什么\"><a href=\"#了解过cglib动态代理吗，他和jdk动态代理的区别是什么\" class=\"headerlink\" title=\"了解过cglib动态代理吗，他和jdk动态代理的区别是什么\"></a>了解过cglib动态代理吗，他和jdk动态代理的区别是什么</h3><p>jdk动态代理，有接口的时候使用，生成一个实现这些同样接口的对象。</p>\n<p>没有接口会使用cglib来生成你的类的子类，覆盖你的类的方法，在方法中加入增强的代码。</p>\n<h3 id=\"spring事务的实现原理是什么，事务传播机制是什么\"><a href=\"#spring事务的实现原理是什么，事务传播机制是什么\" class=\"headerlink\" title=\"spring事务的实现原理是什么，事务传播机制是什么\"></a>spring事务的实现原理是什么，事务传播机制是什么</h3><p>不同事务之间不互相影响</p>\n<p>@Transactional(propagation &#x3D; Propagation.REQUIRED)会开启一个事务</p>\n<ul>\n<li>Propagation_REQUIRED：如果当前没有事务，创建一个事务，多个调用加入到一个事务中。</li>\n<li>Propagation_SUPPORT：之前有事务则加入，没有则不开启。</li>\n<li>Propagation_MANDATORY：有事务加入，没有则报错。</li>\n<li>Propagation_RESQUIRES_NEW：强制开启一个新事务。</li>\n<li>Propagation_NOT_SUPPORTED：不使用事务，有事务会挂起</li>\n<li>Propagation_NEVER：不允许使用事务，有事务会报错</li>\n<li>Propagation_NESTED：嵌套事务，外层事务回滚会导致内存事务也回滚，内层不影响外层。</li>\n</ul>\n<h3 id=\"Springboot-的核心架构\"><a href=\"#Springboot-的核心架构\" class=\"headerlink\" title=\"Springboot 的核心架构\"></a>Springboot 的核心架构</h3><p>自动装配依赖。不需要像spring一样自己配置xml文件，引入jar包。减少了配置。</p>\n<h3 id=\"Spring-核心源码\"><a href=\"#Spring-核心源码\" class=\"headerlink\" title=\"Spring 核心源码\"></a>Spring 核心源码</h3><p>Spring bean 生命周期：</p>\n<ul>\n<li>创建bean<ul>\n<li>实例化一个bean</li>\n<li>依赖注入<ul>\n<li>把这个bean的依赖的bean实例化，也进行依赖注入。注入方法：构造函数，setter方法。</li>\n</ul>\n</li>\n<li>处理Aware接口<ul>\n<li>如果这个bean实现了Aware相关的接口，Spring容器会把自己的信息注入给bean中。</li>\n</ul>\n</li>\n<li>BeanPostProcesser<ul>\n<li>在bean实例初始化之前和之后可以执行的方法。</li>\n</ul>\n</li>\n<li>init初始化方法</li>\n</ul>\n</li>\n<li>销毁<ul>\n<li>DisposableBean接口，会调用这个接口实现的destroy方法</li>\n<li>最后，如果配置了destroy-method方法，会调用这个方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Spring中的设计模式\"><a href=\"#Spring中的设计模式\" class=\"headerlink\" title=\"Spring中的设计模式\"></a>Spring中的设计模式</h3><p>工厂，单例，代理</p>\n<p>工厂模式：使用工厂类来创建类。</p>\n<p>单例模式：每个bean在系统运行期间只会创建一个实例对象。</p>\n<p>代理模式：AOP</p>\n<h3 id=\"SpringMVC架构\"><a href=\"#SpringMVC架构\" class=\"headerlink\" title=\"SpringMVC架构\"></a>SpringMVC架构</h3><ul>\n<li>tomcat 监听端口，将请求转发给SpringMVC的DispathcherServlet</li>\n<li>然后SpringMVC再根据url将请求转发给对应的controller</li>\n<li>返回json给前端，前端符合渲染</li>\n</ul>\n<h3 id=\"SpringCloud核心架构\"><a href=\"#SpringCloud核心架构\" class=\"headerlink\" title=\"SpringCloud核心架构\"></a>SpringCloud核心架构</h3><p>这些框架</p>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><h3 id=\"JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进\"><a href=\"#JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进\" class=\"headerlink\" title=\"JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进\"></a>JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进</h3><ul>\n<li>栈内存：每个线程独有</li>\n<li>堆内存：存放对象、实例</li>\n<li>永久代区域：我们写的类</li>\n</ul>\n<p>Java8以后永久代变成metaspace</p>\n<p>常量区放在了堆里面</p>\n<h3 id=\"JVM如何运行起来的，如何创建各种对象\"><a href=\"#JVM如何运行起来的，如何创建各种对象\" class=\"headerlink\" title=\"JVM如何运行起来的，如何创建各种对象\"></a>JVM如何运行起来的，如何创建各种对象</h3><p><strong>线程执行main函数同时创建对象</strong></p>\n<p>Spring容器创建一些bean对象</p>\n<p>把执行的方法和局部变量放在栈帧。</p>\n<h3 id=\"JVM什么时候会触发垃圾回收\"><a href=\"#JVM什么时候会触发垃圾回收\" class=\"headerlink\" title=\"JVM什么时候会触发垃圾回收\"></a>JVM什么时候会触发垃圾回收</h3><p>内存分代：年轻代（eden：s1： s2，  8：1：1 ）和老年代</p>\n<p>年轻代和老年代统称为堆</p>\n<p>新生成的对象实例存放在年轻代。</p>\n<ul>\n<li>ygc：Eden区满了。进行youngGC<ul>\n<li>没有引用的对象（类）被回收</li>\n</ul>\n</li>\n</ul>\n<p>年轻代垃圾回收算法：</p>\n<ul>\n<li>复制算法：因为年轻代中大多数都是垃圾对象，所以把存活对象复制到s1中，一键全部清除Eden区。<ul>\n<li>把s1和Eden中的存活对象复制到s2，把s1和Eden区全部清除</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么时候对象会转移到老年代\"><a href=\"#什么时候对象会转移到老年代\" class=\"headerlink\" title=\"什么时候对象会转移到老年代\"></a>什么时候对象会转移到老年代</h3><p>如果存活了多次垃圾回收过程，就会转移到老年代</p>\n<p>如果s区放不下，会把一些存活的对象直接放到老年代中。</p>\n<p>对于大对象会直接放到老年代中，防止ygc反复复制大对象。</p>\n<h3 id=\"常用的垃圾回收器，老年代如何回收\"><a href=\"#常用的垃圾回收器，老年代如何回收\" class=\"headerlink\" title=\"常用的垃圾回收器，老年代如何回收\"></a>常用的垃圾回收器，老年代如何回收</h3><p>老年代中大多数是长期存活的对象，所以使用标记-清理方法：把所有存活的对象压缩到连续的位置，然后统一清理，可以防止内存碎片问题。</p>\n<p>常用的垃圾回收器：</p>\n<ul>\n<li>CMS+parnew jdk8-jdk9</li>\n<li>g1 jdk11 </li>\n<li>ZGC</li>\n</ul>\n<h3 id=\"生产环境如何设置jvm参数的，如何检查jvm的运行情况\"><a href=\"#生产环境如何设置jvm参数的，如何检查jvm的运行情况\" class=\"headerlink\" title=\"生产环境如何设置jvm参数的，如何检查jvm的运行情况\"></a>生产环境如何设置jvm参数的，如何检查jvm的运行情况</h3><p>tomcat的配置脚本，catalina脚本设置。</p>\n<p>如果使用jar启动，再java命令后直接加上参数</p>\n<p>参数：</p>\n<ul>\n<li>内存区域大小的分配：<ul>\n<li>栈大小</li>\n<li>metaspace大小</li>\n<li>eden  survivor</li>\n<li>堆大小</li>\n<li>年轻代、老年代</li>\n</ul>\n</li>\n<li>垃圾回收器<ul>\n<li>年轻代和老年代用了什么回收器</li>\n<li>是否有特殊参数，作用是什么</li>\n</ul>\n</li>\n</ul>\n<p>jstat压测，QPS,接口性能</p>\n<h3 id=\"JVM-GC优化\"><a href=\"#JVM-GC优化\" class=\"headerlink\" title=\"JVM GC优化\"></a>JVM GC优化</h3><p>自己动手进行压测，调试一下</p>\n<h3 id=\"发生OOM之后，应该如何排查和处理线上系统的OOM问题\"><a href=\"#发生OOM之后，应该如何排查和处理线上系统的OOM问题\" class=\"headerlink\" title=\"发生OOM之后，应该如何排查和处理线上系统的OOM问题\"></a>发生OOM之后，应该如何排查和处理线上系统的OOM问题</h3><p>在jvm设置参数，发生oom之后保存快照。</p>\n<p>找出占用内存最大的对象和创建它的代码，进行调优。</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"TCP-IP的四层模型和七层网络模型\"><a href=\"#TCP-IP的四层模型和七层网络模型\" class=\"headerlink\" title=\"TCP&#x2F;IP的四层模型和七层网络模型\"></a>TCP&#x2F;IP的四层模型和七层网络模型</h3><p>TCP&#x2F;IP四层：数据链路层、网络层、传输层、应用层</p>\n<ul>\n<li>物理层：硬件部分</li>\n<li>数据链路层：将0&#x2F;1信号分组，确定来源去向<ul>\n<li>以太网协议：一组信号是一个网络帧。每帧有两个部分：表头和数据，表头保存说明性的东西，比如发送者，接收者，数据类型等。通过网卡来发送接收数据，mac地址是网卡的id。</li>\n<li>mac：前6个16进制是厂商编号，后6个编号是网卡流水号。</li>\n</ul>\n</li>\n<li>网络层：<ul>\n<li>IP协议</li>\n<li>判断是不是一个子网：使用ip的二进制和子网掩码进行与运算，看结果前三个部分如果是一样的就是子网。</li>\n<li>不在一个子网需要一个路由器，路由器判断数据包的目标mac是不是自己的子网内的mac，是则转发。</li>\n<li>ARP cache 会让每一个电脑都缓存到子网中所以电脑的ip和mac对应关系。</li>\n<li>路由器就可以看做是一个网关</li>\n</ul>\n</li>\n<li>传输层TCP协议：仅仅规定了基于端口的点对点通信协议，包含如何建立连接，读取和发送信息。要基于TCP 开发，实际上是使用socket开发。</li>\n<li>应用层：最常见的是http</li>\n</ul>\n<p>OSI七层：物理层、会话层、表示层 + 四层模型</p>\n<p>DNS：domain name server ，先通过dns服务器把域名翻译成IP。</p>\n<h3 id=\"浏览器访问baidu-com会发生什么\"><a href=\"#浏览器访问baidu-com会发生什么\" class=\"headerlink\" title=\"浏览器访问baidu.com会发生什么\"></a>浏览器访问baidu.com会发生什么</h3><ul>\n<li>域名解析为IP</li>\n<li>把请求打包成http包</li>\n<li>把http数据包包装成tcp数据包，tcp数据头包含接收者和发送者的端口号</li>\n<li>然后把全部数据包包装到ip数据包，ip数据头中包含发送者和接收者的ip</li>\n<li>然后以太网会把这个数据包封装到以太网数据包中，加上以太网头，其中包含有发送者和接收者的网卡mac地址。<ul>\n<li>以太网一次传输字节有限，可能需要切割为多个包。</li>\n<li>根据IP头序号来合成一个包。</li>\n</ul>\n</li>\n<li>然后通过多个路由转发到百度的子网中。</li>\n</ul>\n<h3 id=\"TCP三次握手和四次挥手的流程，为什么不是五次或者两次？\"><a href=\"#TCP三次握手和四次挥手的流程，为什么不是五次或者两次？\" class=\"headerlink\" title=\"TCP三次握手和四次挥手的流程，为什么不是五次或者两次？\"></a>TCP三次握手和四次挥手的流程，为什么不是五次或者两次？</h3><ul>\n<li>建立连接的三次握手：<ul>\n<li>客户端发送syn（同步），表示自己进入了syn_send状态</li>\n<li>服务端恢复syn+ack（确认）表示确认收到同步请求，并且自己进入syn_recevie状态</li>\n<li>客户端发送ack，表示确认建立连接。当服务端接收到这个包的时候，连接正式建立</li>\n</ul>\n</li>\n<li>为什么不是两次握手<ul>\n<li>如果网络问题，遇到不想要的连接，三次连接可以让客户端发送给服务器复位信息，释放资源</li>\n</ul>\n</li>\n<li>结束连接的四次挥手：<ul>\n<li>客户端发送FIN（结束）</li>\n<li>服务端发送ACK（收到），这段时间有可能传输还没有完全完毕，等待全部完毕后再发送FIN。</li>\n<li>服务端发送FIN（结束）</li>\n<li>客户端发送ACK（收到）：服务端收到这个请求后立刻关闭，客户端会等待一段时间，保证服务端确实接收到这个包</li>\n</ul>\n</li>\n</ul>\n<p> 2 3次挥手好像在某些情况可以合并？</p>\n<h3 id=\"说一下http长连接的原理\"><a href=\"#说一下http长连接的原理\" class=\"headerlink\" title=\"说一下http长连接的原理\"></a>说一下http长连接的原理</h3><p><strong>http本身没有长连接，都是tcp的长连接和短链接</strong></p>\n<p>http协议规范：请求头，请求体什么的</p>\n<p>http1.0 都是短链接，一次请求后直接断开tcp连接，需要指定keep-alive才能建立长连接</p>\n<p>http1.1 默认是长连接</p>\n<p>http2.0支持多路复用，一个tcp可以并行发送多个请求以及接收响应。</p>\n<p>http3.0 QUIC 建立在udp之上。</p>\n<h3 id=\"https-http-ssl-tsl\"><a href=\"#https-http-ssl-tsl\" class=\"headerlink\" title=\"https http+ssl&#x2F;tsl\"></a>https http+ssl&#x2F;tsl</h3><p>使用证书加密</p>\n<ul>\n<li>非对称加密：rsa<ul>\n<li>网站给浏览器发送证书（由权威机构颁发），浏览器验证合法性</li>\n<li>浏览器生成随机密码，用随机密码加密随机密码的hash，并且用证书的公钥加密这个随机密码，</li>\n<li>网站用证书的私钥解密这个随机面膜，再用随机密码解密得到hash，计算自己得到的密码的hash进行对比，如果完全相同，则可以使用</li>\n<li>之后用这个随机密码来实现加密通信。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><h3 id=\"引擎：mysiam-innodb\"><a href=\"#引擎：mysiam-innodb\" class=\"headerlink\" title=\"引擎：mysiam innodb\"></a>引擎：mysiam innodb</h3><ul>\n<li>mysiam：不支持事务，不支持外键约束。索引和数据文件分开，可以在内存缓存更多索引，查询性能会更好，适用于少量插入，大量查询<ul>\n<li>hadoop报表系统，用mysql mysiam比较适合，但是数据量太大超过500w以上就也不能用mysql了。</li>\n</ul>\n</li>\n<li>innodb（默认）：支持事务，外键约束，高并发，高可用，大数据量</li>\n</ul>\n<h3 id=\"Mysql索引原理和数据结构。\"><a href=\"#Mysql索引原理和数据结构。\" class=\"headerlink\" title=\"Mysql索引原理和数据结构。\"></a>Mysql索引原理和数据结构。</h3><p>索引：默认b+树</p>\n<ul>\n<li>b-树<ul>\n<li>每个节点都存储对应的data</li>\n</ul>\n</li>\n<li>b+树<ul>\n<li>只有叶子节点存储对应的data</li>\n</ul>\n</li>\n</ul>\n<p>Mysiam的索引：叶子节点存储的是索引的物理地址。然后用物理地址去数据文件找数据。</p>\n<p>Innodb的索引：表要求必须要有主键，默认会为主键建立一个索引，节点data包含所有数据（一个记录，整行），叫做聚簇索引。如果你使用name来找数据，那么从name索引中找到的data是主键（id），再用id从聚簇索引找data。</p>\n<h3 id=\"索引的使用规则\"><a href=\"#索引的使用规则\" class=\"headerlink\" title=\"索引的使用规则\"></a>索引的使用规则</h3><p>怎么建立索引？</p>\n<p><strong>最左前缀匹配原则：</strong></p>\n<p>创建联合索引：create index(shop_id,product_id,gmt_create)</p>\n<p>如果你使用 shop_id 和 gmt_create来查找，那么不会直接通过这个联合索引查找，而是通过使用shop_id筛选出来一些数据，之后扫描gmt_create字段符合要求过滤。（性能也还行）。</p>\n<p><strong>但如果没有最左边的任何字段，就没法用这个索引</strong>，比如直接通过product_id查找，这个是没有用到这个索引的。</p>\n<p>范围列匹配，最左前缀范围查找会用索引，之后的不会用索引了。</p>\n<p>调用了函数的sql语句不使用索引</p>\n<p><strong>建立尽量少的索引，10条以内为佳</strong></p>\n<p><strong>尽量选唯一字段进行建立索引</strong>。选择的字段 去重后数量&#x2F;总数量 ，结果要是小，则说明这个索引用处不大。</p>\n<h3 id=\"事务的几个特点\"><a href=\"#事务的几个特点\" class=\"headerlink\" title=\"事务的几个特点\"></a>事务的几个特点</h3><p><strong>ACID</strong></p>\n<ul>\n<li>Atomic：原子性，同时执行的sql要么一起成功，要么一起失败</li>\n<li>Consistency：一致性，事务之前前后数据都应该是正确的</li>\n<li>Isolation：隔离性，多个事务之间不互相干扰</li>\n<li>Durability：持久性</li>\n</ul>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><ul>\n<li>读未提交：事务A读取到事务B还没有提交的数据</li>\n<li>读已提交：事务A读取到原来的数据，然后事务B提交修改，事务A再次读取，读到不一样的数据。（不可重复读）</li>\n<li>可重复读：事务A读取到原来的数据，然后事务B提交修改，事务A再次读取，读到的还是事务A最开始读取到的数据。（可重复读）</li>\n<li>幻读（不是隔离级别）：事务A查询所有数据，准备插入一一条数据，事务B插入了一行数据，事务B提交插入。事务A想要插入数据，发现这个数据已经存在（被事务B插入）。</li>\n<li>串行化（为了解决幻读）：事务A查询所有数据，事务B想要插入一行数据会被拒绝。事务A提交后，事务B才能进行插入数据。</li>\n</ul>\n<p><strong>MySQL默认级别：可重复读。</strong></p>\n<p><strong>实现可重复读的机制</strong>：MVCC机制 multi-version concurrency control</p>\n<ul>\n<li><p>事务id是全局唯一且递增的，</p>\n</li>\n<li><p>查询事务只会找比自己事务id小的 创建事务。</p>\n<ul>\n<li><p>创建事务id&lt;&#x3D;当前事务id</p>\n</li>\n<li><p>当前事务id&lt;删除事务id</p>\n</li>\n</ul>\n</li>\n<li><p>不同事务修改某行数据，会多出来一行，id相同。</p>\n</li>\n</ul>\n<h3 id=\"数据库锁\"><a href=\"#数据库锁\" class=\"headerlink\" title=\"数据库锁\"></a>数据库锁</h3><p><strong>自动加锁</strong></p>\n<p>表锁 行锁 页锁</p>\n<ul>\n<li>myisam会加表锁。锁表的时候查询会报504</li>\n</ul>\n<p>行锁：innodb：共享锁（s）和排他锁（x）</p>\n<ul>\n<li>共享锁和排他锁不能同时加</li>\n<li>select 不加锁因为MVCC有快照，增删改会加一个行锁排他锁。</li>\n</ul>\n<p><strong>手动加锁</strong></p>\n<p>加共享锁：select * from table where id &#x3D; 1 lock in share mode</p>\n<p>加排他锁：select * from table where id &#x3D;1 for update</p>\n<p><strong>悲观锁</strong>：进行操作都加上排他锁</p>\n<p><strong>乐观锁</strong>：加上版本号字段，在事务修改期间如果版本号不同，则这次修改失败，需要重新读取操作。</p>\n<p><strong>死锁</strong>：dba查看死锁日志。</p>\n<h3 id=\"MySQL调优的常用手段\"><a href=\"#MySQL调优的常用手段\" class=\"headerlink\" title=\"MySQL调优的常用手段\"></a>MySQL调优的常用手段</h3><ul>\n<li>保持sql简单，建议使用单表查询<ul>\n<li>优化索引</li>\n<li>查看sql的执行计划：explain select * from table</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"E-R图\"><a href=\"#E-R图\" class=\"headerlink\" title=\"E-R图\"></a>E-R图</h3><p>entities-relationship图</p>\n<p>关系：操作数是关系，重复行的对应关系（投影）要去掉。剩下的是关系：一对多，一对一，多对多等</p>\n<h2 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h2><p>直接使用tcp进行通信，就是socket编程</p>\n<p>可以认为socket处于传输层。或者是介于传输层和应用层直接。</p>\n<p>socket 就是封装了tcp的编程规范</p>\n<h2 id=\"进程通信和线程切换\"><a href=\"#进程通信和线程切换\" class=\"headerlink\" title=\"进程通信和线程切换\"></a>进程通信和线程切换</h2><h3 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3><p>9.1.1管道 pipe</p>\n<p>只有父子进程（fork得到的）才能使用这个管道进行通信。</p>\n<p>9.1.2命名管道</p>\n<p>无亲缘关系的管道可以使用命名管道通信</p>\n<p>9.1.3消息队列</p>\n<p>9.1.4共享内存</p>\n<h3 id=\"线程如何切换\"><a href=\"#线程如何切换\" class=\"headerlink\" title=\"线程如何切换\"></a>线程如何切换</h3><p>时间片轮换</p>\n<p>优先级调度等</p>\n<h2 id=\"nio，bio，aio都是什么，有什么区别。nio的原理是什么\"><a href=\"#nio，bio，aio都是什么，有什么区别。nio的原理是什么\" class=\"headerlink\" title=\"nio，bio，aio都是什么，有什么区别。nio的原理是什么\"></a>nio，bio，aio都是什么，有什么区别。nio的原理是什么</h2><h3 id=\"bio通信原理\"><a href=\"#bio通信原理\" class=\"headerlink\" title=\"bio通信原理\"></a>bio通信原理</h3><p>服务端使用ServerSocket为每一个客户端建立一个线程用于通信。只要客户端还和服务端有连接，这个线程都要等待。</p>\n<p>问题：超过几千客户端就不能够正常运行了</p>\n<h3 id=\"nio通信原理\"><a href=\"#nio通信原理\" class=\"headerlink\" title=\"nio通信原理\"></a>nio通信原理</h3><p>每有一个客户端和服务端建立连接，都会创建一个channel，这些channel都会注册在selector中，这个selector只有一个线程。会不断轮询这些channel。，如果有请求过来，会创建一个线程来处理这个请求。处理完成后这个线程会被销毁。</p>\n<p>可以对处理请求的线程创建一个线程池。</p>\n<p>在工作线程和channel 直接可以维护一个cache</p>\n<p>工作线程从channel 中读取数据，给channel写数据，是同步的</p>\n<h3 id=\"aio\"><a href=\"#aio\" class=\"headerlink\" title=\"aio\"></a>aio</h3><p>对nio有优化：工作进程从channel读数据的时候，会绑定一个buffer，让操作系统来完成读操作，读完了来通知这个线程。</p>\n<p>写的时候也是把写的过程交给操作系统。</p>\n<h3 id=\"同步阻塞、同步非阻塞、异步非阻塞\"><a href=\"#同步阻塞、同步非阻塞、异步非阻塞\" class=\"headerlink\" title=\"同步阻塞、同步非阻塞、异步非阻塞\"></a>同步阻塞、同步非阻塞、异步非阻塞</h3><p>BIO是同步阻塞，针对的是对磁盘文件的io读写。读写过程中线程阻塞</p>\n<p>NIO是同步非阻塞，在操作系统读写数据的时候，线程可以做其他事情，但是也需要不断轮询判断读写完成了没有。</p>\n<p>AIO 是异步非阻塞，发起文件读写的操作之后，交给操作系统，操作系统执行完毕之后，会通知这个线程。</p>\n<h3 id=\"BIO-NIO-AIO-demo代码\"><a href=\"#BIO-NIO-AIO-demo代码\" class=\"headerlink\" title=\"BIO NIO AIO demo代码\"></a>BIO NIO AIO demo代码</h3><p>TOREAD</p>\n<h2 id=\"线上服务器问题\"><a href=\"#线上服务器问题\" class=\"headerlink\" title=\"线上服务器问题\"></a>线上服务器问题</h2><h3 id=\"线上CPU占用100-，排查步骤：\"><a href=\"#线上CPU占用100-，排查步骤：\" class=\"headerlink\" title=\"线上CPU占用100%，排查步骤：\"></a>线上CPU占用100%，排查步骤：</h3><ul>\n<li>top -c 输入P ，按照cpu进行排序</li>\n<li>top -Hp pid ，可以看到这个进程的负载</li>\n<li>把线程pid换成16进制pidhex，如何使用jstack pid | grep pidhex -C5 –color 就可以定位到线程中哪行代码的cpu占用最高。</li>\n</ul>\n<h3 id=\"如果线上进程kill不掉怎么办\"><a href=\"#如果线上进程kill不掉怎么办\" class=\"headerlink\" title=\"如果线上进程kill不掉怎么办\"></a>如果线上进程kill不掉怎么办</h3><p>ps aux 查看是否有僵尸进程 zombie</p>\n<p>ps -ef  | grep 僵尸进程id ，得到父进程id</p>\n<p>然后kill 父进程之后kill子进程。</p>\n<h3 id=\"磁盘马上占满了怎么办\"><a href=\"#磁盘马上占满了怎么办\" class=\"headerlink\" title=\"磁盘马上占满了怎么办\"></a>磁盘马上占满了怎么办</h3><p>是否是日志占满空间了？</p>\n<p>经历：安装程序的时候提示根目录空间占用100%，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm -rf删除了这些日志&#x2F;var&#x2F;log&#x2F;pcp&#x2F;pmlogger&#x2F;openEuler1&#x2F;。</p>\n<p>关于pcp：</p>\n<ul>\n<li>Performance Co-Pilot (<code>pcp</code>) 提供了支持系统级性能监控和管理的框架和服务。它为系统中的所有性能数据提供了统一的抽象，以及用于询问、检索和处理该数据的许多工具。 \t</li>\n<li>这些生成的log，在openeuler系统没有设置自动清理，导致了日志积累。</li>\n</ul>\n<p> \t</p>\n<p>find &#x2F; -size+100M | xargs ls -lh  找大于100m的文件</p>\n<h2 id=\"Java语言特性\"><a href=\"#Java语言特性\" class=\"headerlink\" title=\"Java语言特性\"></a>Java语言特性</h2><h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><ul>\n<li>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong>：<ul>\n<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>\n<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本</li>\n</ul>\n</li>\n<li>想要通过传值来修改原来的值<ul>\n<li>通过数组</li>\n<li>通过类</li>\n<li>或者其他可变的引用类型</li>\n</ul>\n</li>\n<li>不可变的引用类型<ul>\n<li>String</li>\n<li>Integer</li>\n<li>BigDecimal</li>\n<li>LocalDate、LocalTime、LocalDateTime、Duration，Period</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h3><ul>\n<li><p>序列化协议属于应用层或者传输层</p>\n</li>\n<li><p>序列化的对象：实现Serializable 接口的类、实例变量的值、非静态成员变量</p>\n</li>\n<li><p>serialVersionUID：用来判断对象版本。手动设置这个变量可以解决对象版本兼容问题。</p>\n</li>\n<li><p>Kryo用来序列化Java代码性能高。</p>\n<ul>\n<li><pre><code class=\"java\">import com.esotericsoftware.kryo.Kryo;\nimport com.esotericsoftware.kryo.io.Input;\nimport com.esotericsoftware.kryo.io.Output;\n\nimport java.io.*;\n\npublic class KryoSerializationExample &#123;\n    public static void main(String[] args) &#123;\n        // 创建 Kryo 对象\n        Kryo kryo = new Kryo();\n\n        // 创建要序列化的对象\n        Person person = new Person(&quot;Alice&quot;, 30);\n\n        // 序列化\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        Output output = new Output(outputStream);\n        kryo.writeObject(output, person);\n        output.close();\n\n        // 将序列化的数据保存到文件\n        try (FileOutputStream fileOutputStream = new FileOutputStream(&quot;person.dat&quot;)) &#123;\n            outputStream.writeTo(fileOutputStream);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        // 反序列化\n        try (FileInputStream fileInputStream = new FileInputStream(&quot;person.dat&quot;)) &#123;\n            // 创建 Kryo 输入流\n            Input input = new Input(fileInputStream);\n\n            // 从输入流中反序列化对象\n            Person deserializedPerson = kryo.readObject(input, Person.class);\n            input.close();\n\n            // 使用反序列化后的对象\n            System.out.println(&quot;姓名: &quot; + deserializedPerson.getName());\n            System.out.println(&quot;年龄: &quot; + deserializedPerson.getAge());\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"泛型和通配符\"><a href=\"#泛型和通配符\" class=\"headerlink\" title=\"泛型和通配符\"></a>泛型和通配符</h3><ol>\n<li>泛型（Generics）：泛型允许在编译时指定类、接口或方法操作的数据类型，以提供类型安全和代码重用。通过使用泛型，可以在编译时捕获类型错误，并避免在运行时出现类型转换错误。<ul>\n<li>定义泛型类：使用 <code>&lt;T&gt;</code> 来表示类型参数，可以在类名后面声明一个泛型类型。例如：<code>class MyClass&lt;T&gt; &#123; ... &#125;</code>。</li>\n<li>定义泛型方法：使用 <code>&lt;T&gt;</code> 来表示类型参数，可以在方法返回类型前声明一个泛型类型。例如：<code>&lt;T&gt; T myMethod(T obj) &#123; ... &#125;</code>。</li>\n<li>约定<ul>\n<li><code>E</code>：表示集合中的元素类型。</li>\n<li><code>K</code>：表示映射中的键类型。</li>\n<li><code>V</code>：表示映射中的值类型。</li>\n<li><code>T</code>：表示任意类型。</li>\n<li><code>S</code>、<code>U</code>、<code>V</code>：用于表示第二、第三和第四类型参数。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>类型通配符（Wildcard）：类型通配符用问号 <code>?</code> 表示，用于灵活处理不同类型的泛型对象。通配符可以用于泛型类、泛型方法和通配符限定。<ul>\n<li>通配符限定上界：<code>? extends Type</code>，表示泛型参数是 Type 类型或其子类。例如：<code>List&lt;? extends Number&gt;</code> 表示一个只能接受 Number 及其子类的 List。</li>\n<li>通配符限定下界：<code>? super Type</code>，表示泛型参数是 Type 类型或其父类。例如：<code>List&lt;? super Integer&gt;</code> 表示一个只能接受 Integer 及其父类的 List。</li>\n<li>无限制通配符：<code>?</code>，表示可以是任意类型。例如：<code>List&lt;?&gt;</code> 表示一个可以接受任意类型的 List。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><h5 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h5><pre><code class=\"java\">//获取类\nClass&lt;?&gt; myClass = MyClass.class;\nClass&lt;?&gt; myClass = Class.forName(&quot;com.example.MyClass&quot;);\n//获取构造函数\nConstructor&lt;?&gt; constructor = myClass.getDeclaredConstructor(parameterTypes);\n//创建对象\nObject myObject = constructor.newInstance(arguments);\n//获取方法\nMethod method = myClass.getDeclaredMethod(&quot;methodName&quot;, parameterTypes);\n//调用方法\nmethod.invoke(myObject, arguments);\n//获取字段\nField field = myClass.getDeclaredField(&quot;fieldName&quot;);\n//获取字段的值\nObject fieldValue = field.get(myObject);\n//设置字段的值\nfield.set(myObject, value);\n//对于私有方法或字段，可能需要使用setAccessible(true)来绕过访问限制。\n</code></pre>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><h5 id=\"1-静态代理：\"><a href=\"#1-静态代理：\" class=\"headerlink\" title=\"1.静态代理：\"></a>1.静态代理：</h5><p>就是把在调用类的前后在执行一些步骤。</p>\n<pre><code class=\"java\">public class SmsProxy implements SmsService &#123;\n\n    private final SmsService smsService;\n\n    public SmsProxy(SmsService smsService) &#123;\n        this.smsService = smsService;\n    &#125;\n\n    @Override\n    public String send(String message) &#123;\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(&quot;before method send()&quot;);\n        smsService.send(message);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(&quot;after method send()&quot;);\n        return null;\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"2-动态代理\"><a href=\"#2-动态代理\" class=\"headerlink\" title=\"2.动态代理\"></a>2.动态代理</h5><p><strong>2.1JDK代理：在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>\n<pre><code class=\"java\">//调用proxy的方法newProxyInstance\nProxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),new DebugInvocationHandler(target));\n//DebugInvocationHandler 是自定义的proxy方法，需要实现InvocationHandler接口的invoke方法，实际上是调用了这里的invoke方法\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\npublic class DebugInvocationHandler implements InvocationHandler &#123;\n    private final Object target;\n    public DebugInvocationHandler(Object target) &#123;\n        this.target = target;\n    &#125;\n    @Override\n    public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123;\n        System.out.println(&quot;before Method&quot;+ method.getName());\n        Object result = method.invoke(target, objects);\n        System.out.println(&quot;after Method&quot;+ method.getName());\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>JDK 动态代理有一个最致命的问题是其<strong>只能代理实现了接口的类</strong>。</p>\n<p>为了解决这个问题，我们可以用 CGLIB 动态代理机制。</p>\n<p><strong>2.2CGLIB代理</strong></p>\n<ul>\n<li><p>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</p>\n</li>\n<li><p>maven依赖：</p>\n<ul>\n<li><pre><code class=\"xml\">&lt;dependency&gt;\n  &lt;groupId&gt;cglib&lt;/groupId&gt;\n  &lt;artifactId&gt;cglib&lt;/artifactId&gt;\n  &lt;version&gt;3.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><pre><code class=\"java\">//代理工厂中生成一个 enhancer对象，这个对象拥有下列属性，其中DebugMethodInterceptor拦截器是自定义的最终执行的方法\npublic class CglibProxyFactory &#123;\n    public static Object getProxy(Class&lt;?&gt; clazz)&#123;\n        Enhancer enhancer = new Enhancer();\n        enhancer.setClassLoader(clazz.getClassLoader());\n        enhancer.setSuperclass(clazz);\n        enhancer.setCallback(new DebugMethodInterceptor());\n        return enhancer.create();\n    &#125;\n&#125;\n//DebugMethodInterceptor 实现MethodInterceptor接口，重写intercept方法，这个方法相当于前面的invoke\npublic class DebugMethodInterceptor implements MethodInterceptor &#123;\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(&quot;before method &quot; + method.getName());\n        Object object = methodProxy.invokeSuper(o, objects);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(&quot;after method &quot; + method.getName());\n        return object;\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n<p><strong>2.3二者的区别</strong></p>\n<p>jdk动态代理，有接口的时候使用，生成一个实现这些同样接口的对象。</p>\n<p>没有接口会使用cglib来生成你的类的子类，覆盖你的类的方法，在方法中加入增强的代码。</p>\n<h3 id=\"BigDecimal常见方法\"><a href=\"#BigDecimal常见方法\" class=\"headerlink\" title=\"BigDecimal常见方法\"></a>BigDecimal常见方法</h3><p>我们在使用 <code>BigDecimal</code> 时，为了防止精度丢失，推荐使用它的<code>BigDecimal(String val)</code>构造方法或者 <code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象。</p>\n<p><strong>使用BigDecimal(double val)会丢失精度</strong></p>\n<p>方法：</p>\n<ul>\n<li>add：加</li>\n<li>subtract：减</li>\n<li>multiple：乘</li>\n<li>divide：除<ul>\n<li>除的时候尽量使用三个参数的版本：指定保留规则RoundingMode</li>\n</ul>\n</li>\n<li>compareTo：<code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1 表示 <code>a</code> 大于 <code>b</code>。<ul>\n<li>比较不能使用equals，因为equals比较会同时比较精度，1.0和1.00不相同</li>\n</ul>\n</li>\n<li>setScale：保留小数</li>\n</ul>\n<p>工具类：</p>\n<details><summary>点击查看代码</summary>\n <pre><code>\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n/**\n * 简化BigDecimal计算的小工具类\n */\npublic class BigDecimalUtil &#123;\n    /**\n     * 默认除法运算精度\n     */\n    private static final int DEF_DIV_SCALE = 10;\n    private BigDecimalUtil() &#123;\n    &#125;\n    /**\n     * 提供精确的加法运算。\n     *\n     * @param v1 被加数\n     * @param v2 加数\n     * @return 两个参数的和\n     */\n    public static double add(double v1, double v2) &#123;\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.add(b2).doubleValue();\n    &#125;\n    /**\n     * 提供精确的减法运算。\n     *\n     * @param v1 被减数\n     * @param v2 减数\n     * @return 两个参数的差\n     */\n    public static double subtract(double v1, double v2) &#123;\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.subtract(b2).doubleValue();\n    &#125;\n    /**\n     * 提供精确的乘法运算。\n     *\n     * @param v1 被乘数\n     * @param v2 乘数\n     * @return 两个参数的积\n     */\n    public static double multiply(double v1, double v2) &#123;\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.multiply(b2).doubleValue();\n    &#125;\n    /**\n     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到\n     * 小数点以后10位，以后的数字四舍五入。\n     *\n     * @param v1 被除数\n     * @param v2 除数\n     * @return 两个参数的商\n     */\n    public static double divide(double v1, double v2) &#123;\n        return divide(v1, v2, DEF_DIV_SCALE);\n    &#125;\n    /**\n     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指\n     * 定精度，以后的数字四舍五入。\n     *\n     * @param v1    被除数\n     * @param v2    除数\n     * @param scale 表示表示需要精确到小数点以后几位。\n     * @return 两个参数的商\n     */\n    public static double divide(double v1, double v2, int scale) &#123;\n        if (scale < 0) &#123;\n            throw new IllegalArgumentException(\n                    \"The scale must be a positive integer or zero\");\n        &#125;\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.divide(b2, scale, RoundingMode.HALF_EVEN).doubleValue();\n    &#125;\n    /**\n     * 提供精确的小数位四舍五入处理。\n     *\n     * @param v     需要四舍五入的数字\n     * @param scale 小数点后保留几位\n     * @return 四舍五入后的结果\n     */\n    public static double round(double v, int scale) &#123;\n        if (scale < 0) &#123;\n            throw new IllegalArgumentException(\n                    \"The scale must be a positive integer or zero\");\n        &#125;\n        BigDecimal b = BigDecimal.valueOf(v);\n        BigDecimal one = new BigDecimal(\"1\");\n        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();\n    &#125;\n    /**\n     * 提供精确的类型转换(Float)\n     *\n     * @param v 需要被转换的数字\n     * @return 返回转换结果\n     */\n    public static float convertToFloat(double v) &#123;\n        BigDecimal b = new BigDecimal(v);\n        return b.floatValue();\n    &#125;\n    /**\n     * 提供精确的类型转换(Int)不进行四舍五入\n     *\n     * @param v 需要被转换的数字\n     * @return 返回转换结果\n     */\n    public static int convertsToInt(double v) &#123;\n        BigDecimal b = new BigDecimal(v);\n        return b.intValue();\n    &#125;\n    /**\n     * 提供精确的类型转换(Long)\n     *\n     * @param v 需要被转换的数字\n     * @return 返回转换结果\n     */\n    public static long convertsToLong(double v) &#123;\n        BigDecimal b = new BigDecimal(v);\n        return b.longValue();\n    &#125;\n    /**\n     * 返回两个数中大的一个值\n     *\n     * @param v1 需要被对比的第一个数\n     * @param v2 需要被对比的第二个数\n     * @return 返回两个数中大的一个值\n     */\n    public static double returnMax(double v1, double v2) &#123;\n        BigDecimal b1 = new BigDecimal(v1);\n        BigDecimal b2 = new BigDecimal(v2);\n        return b1.max(b2).doubleValue();\n    &#125;\n    /**\n     * 返回两个数中小的一个值\n     *\n     * @param v1 需要被对比的第一个数\n     * @param v2 需要被对比的第二个数\n     * @return 返回两个数中小的一个值\n     */\n    public static double returnMin(double v1, double v2) &#123;\n        BigDecimal b1 = new BigDecimal(v1);\n        BigDecimal b2 = new BigDecimal(v2);\n        return b1.min(b2).doubleValue();\n    &#125;\n    /**\n     * 精确对比两个数字\n     *\n     * @param v1 需要被对比的第一个数\n     * @param v2 需要被对比的第二个数\n     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1\n     */\n    public static int compareTo(double v1, double v2) &#123;\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.compareTo(b2);\n    &#125;\n&#125;\n    </code></pre>\n</details>\n\n<h3 id=\"Unsafe类\"><a href=\"#Unsafe类\" class=\"headerlink\" title=\"Unsafe类\"></a><a href=\"https://javaguide.cn/java/basis/unsafe.html\">Unsafe类</a></h3><p>在JUC高并发编程中主要使用，用来执行本地方法（native方法）。</p>\n<p>native方法的执行绕过了Java本身的界限。能直接接触到操作系统底层的某些功能，因此并不安全。</p>\n<p>可以实现的功能：</p>\n<ol>\n<li>内存操作</li>\n<li>内存屏障</li>\n<li>对象操作</li>\n<li>数据操作</li>\n<li>CAS 操作</li>\n<li>线程调度</li>\n<li>Class 操作</li>\n<li>系统信息</li>\n</ol>\n<p>因为其不安全性，并不推荐使用。</p>\n<h3 id=\"SPI机制\"><a href=\"#SPI机制\" class=\"headerlink\" title=\"SPI机制\"></a>SPI机制</h3><h3 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"面经\"><a href=\"#面经\" class=\"headerlink\" title=\"面经\"></a>面经</h1><h2 id=\"Java基础知识\"><a href=\"#Java基础知识\" class=\"headerlink\" title=\"Java基础知识\"></a>Java基础知识</h2><h3 id=\"为什么说Java是编译和解释的语言\"><a href=\"#为什么说Java是编译和解释的语言\" class=\"headerlink\" title=\"为什么说Java是编译和解释的语言\"></a>为什么说Java是编译和解释的语言</h3><p>Java需要把代码编译成.class的字节码文件，然后再解释成机器码。</p>\n<h3 id=\"静态方法中为什么不能调用非静态方法\"><a href=\"#静态方法中为什么不能调用非静态方法\" class=\"headerlink\" title=\"静态方法中为什么不能调用非静态方法\"></a>静态方法中为什么不能调用非静态方法</h3><p>因为静态方法在类创建的时候生成，非静态方法在实例化对象之后才生成。</p>\n<h3 id=\"重载和重写\"><a href=\"#重载和重写\" class=\"headerlink\" title=\"重载和重写\"></a>重载和重写</h3><p>重载：同方法名，不同参数</p>\n<p>重写：子类重写父类的方法，方法名参数相同，构造方法无法重写</p>\n<h3 id=\"可变长参数public-void-test-String-…args\"><a href=\"#可变长参数public-void-test-String-…args\" class=\"headerlink\" title=\"可变长参数public void test(String …args)\"></a>可变长参数public void test(String …args)</h3><p>可以接收不同长度的参数，重载的时候优先匹配固定长度参数的方法。</p>\n<h3 id=\"对象实体和对象引用\"><a href=\"#对象实体和对象引用\" class=\"headerlink\" title=\"对象实体和对象引用\"></a>对象实体和对象引用</h3><p>new 来创建一个对象实体，一个对象实体可以有多个对象引用。一个对象引用可以指向一个对象实体。</p>\n<p>对象实体存在堆内存中（类和对象都存放在堆内存中）</p>\n<p>对象引用存放在栈内存中</p>\n<h3 id=\"对象默认有无参构造，但创建有参构造后要手动创建无参构造。\"><a href=\"#对象默认有无参构造，但创建有参构造后要手动创建无参构造。\" class=\"headerlink\" title=\"对象默认有无参构造，但创建有参构造后要手动创建无参构造。\"></a>对象默认有无参构造，但创建有参构造后要手动创建无参构造。</h3><h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>子类在调用父类的方法的时候，只有在运行的时候，才知道调用的是哪个方法（父类的还是子类的），这个方法具有多态性</p>\n<h3 id=\"接口和抽象类的区别\"><a href=\"#接口和抽象类的区别\" class=\"headerlink\" title=\"接口和抽象类的区别\"></a>接口和抽象类的区别</h3><ul>\n<li>相同点：<ul>\n<li>都不能被实例化</li>\n<li>都可以包含抽象方法</li>\n<li>都可以有默认实现的方法，接口中可以定义default方法来实现</li>\n</ul>\n</li>\n<li>不同点<ul>\n<li>接口主要是对对象的约束，约束对象的行为（实现接口的方法）</li>\n<li>抽象类主要是代码的复用性的规定</li>\n<li>一个类只可以继承一个类，但可以实现多个接口</li>\n<li>接口中 的成员变量只能是public static final 类型，有初值，不可变</li>\n<li>抽象类中的成员变量默认为default，可在子类中重新定义和赋值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"深拷贝和浅拷贝\"><a href=\"#深拷贝和浅拷贝\" class=\"headerlink\" title=\"深拷贝和浅拷贝\"></a>深拷贝和浅拷贝</h3><p>浅拷贝：在对上创建一个新对象，如果被拷贝的是引用类型，则会直接复制它引用的地址</p>\n<p>深拷贝：复制整个对象，包含内部对象</p>\n<h3 id=\"Object-的常用方法\"><a href=\"#Object-的常用方法\" class=\"headerlink\" title=\"Object 的常用方法\"></a>Object 的常用方法</h3><details><summary>点击展开代码</summary><pre><code>/**\n * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\n */\npublic final native Class<?> getClass()\n/**\n * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\n */\npublic native int hashCode()\n/**\n * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\n */\npublic boolean equals(Object obj)\n/**\n * native 方法，用于创建并返回当前对象的一份拷贝。\n */\nprotected native Object clone() throws CloneNotSupportedException\n/**\n * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\n */\npublic String toString()\n/**\n * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n */\npublic final native void notify()\n/**\n * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n */\npublic final native void notifyAll()\n/**\n * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\n */\npublic final native void wait(long timeout) throws InterruptedException\n/**\n * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。\n */\npublic final void wait(long timeout, int nanos) throws InterruptedException\n/**\n * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n */\npublic final void wait() throws InterruptedException\n/**\n * 实例被垃圾回收器回收的时候触发的操作\n */\nprotected void finalize() throws Throwable &#123; &#125;</code></pre></details>\n\n<p>hashcode 和 equals 都是判断对象是否相同的方法</p>\n<p>hashcode 可能会碰撞，equals 是比较地址但效率较低</p>\n<p>重写equals也应当重写hashcode方法。</p>\n<h3 id=\"String-StringBuffer-StringBuilder-的区别\"><a href=\"#String-StringBuffer-StringBuilder-的区别\" class=\"headerlink\" title=\"String StringBuffer StringBuilder 的区别\"></a>String StringBuffer StringBuilder 的区别</h3><ul>\n<li><p>String 对象不可变，String a &#x3D; “test”;  a &#x3D; “test1” 。更改a的值的时候，是创建了一个新的String对象，将地址赋给a。是线程安全的</p>\n</li>\n<li><p>StringBuffer 和 StringBuilder 更改值，不用新建对象。</p>\n</li>\n<li><p>StringBuffer 使用同步锁保证线程安全</p>\n</li>\n<li><p>StringBuilder 是线程不安全的，效率比StringBUffer快10%-15%</p>\n</li>\n</ul>\n<h3 id=\"String拼接、赋值和intern方法\"><a href=\"#String拼接、赋值和intern方法\" class=\"headerlink\" title=\"String拼接、赋值和intern方法\"></a>String拼接、赋值和intern方法</h3><ul>\n<li>在Java9之前，String 用加号连接的方法是使用StringBuilder.append().toString()方法构建的。在之后更新了方法，可以放心使用+连接，性能也不错</li>\n<li>String s &#x3D; new String(“abc”); 这段代码可能会创建 1-2 个字符串对象。 先在字符串常量池创建一个字符串对象abc（如果已存在则不需要再创建），然后复制一份到堆内存中。</li>\n<li>String intern 方法：将引用保存到字符串常量池中（如果已有则不再保存），并且返回这个对象</li>\n</ul>\n<h3 id=\"字符串常量池\"><a href=\"#字符串常量池\" class=\"headerlink\" title=\"字符串常量池\"></a>字符串常量池</h3><h2 id=\"常用数据结构源码解析\"><a href=\"#常用数据结构源码解析\" class=\"headerlink\" title=\"常用数据结构源码解析\"></a>常用数据结构源码解析</h2><h3 id=\"hashmap\"><a href=\"#hashmap\" class=\"headerlink\" title=\"hashmap\"></a>hashmap</h3><ul>\n<li><p>底层是数组+链表+红黑树，非线程安全</p>\n</li>\n<li><p>可存储null的key和value</p>\n</li>\n<li><p>初始大小16，扩容到当前的二倍</p>\n</li>\n<li><p>获取Key的方法：</p>\n<ul>\n<li><pre><code class=\"java\">static final int hash(Object key) &#123;\n  int h;\n  // key.hashCode()：返回散列值也就是hashcode\n  // ^：按位异或\n  // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐\n  return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>元素添加：</p>\n<ul>\n<li>获取数组的index：key对hashmap的length取模（将key和length-1与，比%取模的性能好）</li>\n<li>如果这个index没有元素，直接添加</li>\n<li>如果有元素则比较key，如果key相同则覆盖。</li>\n<li>如果是hash碰撞，则判断是否是树节点，是就调用putTreeVal加入树节点，否则加入链表尾部</li>\n</ul>\n</li>\n<li><p>hash碰撞使用拉链法</p>\n<ul>\n<li>在hash碰撞的节点创建一个链表，把碰撞的值都放在链表中</li>\n<li>链表元素超过8个，将链表切换成红黑树</li>\n</ul>\n</li>\n<li><p>扩容条件是存放的元素数量超过<code>容量*负载因子</code></p>\n<ul>\n<li>负载因子<strong>loadFactor</strong> 是控制数组存放数据的疏密程度<ul>\n<li>loadFactor越趋近1，数组中存储的元素就越多，碰撞的元素在链表的长度就越多，查询性能下降</li>\n<li>loadFactor越趋近0，hashMap扩容次数增加，rehash消耗性能</li>\n<li>官方给出的默认为0.75</li>\n</ul>\n</li>\n<li>resize就是扩容之后重新计算index和hash碰撞<ul>\n<li>底层就是新开一个数组，将元素重新放入新数组</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><ul>\n<li><p><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。线程不安全。</p>\n<ul>\n<li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>\n<li><code>RandomAccess</code> ：表明它可以快速进行随机访问，get(index)</li>\n<li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>\n<li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li>\n</ul>\n</li>\n<li><p>可以添加null值。</p>\n</li>\n<li><p>底层是Object数组。</p>\n</li>\n<li><p>时间复杂度：add() O(1) ;   add(index,val) O(n) ;</p>\n</li>\n<li><p>空间占用主要是末尾预留的空间。</p>\n</li>\n<li><p>在添加大量元素的时候，可以提前使用ensureCapacity(N)方法预留空间，减少空间分配次数，节约性能。</p>\n</li>\n<li><p>当添加元素大于容量的时候，触发扩容</p>\n<ul>\n<li>扩容：每次newSize&#x3D; oldSize+oldSize&#x2F;2 相当于1.5倍</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><ul>\n<li><code>LinkedList</code> 继承了 <code>AbstractSequentialList</code> ，而 <code>AbstractSequentialList</code> 又继承于 <code>AbstractList</code> 。</li>\n<li><code>LinkedList</code> 实现了<code>List</code>,<code>Deque</code>,<code>Cloneable</code>,<code>Seralizable</code><ul>\n<li><code>Deque</code>：表明它具有双端队列特性，便于两端插入和删除</li>\n</ul>\n</li>\n<li>底层是双向链表</li>\n<li>时间复杂度：add() O(1); add(index,val) O(n) </li>\n<li>空间占用主要是除了data之外的索引等数据</li>\n<li>遍历常用for-each</li>\n<li>基本上不用LinkedList，都用ArrayList，性能一般更好一些</li>\n</ul>\n<h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><h2 id=\"并发编程\"><a href=\"#并发编程\" class=\"headerlink\" title=\"并发编程\"></a>并发编程</h2><h3 id=\"synchronized关键字的底层原理是什么\"><a href=\"#synchronized关键字的底层原理是什么\" class=\"headerlink\" title=\"synchronized关键字的底层原理是什么\"></a>synchronized关键字的底层原理是什么</h3><p>2.1.1synchronized是做什么的</p>\n<p><strong>给线程加锁</strong>，加锁目标是一个类或一个对象。</p>\n<p>2.1.2实现原理</p>\n<p>加锁指令：monitorenter（加锁） monitorexit（释放锁）</p>\n<p>一个对象或类关联有一个monitor（计数器：正在使用的线程数，<strong>类似信号量</strong>）</p>\n<h3 id=\"CAS的理解和底层实现原理\"><a href=\"#CAS的理解和底层实现原理\" class=\"headerlink\" title=\"CAS的理解和底层实现原理\"></a>CAS的理解和底层实现原理</h3><p>多个线程要访问同一个数据会出现并发安全问题。</p>\n<p><code>AtomicInterger</code>并发包的原子类，使用CAS实现。</p>\n<p>2.2.1线程操作AtomicInterger基本流程：</p>\n<p>线程1想要修改值，会</p>\n<ul>\n<li>先读取旧值</li>\n<li>在修改前再次读取这个值</li>\n<li>如果没人修改，则使用CAS进行修改这个值。</li>\n<li>如果第二次读取的值和旧值不同，则CAS失败。</li>\n</ul>\n<p>2.2.2CAS</p>\n<p>CAS：compare and set</p>\n<p>在硬件级别保是原子操作，同一时间只有一个线程可以执行CAS。</p>\n<h3 id=\"ConcurrentHashMap实现线程安全的底层原理\"><a href=\"#ConcurrentHashMap实现线程安全的底层原理\" class=\"headerlink\" title=\"ConcurrentHashMap实现线程安全的底层原理\"></a>ConcurrentHashMap实现线程安全的底层原理</h3><p>2.3.1对hashmap简单的操作，不需要进行synchronized</p>\n<p>一般的操作都是hashmap底层数组的不同的元素进行操作，无需加锁</p>\n<p>ConcurrentHashmap默认实现了线程安全。</p>\n<p>2.3.2在jdk1.7以及之前，对ConcurrentHashmap底层的数组分段加锁。</p>\n<p><strong>一段数组加一个锁</strong>，如果操作的是不同不同段的数组，则不互相影响</p>\n<p>2.3.3在jdk1.8以及之后，不再数组分段，<strong>对数组中每一个元素都加了一个锁</strong>。</p>\n<p>将锁的粒度细化。</p>\n<h3 id=\"JDK中的AQS的实现原理\"><a href=\"#JDK中的AQS的实现原理\" class=\"headerlink\" title=\"JDK中的AQS的实现原理\"></a>JDK中的AQS的实现原理</h3><p><code>ReentrantLock </code>类底层是AQS（Abstract Queue Synchronizer）</p>\n<p>可以使用这个类生成一个锁lock，可以进行lock.lock() lock.unlock()实现互斥。</p>\n<p>2.4.1 AQS会有一个等待队列，存储没有得到锁的线程，待锁释放后，按顺序为等待队列的线程提供锁</p>\n<img src=\"http://gohoy.top/i/2023/07/31/ui6crn-1.png\" alt=\"image-20230731160209376\" style=\"zoom:80%;\" />\n\n<p>2.4.2如果在线程1执行完毕，唤醒线程2的过程中，如果有线程3想要加锁</p>\n<ul>\n<li>非公平锁：ReentrantLock lock &#x3D; new ReentrantLock()；<ul>\n<li>线程3可能会成功得到锁，达到插队。</li>\n</ul>\n</li>\n<li>公平锁：ReentrantLock lock &#x3D; new ReentrantLock(true);<ul>\n<li>如果等待队列有线程，线程3会进入等待队列。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程池的底层工作原理\"><a href=\"#线程池的底层工作原理\" class=\"headerlink\" title=\"线程池的底层工作原理\"></a>线程池的底层工作原理</h3><p>2.5.1线程池：提供一定量的线程，线程执行完成任务后，不销毁自己，等待下一次任务：</p>\n<p><strong>避免重复创建和销毁线程，造成性能浪费</strong></p>\n<p>创建线程池：</p>\n<pre><code class=\"java\">ExecutorService threadPool = Executor.newFixedThreadPool(10)  //(corePoolSize = 10)\nthreadPool.submit(new Callable() &#123;\n    public void run()&#123;&#125;\n&#125;);\n</code></pre>\n<p>有新任务的时候</p>\n<ul>\n<li>如果线程池的线程数量小于容量，则直接创建一个新的线程执行任务。</li>\n<li>如果满了，则放在任务队列中。</li>\n</ul>\n<p>当线程完成自己的任务的时候，会去任务队列中获取任务，如果没有任务，会阻塞，不会销毁。</p>\n<h3 id=\"线程池的核心配置参数\"><a href=\"#线程池的核心配置参数\" class=\"headerlink\" title=\"线程池的核心配置参数\"></a>线程池的核心配置参数</h3><p>代表线程池的类是ThreadPoolExecutor</p>\n<pre><code class=\"java\">return new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;())\n</code></pre>\n<ul>\n<li><code>corePoolSize：3</code><ul>\n<li>一般最大线程数只有3</li>\n</ul>\n</li>\n<li><code>maximumPoolSize：200</code><ul>\n<li>当任务队列满了，可以最多额外创建到200个，执行任务并从任务队列获取任务</li>\n</ul>\n</li>\n<li><code>keepAliveTime：60s</code><ul>\n<li>任务队列空了60s后，额外线程自动会销毁掉</li>\n</ul>\n</li>\n<li><code>new ArrayBlockingQueue&lt;Runnable&gt;(200)</code><ul>\n<li>任务队列</li>\n</ul>\n</li>\n</ul>\n<p>如果额外线程也满了，会报异常。可以自定义RejectedExecutionHandler策略来应对这种情况：持久化被reject的任务，等负载低了再加载执行。</p>\n<h3 id=\"如果在线程池中使用无界阻塞队列会发生什么问题\"><a href=\"#如果在线程池中使用无界阻塞队列会发生什么问题\" class=\"headerlink\" title=\"如果在线程池中使用无界阻塞队列会发生什么问题\"></a>如果在线程池中使用无界阻塞队列会发生什么问题</h3><h4 id=\"面试题1：如果使用无界阻塞队列调用远程服务，远程服务异常，会不会导致内存异常飙升\"><a href=\"#面试题1：如果使用无界阻塞队列调用远程服务，远程服务异常，会不会导致内存异常飙升\" class=\"headerlink\" title=\"面试题1：如果使用无界阻塞队列调用远程服务，远程服务异常，会不会导致内存异常飙升\"></a>面试题1：如果使用无界阻塞队列调用远程服务，远程服务异常，会不会导致内存异常飙升</h4><p>调用超时，队列变得越来越大，内存会飙升，可能会导致OOM。</p>\n<h3 id=\"线程池队列满了之后，会发生什么\"><a href=\"#线程池队列满了之后，会发生什么\" class=\"headerlink\" title=\"线程池队列满了之后，会发生什么\"></a>线程池队列满了之后，会发生什么</h3><ul>\n<li>如果给maximumPoolSize设置太大，可能会导致系统崩溃。因为线程会占用一定内存，也会增加cpu负载。</li>\n<li>如果给maximumPoolSize设置太小，可能会导致任务reject。</li>\n</ul>\n<h3 id=\"如果机器突然宕机，线程池的阻塞队列的任务怎么办\"><a href=\"#如果机器突然宕机，线程池的阻塞队列的任务怎么办\" class=\"headerlink\" title=\"如果机器突然宕机，线程池的阻塞队列的任务怎么办\"></a>如果机器突然宕机，线程池的阻塞队列的任务怎么办</h3><p><strong>都会丢失</strong></p>\n<p>解决办法：在数据库对任务信息进行持久化。</p>\n<h2 id=\"谈谈对Java内存模型的理解\"><a href=\"#谈谈对Java内存模型的理解\" class=\"headerlink\" title=\"谈谈对Java内存模型的理解\"></a>谈谈对Java内存模型的理解</h2><pre><code class=\"java\">public class HelloWorld &#123;\n    private int data;\n    public void increment()&#123;\n        data++;\n    &#125;\n&#125;\nHelloWorld helloWorld = new HelloWorld(); //对象存放在堆内存，包含对象中的实例变量\n//线程1\nnew Thread()&#123;\n    public void run()&#123;\n        helloWorld.increment();\n    &#125;\n&#125;.start()\n//线程2\nnew Thread()&#123;\n    public void run()&#123;\n        helloWorld.increment();\n    &#125;\n&#125;.start()\n   \n</code></pre>\n<p>常量：主存（内存）</p>\n<p>线程的工作内存：cpu缓存</p>\n<p>常量操作：read load use assign store write</p>\n<img src=\"http://gohoy.top/i/2023/07/31/ui6jyh-1.png\" alt=\"image-20230731165920298\" style=\"zoom: 80%;\" />\n\n<h3 id=\"可见性、原子性、有序性\"><a href=\"#可见性、原子性、有序性\" class=\"headerlink\" title=\"可见性、原子性、有序性\"></a>可见性、原子性、有序性</h3><ul>\n<li>可见性<ul>\n<li>没有可见性：线程1更新了数据，但是线程2看到的还是工作内存中旧的数据</li>\n<li>有可见性：数据更新之后，线程1会强制使线程2重新读取修改后的数据。</li>\n</ul>\n</li>\n<li>原子性<ul>\n<li>一次只有一个线程进入临界区。data++必须是独立执行的。</li>\n</ul>\n</li>\n<li>有序性<ul>\n<li>在任务需要的资源准备完全之后，执行该线程任务。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"从底层角度聊volatile关键字原理\"><a href=\"#从底层角度聊volatile关键字原理\" class=\"headerlink\" title=\"从底层角度聊volatile关键字原理\"></a>从底层角度聊volatile关键字原理</h3><p>volatile：用来解决<strong>可见性和有序性</strong>，对原子性的保证很有限。（对64位的long型有一定原子性保证）</p>\n<ul>\n<li>实现可见性<ul>\n<li><strong>当加上volatile的变量改变时，会使其他线程工作内存的过期变量失效。</strong></li>\n</ul>\n</li>\n<li>保证有序性<ul>\n<li>保证写在读之前</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"指令重排和happens-before原则\"><a href=\"#指令重排和happens-before原则\" class=\"headerlink\" title=\"指令重排和happens-before原则\"></a>指令重排和happens-before原则</h3><p>指令重排有可能导致有序性失效。</p>\n<p>happens-before原则：</p>\n<ul>\n<li>线程内按照代码顺序，写在前面的代码先行发生在卸载后面的代码。</li>\n<li>锁定操作：对锁的unlock操作先行发生在lock操作</li>\n<li>volatile变量原则：写操作在读操作之前</li>\n<li>传递原则：A先于B，B先于C，则A先于C</li>\n<li>线程启动原则：线程的启动thread.star()先于线程中的其他操作。还有interrupt</li>\n<li>线程终结原则：线程的所有操作都先于线程的终止检测，使用thread.jion()结束。</li>\n<li>对象终结原则：一个对象的初始化完成在finalize()方法之前。</li>\n</ul>\n<h3 id=\"volatile底层如何基于内存屏障保证可见性和有序性\"><a href=\"#volatile底层如何基于内存屏障保证可见性和有序性\" class=\"headerlink\" title=\"volatile底层如何基于内存屏障保证可见性和有序性\"></a>volatile底层如何基于内存屏障保证可见性和有序性</h3><p>对volatile的值的操作代码前后加上内存屏障。</p>\n<p>内存屏障：禁止重排序</p>\n<h2 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h2><h3 id=\"Spring的IOC\"><a href=\"#Spring的IOC\" class=\"headerlink\" title=\"Spring的IOC\"></a>Spring的IOC</h3><p>如果没有IOC：tomcat+servlet：tomcat 监听端口来将请求转发给servlet来处理，耦合严重，需要变动时，修改很麻烦。</p>\n<p>IOC：<strong>依赖注入，控制反转，容器根据xml配置或者注解来对bean对象之间的引用关系进行依赖注入</strong></p>\n<p>底层核心技术：反射。根据类来自动构建对应的对象。</p>\n<p>类与类彻底解耦。</p>\n<p><img src=\"http://gohoy.top/i/2023/08/01/njxvd8-1.png\" alt=\"image-20230801142412643\"></p>\n<h3 id=\"Spring的AOP\"><a href=\"#Spring的AOP\" class=\"headerlink\" title=\"Spring的AOP\"></a>Spring的AOP</h3><p>MySQL：事务：一次开启一个事务，其中进行多次增删改查。如果有一条失败了，会回滚事务，把这个事务中所有的sql语句都恢复。</p>\n<p>AOP:做一个切面Aspect，给所有类似servicexxx代码之前都会开启一个事务，在这些方法运行完毕之后，根据是否抛出异常，去回滚或者提交事务。</p>\n<p>核心技术：动态代理</p>\n<p><strong>Spring会给正在运行的类生成动态代理类，包含我们写的类。然后在代理类中给逻辑前后加上事务。</strong></p>\n<p>如何限定AOP。</p>\n<p>TODO</p>\n<h3 id=\"了解过cglib动态代理吗，他和jdk动态代理的区别是什么\"><a href=\"#了解过cglib动态代理吗，他和jdk动态代理的区别是什么\" class=\"headerlink\" title=\"了解过cglib动态代理吗，他和jdk动态代理的区别是什么\"></a>了解过cglib动态代理吗，他和jdk动态代理的区别是什么</h3><p>jdk动态代理，有接口的时候使用，生成一个实现这些同样接口的对象。</p>\n<p>没有接口会使用cglib来生成你的类的子类，覆盖你的类的方法，在方法中加入增强的代码。</p>\n<h3 id=\"spring事务的实现原理是什么，事务传播机制是什么\"><a href=\"#spring事务的实现原理是什么，事务传播机制是什么\" class=\"headerlink\" title=\"spring事务的实现原理是什么，事务传播机制是什么\"></a>spring事务的实现原理是什么，事务传播机制是什么</h3><p>不同事务之间不互相影响</p>\n<p>@Transactional(propagation &#x3D; Propagation.REQUIRED)会开启一个事务</p>\n<ul>\n<li>Propagation_REQUIRED：如果当前没有事务，创建一个事务，多个调用加入到一个事务中。</li>\n<li>Propagation_SUPPORT：之前有事务则加入，没有则不开启。</li>\n<li>Propagation_MANDATORY：有事务加入，没有则报错。</li>\n<li>Propagation_RESQUIRES_NEW：强制开启一个新事务。</li>\n<li>Propagation_NOT_SUPPORTED：不使用事务，有事务会挂起</li>\n<li>Propagation_NEVER：不允许使用事务，有事务会报错</li>\n<li>Propagation_NESTED：嵌套事务，外层事务回滚会导致内存事务也回滚，内层不影响外层。</li>\n</ul>\n<h3 id=\"Springboot-的核心架构\"><a href=\"#Springboot-的核心架构\" class=\"headerlink\" title=\"Springboot 的核心架构\"></a>Springboot 的核心架构</h3><p>自动装配依赖。不需要像spring一样自己配置xml文件，引入jar包。减少了配置。</p>\n<h3 id=\"Spring-核心源码\"><a href=\"#Spring-核心源码\" class=\"headerlink\" title=\"Spring 核心源码\"></a>Spring 核心源码</h3><p>Spring bean 生命周期：</p>\n<ul>\n<li>创建bean<ul>\n<li>实例化一个bean</li>\n<li>依赖注入<ul>\n<li>把这个bean的依赖的bean实例化，也进行依赖注入。注入方法：构造函数，setter方法。</li>\n</ul>\n</li>\n<li>处理Aware接口<ul>\n<li>如果这个bean实现了Aware相关的接口，Spring容器会把自己的信息注入给bean中。</li>\n</ul>\n</li>\n<li>BeanPostProcesser<ul>\n<li>在bean实例初始化之前和之后可以执行的方法。</li>\n</ul>\n</li>\n<li>init初始化方法</li>\n</ul>\n</li>\n<li>销毁<ul>\n<li>DisposableBean接口，会调用这个接口实现的destroy方法</li>\n<li>最后，如果配置了destroy-method方法，会调用这个方法</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Spring中的设计模式\"><a href=\"#Spring中的设计模式\" class=\"headerlink\" title=\"Spring中的设计模式\"></a>Spring中的设计模式</h3><p>工厂，单例，代理</p>\n<p>工厂模式：使用工厂类来创建类。</p>\n<p>单例模式：每个bean在系统运行期间只会创建一个实例对象。</p>\n<p>代理模式：AOP</p>\n<h3 id=\"SpringMVC架构\"><a href=\"#SpringMVC架构\" class=\"headerlink\" title=\"SpringMVC架构\"></a>SpringMVC架构</h3><ul>\n<li>tomcat 监听端口，将请求转发给SpringMVC的DispathcherServlet</li>\n<li>然后SpringMVC再根据url将请求转发给对应的controller</li>\n<li>返回json给前端，前端符合渲染</li>\n</ul>\n<h3 id=\"SpringCloud核心架构\"><a href=\"#SpringCloud核心架构\" class=\"headerlink\" title=\"SpringCloud核心架构\"></a>SpringCloud核心架构</h3><p>这些框架</p>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><h3 id=\"JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进\"><a href=\"#JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进\" class=\"headerlink\" title=\"JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进\"></a>JVM中有哪几块内存区域，Java8之后对内存分代做了什么改进</h3><ul>\n<li>栈内存：每个线程独有</li>\n<li>堆内存：存放对象、实例</li>\n<li>永久代区域：我们写的类</li>\n</ul>\n<p>Java8以后永久代变成metaspace</p>\n<p>常量区放在了堆里面</p>\n<h3 id=\"JVM如何运行起来的，如何创建各种对象\"><a href=\"#JVM如何运行起来的，如何创建各种对象\" class=\"headerlink\" title=\"JVM如何运行起来的，如何创建各种对象\"></a>JVM如何运行起来的，如何创建各种对象</h3><p><strong>线程执行main函数同时创建对象</strong></p>\n<p>Spring容器创建一些bean对象</p>\n<p>把执行的方法和局部变量放在栈帧。</p>\n<h3 id=\"JVM什么时候会触发垃圾回收\"><a href=\"#JVM什么时候会触发垃圾回收\" class=\"headerlink\" title=\"JVM什么时候会触发垃圾回收\"></a>JVM什么时候会触发垃圾回收</h3><p>内存分代：年轻代（eden：s1： s2，  8：1：1 ）和老年代</p>\n<p>年轻代和老年代统称为堆</p>\n<p>新生成的对象实例存放在年轻代。</p>\n<ul>\n<li>ygc：Eden区满了。进行youngGC<ul>\n<li>没有引用的对象（类）被回收</li>\n</ul>\n</li>\n</ul>\n<p>年轻代垃圾回收算法：</p>\n<ul>\n<li>复制算法：因为年轻代中大多数都是垃圾对象，所以把存活对象复制到s1中，一键全部清除Eden区。<ul>\n<li>把s1和Eden中的存活对象复制到s2，把s1和Eden区全部清除</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么时候对象会转移到老年代\"><a href=\"#什么时候对象会转移到老年代\" class=\"headerlink\" title=\"什么时候对象会转移到老年代\"></a>什么时候对象会转移到老年代</h3><p>如果存活了多次垃圾回收过程，就会转移到老年代</p>\n<p>如果s区放不下，会把一些存活的对象直接放到老年代中。</p>\n<p>对于大对象会直接放到老年代中，防止ygc反复复制大对象。</p>\n<h3 id=\"常用的垃圾回收器，老年代如何回收\"><a href=\"#常用的垃圾回收器，老年代如何回收\" class=\"headerlink\" title=\"常用的垃圾回收器，老年代如何回收\"></a>常用的垃圾回收器，老年代如何回收</h3><p>老年代中大多数是长期存活的对象，所以使用标记-清理方法：把所有存活的对象压缩到连续的位置，然后统一清理，可以防止内存碎片问题。</p>\n<p>常用的垃圾回收器：</p>\n<ul>\n<li>CMS+parnew jdk8-jdk9</li>\n<li>g1 jdk11 </li>\n<li>ZGC</li>\n</ul>\n<h3 id=\"生产环境如何设置jvm参数的，如何检查jvm的运行情况\"><a href=\"#生产环境如何设置jvm参数的，如何检查jvm的运行情况\" class=\"headerlink\" title=\"生产环境如何设置jvm参数的，如何检查jvm的运行情况\"></a>生产环境如何设置jvm参数的，如何检查jvm的运行情况</h3><p>tomcat的配置脚本，catalina脚本设置。</p>\n<p>如果使用jar启动，再java命令后直接加上参数</p>\n<p>参数：</p>\n<ul>\n<li>内存区域大小的分配：<ul>\n<li>栈大小</li>\n<li>metaspace大小</li>\n<li>eden  survivor</li>\n<li>堆大小</li>\n<li>年轻代、老年代</li>\n</ul>\n</li>\n<li>垃圾回收器<ul>\n<li>年轻代和老年代用了什么回收器</li>\n<li>是否有特殊参数，作用是什么</li>\n</ul>\n</li>\n</ul>\n<p>jstat压测，QPS,接口性能</p>\n<h3 id=\"JVM-GC优化\"><a href=\"#JVM-GC优化\" class=\"headerlink\" title=\"JVM GC优化\"></a>JVM GC优化</h3><p>自己动手进行压测，调试一下</p>\n<h3 id=\"发生OOM之后，应该如何排查和处理线上系统的OOM问题\"><a href=\"#发生OOM之后，应该如何排查和处理线上系统的OOM问题\" class=\"headerlink\" title=\"发生OOM之后，应该如何排查和处理线上系统的OOM问题\"></a>发生OOM之后，应该如何排查和处理线上系统的OOM问题</h3><p>在jvm设置参数，发生oom之后保存快照。</p>\n<p>找出占用内存最大的对象和创建它的代码，进行调优。</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"TCP-IP的四层模型和七层网络模型\"><a href=\"#TCP-IP的四层模型和七层网络模型\" class=\"headerlink\" title=\"TCP&#x2F;IP的四层模型和七层网络模型\"></a>TCP&#x2F;IP的四层模型和七层网络模型</h3><p>TCP&#x2F;IP四层：数据链路层、网络层、传输层、应用层</p>\n<ul>\n<li>物理层：硬件部分</li>\n<li>数据链路层：将0&#x2F;1信号分组，确定来源去向<ul>\n<li>以太网协议：一组信号是一个网络帧。每帧有两个部分：表头和数据，表头保存说明性的东西，比如发送者，接收者，数据类型等。通过网卡来发送接收数据，mac地址是网卡的id。</li>\n<li>mac：前6个16进制是厂商编号，后6个编号是网卡流水号。</li>\n</ul>\n</li>\n<li>网络层：<ul>\n<li>IP协议</li>\n<li>判断是不是一个子网：使用ip的二进制和子网掩码进行与运算，看结果前三个部分如果是一样的就是子网。</li>\n<li>不在一个子网需要一个路由器，路由器判断数据包的目标mac是不是自己的子网内的mac，是则转发。</li>\n<li>ARP cache 会让每一个电脑都缓存到子网中所以电脑的ip和mac对应关系。</li>\n<li>路由器就可以看做是一个网关</li>\n</ul>\n</li>\n<li>传输层TCP协议：仅仅规定了基于端口的点对点通信协议，包含如何建立连接，读取和发送信息。要基于TCP 开发，实际上是使用socket开发。</li>\n<li>应用层：最常见的是http</li>\n</ul>\n<p>OSI七层：物理层、会话层、表示层 + 四层模型</p>\n<p>DNS：domain name server ，先通过dns服务器把域名翻译成IP。</p>\n<h3 id=\"浏览器访问baidu-com会发生什么\"><a href=\"#浏览器访问baidu-com会发生什么\" class=\"headerlink\" title=\"浏览器访问baidu.com会发生什么\"></a>浏览器访问baidu.com会发生什么</h3><ul>\n<li>域名解析为IP</li>\n<li>把请求打包成http包</li>\n<li>把http数据包包装成tcp数据包，tcp数据头包含接收者和发送者的端口号</li>\n<li>然后把全部数据包包装到ip数据包，ip数据头中包含发送者和接收者的ip</li>\n<li>然后以太网会把这个数据包封装到以太网数据包中，加上以太网头，其中包含有发送者和接收者的网卡mac地址。<ul>\n<li>以太网一次传输字节有限，可能需要切割为多个包。</li>\n<li>根据IP头序号来合成一个包。</li>\n</ul>\n</li>\n<li>然后通过多个路由转发到百度的子网中。</li>\n</ul>\n<h3 id=\"TCP三次握手和四次挥手的流程，为什么不是五次或者两次？\"><a href=\"#TCP三次握手和四次挥手的流程，为什么不是五次或者两次？\" class=\"headerlink\" title=\"TCP三次握手和四次挥手的流程，为什么不是五次或者两次？\"></a>TCP三次握手和四次挥手的流程，为什么不是五次或者两次？</h3><ul>\n<li>建立连接的三次握手：<ul>\n<li>客户端发送syn（同步），表示自己进入了syn_send状态</li>\n<li>服务端恢复syn+ack（确认）表示确认收到同步请求，并且自己进入syn_recevie状态</li>\n<li>客户端发送ack，表示确认建立连接。当服务端接收到这个包的时候，连接正式建立</li>\n</ul>\n</li>\n<li>为什么不是两次握手<ul>\n<li>如果网络问题，遇到不想要的连接，三次连接可以让客户端发送给服务器复位信息，释放资源</li>\n</ul>\n</li>\n<li>结束连接的四次挥手：<ul>\n<li>客户端发送FIN（结束）</li>\n<li>服务端发送ACK（收到），这段时间有可能传输还没有完全完毕，等待全部完毕后再发送FIN。</li>\n<li>服务端发送FIN（结束）</li>\n<li>客户端发送ACK（收到）：服务端收到这个请求后立刻关闭，客户端会等待一段时间，保证服务端确实接收到这个包</li>\n</ul>\n</li>\n</ul>\n<p> 2 3次挥手好像在某些情况可以合并？</p>\n<h3 id=\"说一下http长连接的原理\"><a href=\"#说一下http长连接的原理\" class=\"headerlink\" title=\"说一下http长连接的原理\"></a>说一下http长连接的原理</h3><p><strong>http本身没有长连接，都是tcp的长连接和短链接</strong></p>\n<p>http协议规范：请求头，请求体什么的</p>\n<p>http1.0 都是短链接，一次请求后直接断开tcp连接，需要指定keep-alive才能建立长连接</p>\n<p>http1.1 默认是长连接</p>\n<p>http2.0支持多路复用，一个tcp可以并行发送多个请求以及接收响应。</p>\n<p>http3.0 QUIC 建立在udp之上。</p>\n<h3 id=\"https-http-ssl-tsl\"><a href=\"#https-http-ssl-tsl\" class=\"headerlink\" title=\"https http+ssl&#x2F;tsl\"></a>https http+ssl&#x2F;tsl</h3><p>使用证书加密</p>\n<ul>\n<li>非对称加密：rsa<ul>\n<li>网站给浏览器发送证书（由权威机构颁发），浏览器验证合法性</li>\n<li>浏览器生成随机密码，用随机密码加密随机密码的hash，并且用证书的公钥加密这个随机密码，</li>\n<li>网站用证书的私钥解密这个随机面膜，再用随机密码解密得到hash，计算自己得到的密码的hash进行对比，如果完全相同，则可以使用</li>\n<li>之后用这个随机密码来实现加密通信。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><h3 id=\"引擎：mysiam-innodb\"><a href=\"#引擎：mysiam-innodb\" class=\"headerlink\" title=\"引擎：mysiam innodb\"></a>引擎：mysiam innodb</h3><ul>\n<li>mysiam：不支持事务，不支持外键约束。索引和数据文件分开，可以在内存缓存更多索引，查询性能会更好，适用于少量插入，大量查询<ul>\n<li>hadoop报表系统，用mysql mysiam比较适合，但是数据量太大超过500w以上就也不能用mysql了。</li>\n</ul>\n</li>\n<li>innodb（默认）：支持事务，外键约束，高并发，高可用，大数据量</li>\n</ul>\n<h3 id=\"Mysql索引原理和数据结构。\"><a href=\"#Mysql索引原理和数据结构。\" class=\"headerlink\" title=\"Mysql索引原理和数据结构。\"></a>Mysql索引原理和数据结构。</h3><p>索引：默认b+树</p>\n<ul>\n<li>b-树<ul>\n<li>每个节点都存储对应的data</li>\n</ul>\n</li>\n<li>b+树<ul>\n<li>只有叶子节点存储对应的data</li>\n</ul>\n</li>\n</ul>\n<p>Mysiam的索引：叶子节点存储的是索引的物理地址。然后用物理地址去数据文件找数据。</p>\n<p>Innodb的索引：表要求必须要有主键，默认会为主键建立一个索引，节点data包含所有数据（一个记录，整行），叫做聚簇索引。如果你使用name来找数据，那么从name索引中找到的data是主键（id），再用id从聚簇索引找data。</p>\n<h3 id=\"索引的使用规则\"><a href=\"#索引的使用规则\" class=\"headerlink\" title=\"索引的使用规则\"></a>索引的使用规则</h3><p>怎么建立索引？</p>\n<p><strong>最左前缀匹配原则：</strong></p>\n<p>创建联合索引：create index(shop_id,product_id,gmt_create)</p>\n<p>如果你使用 shop_id 和 gmt_create来查找，那么不会直接通过这个联合索引查找，而是通过使用shop_id筛选出来一些数据，之后扫描gmt_create字段符合要求过滤。（性能也还行）。</p>\n<p><strong>但如果没有最左边的任何字段，就没法用这个索引</strong>，比如直接通过product_id查找，这个是没有用到这个索引的。</p>\n<p>范围列匹配，最左前缀范围查找会用索引，之后的不会用索引了。</p>\n<p>调用了函数的sql语句不使用索引</p>\n<p><strong>建立尽量少的索引，10条以内为佳</strong></p>\n<p><strong>尽量选唯一字段进行建立索引</strong>。选择的字段 去重后数量&#x2F;总数量 ，结果要是小，则说明这个索引用处不大。</p>\n<h3 id=\"事务的几个特点\"><a href=\"#事务的几个特点\" class=\"headerlink\" title=\"事务的几个特点\"></a>事务的几个特点</h3><p><strong>ACID</strong></p>\n<ul>\n<li>Atomic：原子性，同时执行的sql要么一起成功，要么一起失败</li>\n<li>Consistency：一致性，事务之前前后数据都应该是正确的</li>\n<li>Isolation：隔离性，多个事务之间不互相干扰</li>\n<li>Durability：持久性</li>\n</ul>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><ul>\n<li>读未提交：事务A读取到事务B还没有提交的数据</li>\n<li>读已提交：事务A读取到原来的数据，然后事务B提交修改，事务A再次读取，读到不一样的数据。（不可重复读）</li>\n<li>可重复读：事务A读取到原来的数据，然后事务B提交修改，事务A再次读取，读到的还是事务A最开始读取到的数据。（可重复读）</li>\n<li>幻读（不是隔离级别）：事务A查询所有数据，准备插入一一条数据，事务B插入了一行数据，事务B提交插入。事务A想要插入数据，发现这个数据已经存在（被事务B插入）。</li>\n<li>串行化（为了解决幻读）：事务A查询所有数据，事务B想要插入一行数据会被拒绝。事务A提交后，事务B才能进行插入数据。</li>\n</ul>\n<p><strong>MySQL默认级别：可重复读。</strong></p>\n<p><strong>实现可重复读的机制</strong>：MVCC机制 multi-version concurrency control</p>\n<ul>\n<li><p>事务id是全局唯一且递增的，</p>\n</li>\n<li><p>查询事务只会找比自己事务id小的 创建事务。</p>\n<ul>\n<li><p>创建事务id&lt;&#x3D;当前事务id</p>\n</li>\n<li><p>当前事务id&lt;删除事务id</p>\n</li>\n</ul>\n</li>\n<li><p>不同事务修改某行数据，会多出来一行，id相同。</p>\n</li>\n</ul>\n<h3 id=\"数据库锁\"><a href=\"#数据库锁\" class=\"headerlink\" title=\"数据库锁\"></a>数据库锁</h3><p><strong>自动加锁</strong></p>\n<p>表锁 行锁 页锁</p>\n<ul>\n<li>myisam会加表锁。锁表的时候查询会报504</li>\n</ul>\n<p>行锁：innodb：共享锁（s）和排他锁（x）</p>\n<ul>\n<li>共享锁和排他锁不能同时加</li>\n<li>select 不加锁因为MVCC有快照，增删改会加一个行锁排他锁。</li>\n</ul>\n<p><strong>手动加锁</strong></p>\n<p>加共享锁：select * from table where id &#x3D; 1 lock in share mode</p>\n<p>加排他锁：select * from table where id &#x3D;1 for update</p>\n<p><strong>悲观锁</strong>：进行操作都加上排他锁</p>\n<p><strong>乐观锁</strong>：加上版本号字段，在事务修改期间如果版本号不同，则这次修改失败，需要重新读取操作。</p>\n<p><strong>死锁</strong>：dba查看死锁日志。</p>\n<h3 id=\"MySQL调优的常用手段\"><a href=\"#MySQL调优的常用手段\" class=\"headerlink\" title=\"MySQL调优的常用手段\"></a>MySQL调优的常用手段</h3><ul>\n<li>保持sql简单，建议使用单表查询<ul>\n<li>优化索引</li>\n<li>查看sql的执行计划：explain select * from table</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"E-R图\"><a href=\"#E-R图\" class=\"headerlink\" title=\"E-R图\"></a>E-R图</h3><p>entities-relationship图</p>\n<p>关系：操作数是关系，重复行的对应关系（投影）要去掉。剩下的是关系：一对多，一对一，多对多等</p>\n<h2 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h2><p>直接使用tcp进行通信，就是socket编程</p>\n<p>可以认为socket处于传输层。或者是介于传输层和应用层直接。</p>\n<p>socket 就是封装了tcp的编程规范</p>\n<h2 id=\"进程通信和线程切换\"><a href=\"#进程通信和线程切换\" class=\"headerlink\" title=\"进程通信和线程切换\"></a>进程通信和线程切换</h2><h3 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3><p>9.1.1管道 pipe</p>\n<p>只有父子进程（fork得到的）才能使用这个管道进行通信。</p>\n<p>9.1.2命名管道</p>\n<p>无亲缘关系的管道可以使用命名管道通信</p>\n<p>9.1.3消息队列</p>\n<p>9.1.4共享内存</p>\n<h3 id=\"线程如何切换\"><a href=\"#线程如何切换\" class=\"headerlink\" title=\"线程如何切换\"></a>线程如何切换</h3><p>时间片轮换</p>\n<p>优先级调度等</p>\n<h2 id=\"nio，bio，aio都是什么，有什么区别。nio的原理是什么\"><a href=\"#nio，bio，aio都是什么，有什么区别。nio的原理是什么\" class=\"headerlink\" title=\"nio，bio，aio都是什么，有什么区别。nio的原理是什么\"></a>nio，bio，aio都是什么，有什么区别。nio的原理是什么</h2><h3 id=\"bio通信原理\"><a href=\"#bio通信原理\" class=\"headerlink\" title=\"bio通信原理\"></a>bio通信原理</h3><p>服务端使用ServerSocket为每一个客户端建立一个线程用于通信。只要客户端还和服务端有连接，这个线程都要等待。</p>\n<p>问题：超过几千客户端就不能够正常运行了</p>\n<h3 id=\"nio通信原理\"><a href=\"#nio通信原理\" class=\"headerlink\" title=\"nio通信原理\"></a>nio通信原理</h3><p>每有一个客户端和服务端建立连接，都会创建一个channel，这些channel都会注册在selector中，这个selector只有一个线程。会不断轮询这些channel。，如果有请求过来，会创建一个线程来处理这个请求。处理完成后这个线程会被销毁。</p>\n<p>可以对处理请求的线程创建一个线程池。</p>\n<p>在工作线程和channel 直接可以维护一个cache</p>\n<p>工作线程从channel 中读取数据，给channel写数据，是同步的</p>\n<h3 id=\"aio\"><a href=\"#aio\" class=\"headerlink\" title=\"aio\"></a>aio</h3><p>对nio有优化：工作进程从channel读数据的时候，会绑定一个buffer，让操作系统来完成读操作，读完了来通知这个线程。</p>\n<p>写的时候也是把写的过程交给操作系统。</p>\n<h3 id=\"同步阻塞、同步非阻塞、异步非阻塞\"><a href=\"#同步阻塞、同步非阻塞、异步非阻塞\" class=\"headerlink\" title=\"同步阻塞、同步非阻塞、异步非阻塞\"></a>同步阻塞、同步非阻塞、异步非阻塞</h3><p>BIO是同步阻塞，针对的是对磁盘文件的io读写。读写过程中线程阻塞</p>\n<p>NIO是同步非阻塞，在操作系统读写数据的时候，线程可以做其他事情，但是也需要不断轮询判断读写完成了没有。</p>\n<p>AIO 是异步非阻塞，发起文件读写的操作之后，交给操作系统，操作系统执行完毕之后，会通知这个线程。</p>\n<h3 id=\"BIO-NIO-AIO-demo代码\"><a href=\"#BIO-NIO-AIO-demo代码\" class=\"headerlink\" title=\"BIO NIO AIO demo代码\"></a>BIO NIO AIO demo代码</h3><p>TOREAD</p>\n<h2 id=\"线上服务器问题\"><a href=\"#线上服务器问题\" class=\"headerlink\" title=\"线上服务器问题\"></a>线上服务器问题</h2><h3 id=\"线上CPU占用100-，排查步骤：\"><a href=\"#线上CPU占用100-，排查步骤：\" class=\"headerlink\" title=\"线上CPU占用100%，排查步骤：\"></a>线上CPU占用100%，排查步骤：</h3><ul>\n<li>top -c 输入P ，按照cpu进行排序</li>\n<li>top -Hp pid ，可以看到这个进程的负载</li>\n<li>把线程pid换成16进制pidhex，如何使用jstack pid | grep pidhex -C5 –color 就可以定位到线程中哪行代码的cpu占用最高。</li>\n</ul>\n<h3 id=\"如果线上进程kill不掉怎么办\"><a href=\"#如果线上进程kill不掉怎么办\" class=\"headerlink\" title=\"如果线上进程kill不掉怎么办\"></a>如果线上进程kill不掉怎么办</h3><p>ps aux 查看是否有僵尸进程 zombie</p>\n<p>ps -ef  | grep 僵尸进程id ，得到父进程id</p>\n<p>然后kill 父进程之后kill子进程。</p>\n<h3 id=\"磁盘马上占满了怎么办\"><a href=\"#磁盘马上占满了怎么办\" class=\"headerlink\" title=\"磁盘马上占满了怎么办\"></a>磁盘马上占满了怎么办</h3><p>是否是日志占满空间了？</p>\n<p>经历：安装程序的时候提示根目录空间占用100%，发现是pcp（性能监控软件）的日志占用了很大空间。解决方法是直接使用rm -rf删除了这些日志&#x2F;var&#x2F;log&#x2F;pcp&#x2F;pmlogger&#x2F;openEuler1&#x2F;。</p>\n<p>关于pcp：</p>\n<ul>\n<li>Performance Co-Pilot (<code>pcp</code>) 提供了支持系统级性能监控和管理的框架和服务。它为系统中的所有性能数据提供了统一的抽象，以及用于询问、检索和处理该数据的许多工具。 \t</li>\n<li>这些生成的log，在openeuler系统没有设置自动清理，导致了日志积累。</li>\n</ul>\n<p> \t</p>\n<p>find &#x2F; -size+100M | xargs ls -lh  找大于100m的文件</p>\n<h2 id=\"Java语言特性\"><a href=\"#Java语言特性\" class=\"headerlink\" title=\"Java语言特性\"></a>Java语言特性</h2><h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><ul>\n<li>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong>：<ul>\n<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>\n<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本</li>\n</ul>\n</li>\n<li>想要通过传值来修改原来的值<ul>\n<li>通过数组</li>\n<li>通过类</li>\n<li>或者其他可变的引用类型</li>\n</ul>\n</li>\n<li>不可变的引用类型<ul>\n<li>String</li>\n<li>Integer</li>\n<li>BigDecimal</li>\n<li>LocalDate、LocalTime、LocalDateTime、Duration，Period</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h3><ul>\n<li><p>序列化协议属于应用层或者传输层</p>\n</li>\n<li><p>序列化的对象：实现Serializable 接口的类、实例变量的值、非静态成员变量</p>\n</li>\n<li><p>serialVersionUID：用来判断对象版本。手动设置这个变量可以解决对象版本兼容问题。</p>\n</li>\n<li><p>Kryo用来序列化Java代码性能高。</p>\n<ul>\n<li><pre><code class=\"java\">import com.esotericsoftware.kryo.Kryo;\nimport com.esotericsoftware.kryo.io.Input;\nimport com.esotericsoftware.kryo.io.Output;\n\nimport java.io.*;\n\npublic class KryoSerializationExample &#123;\n    public static void main(String[] args) &#123;\n        // 创建 Kryo 对象\n        Kryo kryo = new Kryo();\n\n        // 创建要序列化的对象\n        Person person = new Person(&quot;Alice&quot;, 30);\n\n        // 序列化\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        Output output = new Output(outputStream);\n        kryo.writeObject(output, person);\n        output.close();\n\n        // 将序列化的数据保存到文件\n        try (FileOutputStream fileOutputStream = new FileOutputStream(&quot;person.dat&quot;)) &#123;\n            outputStream.writeTo(fileOutputStream);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        // 反序列化\n        try (FileInputStream fileInputStream = new FileInputStream(&quot;person.dat&quot;)) &#123;\n            // 创建 Kryo 输入流\n            Input input = new Input(fileInputStream);\n\n            // 从输入流中反序列化对象\n            Person deserializedPerson = kryo.readObject(input, Person.class);\n            input.close();\n\n            // 使用反序列化后的对象\n            System.out.println(&quot;姓名: &quot; + deserializedPerson.getName());\n            System.out.println(&quot;年龄: &quot; + deserializedPerson.getAge());\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"泛型和通配符\"><a href=\"#泛型和通配符\" class=\"headerlink\" title=\"泛型和通配符\"></a>泛型和通配符</h3><ol>\n<li>泛型（Generics）：泛型允许在编译时指定类、接口或方法操作的数据类型，以提供类型安全和代码重用。通过使用泛型，可以在编译时捕获类型错误，并避免在运行时出现类型转换错误。<ul>\n<li>定义泛型类：使用 <code>&lt;T&gt;</code> 来表示类型参数，可以在类名后面声明一个泛型类型。例如：<code>class MyClass&lt;T&gt; &#123; ... &#125;</code>。</li>\n<li>定义泛型方法：使用 <code>&lt;T&gt;</code> 来表示类型参数，可以在方法返回类型前声明一个泛型类型。例如：<code>&lt;T&gt; T myMethod(T obj) &#123; ... &#125;</code>。</li>\n<li>约定<ul>\n<li><code>E</code>：表示集合中的元素类型。</li>\n<li><code>K</code>：表示映射中的键类型。</li>\n<li><code>V</code>：表示映射中的值类型。</li>\n<li><code>T</code>：表示任意类型。</li>\n<li><code>S</code>、<code>U</code>、<code>V</code>：用于表示第二、第三和第四类型参数。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>类型通配符（Wildcard）：类型通配符用问号 <code>?</code> 表示，用于灵活处理不同类型的泛型对象。通配符可以用于泛型类、泛型方法和通配符限定。<ul>\n<li>通配符限定上界：<code>? extends Type</code>，表示泛型参数是 Type 类型或其子类。例如：<code>List&lt;? extends Number&gt;</code> 表示一个只能接受 Number 及其子类的 List。</li>\n<li>通配符限定下界：<code>? super Type</code>，表示泛型参数是 Type 类型或其父类。例如：<code>List&lt;? super Integer&gt;</code> 表示一个只能接受 Integer 及其父类的 List。</li>\n<li>无限制通配符：<code>?</code>，表示可以是任意类型。例如：<code>List&lt;?&gt;</code> 表示一个可以接受任意类型的 List。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><h5 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h5><pre><code class=\"java\">//获取类\nClass&lt;?&gt; myClass = MyClass.class;\nClass&lt;?&gt; myClass = Class.forName(&quot;com.example.MyClass&quot;);\n//获取构造函数\nConstructor&lt;?&gt; constructor = myClass.getDeclaredConstructor(parameterTypes);\n//创建对象\nObject myObject = constructor.newInstance(arguments);\n//获取方法\nMethod method = myClass.getDeclaredMethod(&quot;methodName&quot;, parameterTypes);\n//调用方法\nmethod.invoke(myObject, arguments);\n//获取字段\nField field = myClass.getDeclaredField(&quot;fieldName&quot;);\n//获取字段的值\nObject fieldValue = field.get(myObject);\n//设置字段的值\nfield.set(myObject, value);\n//对于私有方法或字段，可能需要使用setAccessible(true)来绕过访问限制。\n</code></pre>\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><h5 id=\"1-静态代理：\"><a href=\"#1-静态代理：\" class=\"headerlink\" title=\"1.静态代理：\"></a>1.静态代理：</h5><p>就是把在调用类的前后在执行一些步骤。</p>\n<pre><code class=\"java\">public class SmsProxy implements SmsService &#123;\n\n    private final SmsService smsService;\n\n    public SmsProxy(SmsService smsService) &#123;\n        this.smsService = smsService;\n    &#125;\n\n    @Override\n    public String send(String message) &#123;\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(&quot;before method send()&quot;);\n        smsService.send(message);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(&quot;after method send()&quot;);\n        return null;\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"2-动态代理\"><a href=\"#2-动态代理\" class=\"headerlink\" title=\"2.动态代理\"></a>2.动态代理</h5><p><strong>2.1JDK代理：在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>\n<pre><code class=\"java\">//调用proxy的方法newProxyInstance\nProxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),new DebugInvocationHandler(target));\n//DebugInvocationHandler 是自定义的proxy方法，需要实现InvocationHandler接口的invoke方法，实际上是调用了这里的invoke方法\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\npublic class DebugInvocationHandler implements InvocationHandler &#123;\n    private final Object target;\n    public DebugInvocationHandler(Object target) &#123;\n        this.target = target;\n    &#125;\n    @Override\n    public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123;\n        System.out.println(&quot;before Method&quot;+ method.getName());\n        Object result = method.invoke(target, objects);\n        System.out.println(&quot;after Method&quot;+ method.getName());\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>JDK 动态代理有一个最致命的问题是其<strong>只能代理实现了接口的类</strong>。</p>\n<p>为了解决这个问题，我们可以用 CGLIB 动态代理机制。</p>\n<p><strong>2.2CGLIB代理</strong></p>\n<ul>\n<li><p>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</p>\n</li>\n<li><p>maven依赖：</p>\n<ul>\n<li><pre><code class=\"xml\">&lt;dependency&gt;\n  &lt;groupId&gt;cglib&lt;/groupId&gt;\n  &lt;artifactId&gt;cglib&lt;/artifactId&gt;\n  &lt;version&gt;3.3.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><pre><code class=\"java\">//代理工厂中生成一个 enhancer对象，这个对象拥有下列属性，其中DebugMethodInterceptor拦截器是自定义的最终执行的方法\npublic class CglibProxyFactory &#123;\n    public static Object getProxy(Class&lt;?&gt; clazz)&#123;\n        Enhancer enhancer = new Enhancer();\n        enhancer.setClassLoader(clazz.getClassLoader());\n        enhancer.setSuperclass(clazz);\n        enhancer.setCallback(new DebugMethodInterceptor());\n        return enhancer.create();\n    &#125;\n&#125;\n//DebugMethodInterceptor 实现MethodInterceptor接口，重写intercept方法，这个方法相当于前面的invoke\npublic class DebugMethodInterceptor implements MethodInterceptor &#123;\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;\n        //调用方法之前，我们可以添加自己的操作\n        System.out.println(&quot;before method &quot; + method.getName());\n        Object object = methodProxy.invokeSuper(o, objects);\n        //调用方法之后，我们同样可以添加自己的操作\n        System.out.println(&quot;after method &quot; + method.getName());\n        return object;\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n<p><strong>2.3二者的区别</strong></p>\n<p>jdk动态代理，有接口的时候使用，生成一个实现这些同样接口的对象。</p>\n<p>没有接口会使用cglib来生成你的类的子类，覆盖你的类的方法，在方法中加入增强的代码。</p>\n<h3 id=\"BigDecimal常见方法\"><a href=\"#BigDecimal常见方法\" class=\"headerlink\" title=\"BigDecimal常见方法\"></a>BigDecimal常见方法</h3><p>我们在使用 <code>BigDecimal</code> 时，为了防止精度丢失，推荐使用它的<code>BigDecimal(String val)</code>构造方法或者 <code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象。</p>\n<p><strong>使用BigDecimal(double val)会丢失精度</strong></p>\n<p>方法：</p>\n<ul>\n<li>add：加</li>\n<li>subtract：减</li>\n<li>multiple：乘</li>\n<li>divide：除<ul>\n<li>除的时候尽量使用三个参数的版本：指定保留规则RoundingMode</li>\n</ul>\n</li>\n<li>compareTo：<code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1 表示 <code>a</code> 大于 <code>b</code>。<ul>\n<li>比较不能使用equals，因为equals比较会同时比较精度，1.0和1.00不相同</li>\n</ul>\n</li>\n<li>setScale：保留小数</li>\n</ul>\n<p>工具类：</p>\n<details><summary>点击查看代码</summary>\n <pre><code>\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n/**\n * 简化BigDecimal计算的小工具类\n */\npublic class BigDecimalUtil &#123;\n    /**\n     * 默认除法运算精度\n     */\n    private static final int DEF_DIV_SCALE = 10;\n    private BigDecimalUtil() &#123;\n    &#125;\n    /**\n     * 提供精确的加法运算。\n     *\n     * @param v1 被加数\n     * @param v2 加数\n     * @return 两个参数的和\n     */\n    public static double add(double v1, double v2) &#123;\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.add(b2).doubleValue();\n    &#125;\n    /**\n     * 提供精确的减法运算。\n     *\n     * @param v1 被减数\n     * @param v2 减数\n     * @return 两个参数的差\n     */\n    public static double subtract(double v1, double v2) &#123;\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.subtract(b2).doubleValue();\n    &#125;\n    /**\n     * 提供精确的乘法运算。\n     *\n     * @param v1 被乘数\n     * @param v2 乘数\n     * @return 两个参数的积\n     */\n    public static double multiply(double v1, double v2) &#123;\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.multiply(b2).doubleValue();\n    &#125;\n    /**\n     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到\n     * 小数点以后10位，以后的数字四舍五入。\n     *\n     * @param v1 被除数\n     * @param v2 除数\n     * @return 两个参数的商\n     */\n    public static double divide(double v1, double v2) &#123;\n        return divide(v1, v2, DEF_DIV_SCALE);\n    &#125;\n    /**\n     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指\n     * 定精度，以后的数字四舍五入。\n     *\n     * @param v1    被除数\n     * @param v2    除数\n     * @param scale 表示表示需要精确到小数点以后几位。\n     * @return 两个参数的商\n     */\n    public static double divide(double v1, double v2, int scale) &#123;\n        if (scale < 0) &#123;\n            throw new IllegalArgumentException(\n                    \"The scale must be a positive integer or zero\");\n        &#125;\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.divide(b2, scale, RoundingMode.HALF_EVEN).doubleValue();\n    &#125;\n    /**\n     * 提供精确的小数位四舍五入处理。\n     *\n     * @param v     需要四舍五入的数字\n     * @param scale 小数点后保留几位\n     * @return 四舍五入后的结果\n     */\n    public static double round(double v, int scale) &#123;\n        if (scale < 0) &#123;\n            throw new IllegalArgumentException(\n                    \"The scale must be a positive integer or zero\");\n        &#125;\n        BigDecimal b = BigDecimal.valueOf(v);\n        BigDecimal one = new BigDecimal(\"1\");\n        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();\n    &#125;\n    /**\n     * 提供精确的类型转换(Float)\n     *\n     * @param v 需要被转换的数字\n     * @return 返回转换结果\n     */\n    public static float convertToFloat(double v) &#123;\n        BigDecimal b = new BigDecimal(v);\n        return b.floatValue();\n    &#125;\n    /**\n     * 提供精确的类型转换(Int)不进行四舍五入\n     *\n     * @param v 需要被转换的数字\n     * @return 返回转换结果\n     */\n    public static int convertsToInt(double v) &#123;\n        BigDecimal b = new BigDecimal(v);\n        return b.intValue();\n    &#125;\n    /**\n     * 提供精确的类型转换(Long)\n     *\n     * @param v 需要被转换的数字\n     * @return 返回转换结果\n     */\n    public static long convertsToLong(double v) &#123;\n        BigDecimal b = new BigDecimal(v);\n        return b.longValue();\n    &#125;\n    /**\n     * 返回两个数中大的一个值\n     *\n     * @param v1 需要被对比的第一个数\n     * @param v2 需要被对比的第二个数\n     * @return 返回两个数中大的一个值\n     */\n    public static double returnMax(double v1, double v2) &#123;\n        BigDecimal b1 = new BigDecimal(v1);\n        BigDecimal b2 = new BigDecimal(v2);\n        return b1.max(b2).doubleValue();\n    &#125;\n    /**\n     * 返回两个数中小的一个值\n     *\n     * @param v1 需要被对比的第一个数\n     * @param v2 需要被对比的第二个数\n     * @return 返回两个数中小的一个值\n     */\n    public static double returnMin(double v1, double v2) &#123;\n        BigDecimal b1 = new BigDecimal(v1);\n        BigDecimal b2 = new BigDecimal(v2);\n        return b1.min(b2).doubleValue();\n    &#125;\n    /**\n     * 精确对比两个数字\n     *\n     * @param v1 需要被对比的第一个数\n     * @param v2 需要被对比的第二个数\n     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1\n     */\n    public static int compareTo(double v1, double v2) &#123;\n        BigDecimal b1 = BigDecimal.valueOf(v1);\n        BigDecimal b2 = BigDecimal.valueOf(v2);\n        return b1.compareTo(b2);\n    &#125;\n&#125;\n    </code></pre>\n</details>\n\n<h3 id=\"Unsafe类\"><a href=\"#Unsafe类\" class=\"headerlink\" title=\"Unsafe类\"></a><a href=\"https://javaguide.cn/java/basis/unsafe.html\">Unsafe类</a></h3><p>在JUC高并发编程中主要使用，用来执行本地方法（native方法）。</p>\n<p>native方法的执行绕过了Java本身的界限。能直接接触到操作系统底层的某些功能，因此并不安全。</p>\n<p>可以实现的功能：</p>\n<ol>\n<li>内存操作</li>\n<li>内存屏障</li>\n<li>对象操作</li>\n<li>数据操作</li>\n<li>CAS 操作</li>\n<li>线程调度</li>\n<li>Class 操作</li>\n<li>系统信息</li>\n</ol>\n<p>因为其不安全性，并不推荐使用。</p>\n<h3 id=\"SPI机制\"><a href=\"#SPI机制\" class=\"headerlink\" title=\"SPI机制\"></a>SPI机制</h3><h3 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h3>"},{"title":"使用Let's Encrypt给网站添加SSL","_content":"\n# 使用Let's Encrypt给网站添加SSL\n\n## 安装cerbot\n\n```bash\nsudo apt install certbot python3-certbot-nginx\n```\n\n## 为nginx添加SSL\n\n```bash\nsudo certbot --nginx\n```\n\n## 续订SSL(默认三个月)\n\n```bash\ncertbot renew\n```\n\n","source":"_posts/使用Let's Encrypt给网站添加SSL.md","raw":"---\ntitle: 使用Let's Encrypt给网站添加SSL\ncategory: 教程\ntag: \n - 教程\n - ssl\n - https\n\n---\n\n# 使用Let's Encrypt给网站添加SSL\n\n## 安装cerbot\n\n```bash\nsudo apt install certbot python3-certbot-nginx\n```\n\n## 为nginx添加SSL\n\n```bash\nsudo certbot --nginx\n```\n\n## 续订SSL(默认三个月)\n\n```bash\ncertbot renew\n```\n\n","slug":"使用Let's Encrypt给网站添加SSL","published":1,"date":"2023-09-04T10:49:32.454Z","updated":"2023-09-11T13:27:40.166Z","_id":"clm4spvd50000ksgf9yw127o2","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"使用Let’s-Encrypt给网站添加SSL\"><a href=\"#使用Let’s-Encrypt给网站添加SSL\" class=\"headerlink\" title=\"使用Let’s Encrypt给网站添加SSL\"></a>使用Let’s Encrypt给网站添加SSL</h1><h2 id=\"安装cerbot\"><a href=\"#安装cerbot\" class=\"headerlink\" title=\"安装cerbot\"></a>安装cerbot</h2><pre><code class=\"bash\">sudo apt install certbot python3-certbot-nginx\n</code></pre>\n<h2 id=\"为nginx添加SSL\"><a href=\"#为nginx添加SSL\" class=\"headerlink\" title=\"为nginx添加SSL\"></a>为nginx添加SSL</h2><pre><code class=\"bash\">sudo certbot --nginx\n</code></pre>\n<h2 id=\"续订SSL-默认三个月\"><a href=\"#续订SSL-默认三个月\" class=\"headerlink\" title=\"续订SSL(默认三个月)\"></a>续订SSL(默认三个月)</h2><pre><code class=\"bash\">certbot renew\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用Let’s-Encrypt给网站添加SSL\"><a href=\"#使用Let’s-Encrypt给网站添加SSL\" class=\"headerlink\" title=\"使用Let’s Encrypt给网站添加SSL\"></a>使用Let’s Encrypt给网站添加SSL</h1><h2 id=\"安装cerbot\"><a href=\"#安装cerbot\" class=\"headerlink\" title=\"安装cerbot\"></a>安装cerbot</h2><pre><code class=\"bash\">sudo apt install certbot python3-certbot-nginx\n</code></pre>\n<h2 id=\"为nginx添加SSL\"><a href=\"#为nginx添加SSL\" class=\"headerlink\" title=\"为nginx添加SSL\"></a>为nginx添加SSL</h2><pre><code class=\"bash\">sudo certbot --nginx\n</code></pre>\n<h2 id=\"续订SSL-默认三个月\"><a href=\"#续订SSL-默认三个月\" class=\"headerlink\" title=\"续订SSL(默认三个月)\"></a>续订SSL(默认三个月)</h2><pre><code class=\"bash\">certbot renew\n</code></pre>\n"},{"title":"springboot查询数据库字段实践","_content":"\n# springboot查询数据库字段实践\n\n## 任务描述：\n\n**在订单管理中增加购票信息界面、**\n\n**查询条件：赛季名称、赛事名称、票种、姓名、身份证号、购买者、区域、座位、票类型**\n\n**显示字段：赛季名称、赛事名称、票种、姓名、身份证号、购买者、区域、座位、二维码（限制显示长度20字符）、购票时间、票类型**\n\n**可效仿订单管理页。**\n\n## 后端实现步骤：\n\n### 查看需要查询的表的字段\n\n* 表名为`t_business_member_ticket`\n\n* 字段分别为：\n  * 赛季名称：通过activeId 查询t_business_activity 表的 season字段\n  * 赛事名称：game_player字段\n  * 票种：ticket_name字段\n  * 姓名：bearer_name字段\n  * 身份证号：bearer_id_num字段\n  * 购买者：通过buyer字段的id 查询 t_business_member 表的name字段\n  * 区域：通过 field_id 字段查询 t_base_venue_structure 表的data_name 字段\n  * 座位：seat_name字段\n  * 二维码：校验码（未定）write_off_code字段\n  * 购票时间：buy_date 字段\n  * 票类型：tickit_type 字段\n\n```sql\nSELECT t.id, t.ticket_name , t.bearer_id_num , t.bearer_name ,t.write_off_code,t.game_player , t.seat_name ,t.buy_date,t.tickit_type, m.name AS buyer_name , f.data_name AS field_name , a.activity_name AS activity_name \nFROM ticket.t_business_member_ticket t\nJOIN t_business_member m ON t.buyer=m.id\nJOIN t_base_venue_structure f ON t.field_id=f.id\nJOIN t_business_activity a ON t.activity_id=a.id\n```\n\n### 后端采用的技术是 jpa\n\n* 首先，创建需要返回的类 MemberTicketResponse.java\n\n* 使用jpa进行多表联查。需要在repository文件中实现查询\n\n  * ```java\n    package com.jbrf.service.business.repository.custom;\n    \n    import com.jbrf.common.model.CustomBaseQuery;\n    import com.jbrf.common.model.CustomPage;\n    import com.jbrf.entity.basedata.QTBaseVenueStructure;\n    import com.jbrf.entity.business.*;\n    import com.jbrf.service.business.model.response.MemberTicketResponse;\n    import com.querydsl.core.BooleanBuilder;\n    import com.querydsl.core.types.Projections;\n    import com.querydsl.jpa.impl.JPAQuery;\n    import org.springframework.data.domain.Pageable;\n    import org.springframework.stereotype.Repository;\n    \n    import java.util.List;\n    \n    import static org.apache.commons.lang3.StringUtils.isNotBlank;\n    \n    @Repository\n    public class MemberTicketCustomRepository extends CustomBaseQuery<MemberTicket> {\n        JPAQuery<MemberTicket> query = null;\n        private QMemberTicket qMemberTicket = QMemberTicket.memberTicket;\n        private QActivityInfo qActivityInfo = QActivityInfo.activityInfo;\n        private QTBaseVenueStructure qtBaseVenueStructure = QTBaseVenueStructure.tBaseVenueStructure;\n        private QMember qMember = QMember.member;\n    \n        public CustomPage<MemberTicketResponse> getMemberTicketByPage(\n                Pageable pageable,\n                String activityName,\n                String gamePlayer,\n                String ticketName,\n                String bearerName,\n                String bearer_id_num,\n                String fieldName,\n                String seatName,\n                String ticketType,\n                String buyerName\n        ) {\n            CustomPage<MemberTicketResponse> result = new CustomPage<MemberTicketResponse>(pageable);\n    \n            query = memberTicketPredict(activityName, gamePlayer, ticketName, bearerName, bearer_id_num,\n                    fieldName, seatName, ticketType, buyerName);\n    \n            System.out.println(query);\n            Long totalElements = query.select(qMemberTicket.id).fetchCount();\n            if (null == totalElements || totalElements == 0L) {\n                return result;\n            }\n            List<MemberTicketResponse> ticketResponseList = query\n                    .orderBy(qMemberTicket.buyDate.desc())\n                    .offset(pageable.getOffset())\n                    .limit(pageable.getPageSize())\n                    .select(\n                            Projections.constructor(MemberTicketResponse.class, qMemberTicket.id, qMemberTicket.buyDate, qMemberTicket.seatName, qMember.name, qMemberTicket.ticketType, qMemberTicket.bearerName, qMemberTicket.bearerIdNum, qMemberTicket.gamePlayer, qMemberTicket.ticketName, qtBaseVenueStructure.dataName, qActivityInfo.activityName, qMemberTicket.writeOffCode)\n                    )\n                    .fetch();\n    \n            return result.totalElements(totalElements).content(ticketResponseList);\n        }\n    \n    \n        private JPAQuery<MemberTicket> memberTicketPredict(String activityName,\n                                                           String gamePlayer,\n                                                           String ticketName,\n                                                           String bearerName,\n                                                           String bearerIdNum,\n                                                           String fieldName,\n                                                           String seatName,\n                                                           String ticketType,\n                                                           String buyerName) {\n            BooleanBuilder predicate = new BooleanBuilder();\n    \n            if (isNotBlank(activityName)) {\n                predicate.and(qActivityInfo.activityName.contains(activityName.trim()));\n            }\n            if (isNotBlank(gamePlayer)) {\n                predicate.and(qMemberTicket.gamePlayer.contains(gamePlayer.trim()));\n            }\n            if (isNotBlank(ticketName)) {\n                predicate.and(qMemberTicket.ticketName.contains(ticketName.trim()));\n            }\n            if (isNotBlank(bearerName)) {\n                predicate.and(qMemberTicket.bearerName.contains(bearerName.trim()));\n            }\n            if (isNotBlank(bearerIdNum)) {\n                predicate.and(qMemberTicket.bearerIdNum.eq(bearerIdNum.trim()));\n            }\n            if (isNotBlank(fieldName)) {\n                predicate.and(qtBaseVenueStructure.dataName.contains(fieldName.trim()));\n            }\n            if (isNotBlank(seatName)) {\n                predicate.and(qMemberTicket.seatName.contains(seatName.trim()));\n            }\n            if (isNotBlank(ticketType)) {\n                predicate.and(qMemberTicket.ticketType.in(ticketType.split(\",\")));\n            }\n            if (isNotBlank(buyerName)) {\n                predicate.and(qMember.name.eq(buyerName.trim()));\n            }\n            return query().from(qMemberTicket)\n                    .leftJoin(qMember).on(qMemberTicket.buyer.eq(qMember.id))              .leftJoin(qtBaseVenueStructure).on(qMemberTicket.fieldId.eq(qtBaseVenueStructure.id))\n                    .leftJoin(qActivityInfo).on(qMemberTicket.activityId.eq(qActivityInfo.id))\n                    .where(predicate);\n        }\n    }\n    \n    ```\n\n  * 这段代码动态创建查询语句，并且将查询结果封装给要返回的类 MemberTicketResponse\n\n### 在service 和 serviceImpl中定义，最后在controller中实现\n\n## 前端实现步骤\n\n前端对api进行了封装，封装到api下的js中\n\n```js\nimport request from '@/utils/request'\n\nconst MemberTicket = {\n  // 分页查询会员票列表\n  memberTicketList(params) {\n    return request({\n      url: `http://localhost:51066/memberTicket/page`,\n      method: 'get',\n      params\n    })\n  }\n}\nexport default MemberTicket\n\n //引用\nimport MemeberTicket from ./memberTicket.js\nMemberTicker.memberTicketList(data).then(res=>{})\n\n//其中request是对axios的封装\n```\n\n","source":"_posts/springboot查询数据库字段实践.md","raw":"---\ntitle: springboot查询数据库字段实践\ncategory: Java\ntag: \n - Java\n - springboot\n\n---\n\n# springboot查询数据库字段实践\n\n## 任务描述：\n\n**在订单管理中增加购票信息界面、**\n\n**查询条件：赛季名称、赛事名称、票种、姓名、身份证号、购买者、区域、座位、票类型**\n\n**显示字段：赛季名称、赛事名称、票种、姓名、身份证号、购买者、区域、座位、二维码（限制显示长度20字符）、购票时间、票类型**\n\n**可效仿订单管理页。**\n\n## 后端实现步骤：\n\n### 查看需要查询的表的字段\n\n* 表名为`t_business_member_ticket`\n\n* 字段分别为：\n  * 赛季名称：通过activeId 查询t_business_activity 表的 season字段\n  * 赛事名称：game_player字段\n  * 票种：ticket_name字段\n  * 姓名：bearer_name字段\n  * 身份证号：bearer_id_num字段\n  * 购买者：通过buyer字段的id 查询 t_business_member 表的name字段\n  * 区域：通过 field_id 字段查询 t_base_venue_structure 表的data_name 字段\n  * 座位：seat_name字段\n  * 二维码：校验码（未定）write_off_code字段\n  * 购票时间：buy_date 字段\n  * 票类型：tickit_type 字段\n\n```sql\nSELECT t.id, t.ticket_name , t.bearer_id_num , t.bearer_name ,t.write_off_code,t.game_player , t.seat_name ,t.buy_date,t.tickit_type, m.name AS buyer_name , f.data_name AS field_name , a.activity_name AS activity_name \nFROM ticket.t_business_member_ticket t\nJOIN t_business_member m ON t.buyer=m.id\nJOIN t_base_venue_structure f ON t.field_id=f.id\nJOIN t_business_activity a ON t.activity_id=a.id\n```\n\n### 后端采用的技术是 jpa\n\n* 首先，创建需要返回的类 MemberTicketResponse.java\n\n* 使用jpa进行多表联查。需要在repository文件中实现查询\n\n  * ```java\n    package com.jbrf.service.business.repository.custom;\n    \n    import com.jbrf.common.model.CustomBaseQuery;\n    import com.jbrf.common.model.CustomPage;\n    import com.jbrf.entity.basedata.QTBaseVenueStructure;\n    import com.jbrf.entity.business.*;\n    import com.jbrf.service.business.model.response.MemberTicketResponse;\n    import com.querydsl.core.BooleanBuilder;\n    import com.querydsl.core.types.Projections;\n    import com.querydsl.jpa.impl.JPAQuery;\n    import org.springframework.data.domain.Pageable;\n    import org.springframework.stereotype.Repository;\n    \n    import java.util.List;\n    \n    import static org.apache.commons.lang3.StringUtils.isNotBlank;\n    \n    @Repository\n    public class MemberTicketCustomRepository extends CustomBaseQuery<MemberTicket> {\n        JPAQuery<MemberTicket> query = null;\n        private QMemberTicket qMemberTicket = QMemberTicket.memberTicket;\n        private QActivityInfo qActivityInfo = QActivityInfo.activityInfo;\n        private QTBaseVenueStructure qtBaseVenueStructure = QTBaseVenueStructure.tBaseVenueStructure;\n        private QMember qMember = QMember.member;\n    \n        public CustomPage<MemberTicketResponse> getMemberTicketByPage(\n                Pageable pageable,\n                String activityName,\n                String gamePlayer,\n                String ticketName,\n                String bearerName,\n                String bearer_id_num,\n                String fieldName,\n                String seatName,\n                String ticketType,\n                String buyerName\n        ) {\n            CustomPage<MemberTicketResponse> result = new CustomPage<MemberTicketResponse>(pageable);\n    \n            query = memberTicketPredict(activityName, gamePlayer, ticketName, bearerName, bearer_id_num,\n                    fieldName, seatName, ticketType, buyerName);\n    \n            System.out.println(query);\n            Long totalElements = query.select(qMemberTicket.id).fetchCount();\n            if (null == totalElements || totalElements == 0L) {\n                return result;\n            }\n            List<MemberTicketResponse> ticketResponseList = query\n                    .orderBy(qMemberTicket.buyDate.desc())\n                    .offset(pageable.getOffset())\n                    .limit(pageable.getPageSize())\n                    .select(\n                            Projections.constructor(MemberTicketResponse.class, qMemberTicket.id, qMemberTicket.buyDate, qMemberTicket.seatName, qMember.name, qMemberTicket.ticketType, qMemberTicket.bearerName, qMemberTicket.bearerIdNum, qMemberTicket.gamePlayer, qMemberTicket.ticketName, qtBaseVenueStructure.dataName, qActivityInfo.activityName, qMemberTicket.writeOffCode)\n                    )\n                    .fetch();\n    \n            return result.totalElements(totalElements).content(ticketResponseList);\n        }\n    \n    \n        private JPAQuery<MemberTicket> memberTicketPredict(String activityName,\n                                                           String gamePlayer,\n                                                           String ticketName,\n                                                           String bearerName,\n                                                           String bearerIdNum,\n                                                           String fieldName,\n                                                           String seatName,\n                                                           String ticketType,\n                                                           String buyerName) {\n            BooleanBuilder predicate = new BooleanBuilder();\n    \n            if (isNotBlank(activityName)) {\n                predicate.and(qActivityInfo.activityName.contains(activityName.trim()));\n            }\n            if (isNotBlank(gamePlayer)) {\n                predicate.and(qMemberTicket.gamePlayer.contains(gamePlayer.trim()));\n            }\n            if (isNotBlank(ticketName)) {\n                predicate.and(qMemberTicket.ticketName.contains(ticketName.trim()));\n            }\n            if (isNotBlank(bearerName)) {\n                predicate.and(qMemberTicket.bearerName.contains(bearerName.trim()));\n            }\n            if (isNotBlank(bearerIdNum)) {\n                predicate.and(qMemberTicket.bearerIdNum.eq(bearerIdNum.trim()));\n            }\n            if (isNotBlank(fieldName)) {\n                predicate.and(qtBaseVenueStructure.dataName.contains(fieldName.trim()));\n            }\n            if (isNotBlank(seatName)) {\n                predicate.and(qMemberTicket.seatName.contains(seatName.trim()));\n            }\n            if (isNotBlank(ticketType)) {\n                predicate.and(qMemberTicket.ticketType.in(ticketType.split(\",\")));\n            }\n            if (isNotBlank(buyerName)) {\n                predicate.and(qMember.name.eq(buyerName.trim()));\n            }\n            return query().from(qMemberTicket)\n                    .leftJoin(qMember).on(qMemberTicket.buyer.eq(qMember.id))              .leftJoin(qtBaseVenueStructure).on(qMemberTicket.fieldId.eq(qtBaseVenueStructure.id))\n                    .leftJoin(qActivityInfo).on(qMemberTicket.activityId.eq(qActivityInfo.id))\n                    .where(predicate);\n        }\n    }\n    \n    ```\n\n  * 这段代码动态创建查询语句，并且将查询结果封装给要返回的类 MemberTicketResponse\n\n### 在service 和 serviceImpl中定义，最后在controller中实现\n\n## 前端实现步骤\n\n前端对api进行了封装，封装到api下的js中\n\n```js\nimport request from '@/utils/request'\n\nconst MemberTicket = {\n  // 分页查询会员票列表\n  memberTicketList(params) {\n    return request({\n      url: `http://localhost:51066/memberTicket/page`,\n      method: 'get',\n      params\n    })\n  }\n}\nexport default MemberTicket\n\n //引用\nimport MemeberTicket from ./memberTicket.js\nMemberTicker.memberTicketList(data).then(res=>{})\n\n//其中request是对axios的封装\n```\n\n","slug":"springboot查询数据库字段实践","published":1,"date":"2023-09-05T11:23:59.427Z","updated":"2023-09-11T13:29:38.328Z","_id":"clm8tu10g0000w0gf1zm88z7u","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"springboot查询数据库字段实践\"><a href=\"#springboot查询数据库字段实践\" class=\"headerlink\" title=\"springboot查询数据库字段实践\"></a>springboot查询数据库字段实践</h1><h2 id=\"任务描述：\"><a href=\"#任务描述：\" class=\"headerlink\" title=\"任务描述：\"></a>任务描述：</h2><p><strong>在订单管理中增加购票信息界面、</strong></p>\n<p><strong>查询条件：赛季名称、赛事名称、票种、姓名、身份证号、购买者、区域、座位、票类型</strong></p>\n<p><strong>显示字段：赛季名称、赛事名称、票种、姓名、身份证号、购买者、区域、座位、二维码（限制显示长度20字符）、购票时间、票类型</strong></p>\n<p><strong>可效仿订单管理页。</strong></p>\n<h2 id=\"后端实现步骤：\"><a href=\"#后端实现步骤：\" class=\"headerlink\" title=\"后端实现步骤：\"></a>后端实现步骤：</h2><h3 id=\"查看需要查询的表的字段\"><a href=\"#查看需要查询的表的字段\" class=\"headerlink\" title=\"查看需要查询的表的字段\"></a>查看需要查询的表的字段</h3><ul>\n<li><p>表名为<code>t_business_member_ticket</code></p>\n</li>\n<li><p>字段分别为：</p>\n<ul>\n<li>赛季名称：通过activeId 查询t_business_activity 表的 season字段</li>\n<li>赛事名称：game_player字段</li>\n<li>票种：ticket_name字段</li>\n<li>姓名：bearer_name字段</li>\n<li>身份证号：bearer_id_num字段</li>\n<li>购买者：通过buyer字段的id 查询 t_business_member 表的name字段</li>\n<li>区域：通过 field_id 字段查询 t_base_venue_structure 表的data_name 字段</li>\n<li>座位：seat_name字段</li>\n<li>二维码：校验码（未定）write_off_code字段</li>\n<li>购票时间：buy_date 字段</li>\n<li>票类型：tickit_type 字段</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"sql\">SELECT t.id, t.ticket_name , t.bearer_id_num , t.bearer_name ,t.write_off_code,t.game_player , t.seat_name ,t.buy_date,t.tickit_type, m.name AS buyer_name , f.data_name AS field_name , a.activity_name AS activity_name \nFROM ticket.t_business_member_ticket t\nJOIN t_business_member m ON t.buyer=m.id\nJOIN t_base_venue_structure f ON t.field_id=f.id\nJOIN t_business_activity a ON t.activity_id=a.id\n</code></pre>\n<h3 id=\"后端采用的技术是-jpa\"><a href=\"#后端采用的技术是-jpa\" class=\"headerlink\" title=\"后端采用的技术是 jpa\"></a>后端采用的技术是 jpa</h3><ul>\n<li><p>首先，创建需要返回的类 MemberTicketResponse.java</p>\n</li>\n<li><p>使用jpa进行多表联查。需要在repository文件中实现查询</p>\n<ul>\n<li><pre><code class=\"java\">package com.jbrf.service.business.repository.custom;\n\nimport com.jbrf.common.model.CustomBaseQuery;\nimport com.jbrf.common.model.CustomPage;\nimport com.jbrf.entity.basedata.QTBaseVenueStructure;\nimport com.jbrf.entity.business.*;\nimport com.jbrf.service.business.model.response.MemberTicketResponse;\nimport com.querydsl.core.BooleanBuilder;\nimport com.querydsl.core.types.Projections;\nimport com.querydsl.jpa.impl.JPAQuery;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\nimport static org.apache.commons.lang3.StringUtils.isNotBlank;\n\n@Repository\npublic class MemberTicketCustomRepository extends CustomBaseQuery&lt;MemberTicket&gt; &#123;\n    JPAQuery&lt;MemberTicket&gt; query = null;\n    private QMemberTicket qMemberTicket = QMemberTicket.memberTicket;\n    private QActivityInfo qActivityInfo = QActivityInfo.activityInfo;\n    private QTBaseVenueStructure qtBaseVenueStructure = QTBaseVenueStructure.tBaseVenueStructure;\n    private QMember qMember = QMember.member;\n\n    public CustomPage&lt;MemberTicketResponse&gt; getMemberTicketByPage(\n            Pageable pageable,\n            String activityName,\n            String gamePlayer,\n            String ticketName,\n            String bearerName,\n            String bearer_id_num,\n            String fieldName,\n            String seatName,\n            String ticketType,\n            String buyerName\n    ) &#123;\n        CustomPage&lt;MemberTicketResponse&gt; result = new CustomPage&lt;MemberTicketResponse&gt;(pageable);\n\n        query = memberTicketPredict(activityName, gamePlayer, ticketName, bearerName, bearer_id_num,\n                fieldName, seatName, ticketType, buyerName);\n\n        System.out.println(query);\n        Long totalElements = query.select(qMemberTicket.id).fetchCount();\n        if (null == totalElements || totalElements == 0L) &#123;\n            return result;\n        &#125;\n        List&lt;MemberTicketResponse&gt; ticketResponseList = query\n                .orderBy(qMemberTicket.buyDate.desc())\n                .offset(pageable.getOffset())\n                .limit(pageable.getPageSize())\n                .select(\n                        Projections.constructor(MemberTicketResponse.class, qMemberTicket.id, qMemberTicket.buyDate, qMemberTicket.seatName, qMember.name, qMemberTicket.ticketType, qMemberTicket.bearerName, qMemberTicket.bearerIdNum, qMemberTicket.gamePlayer, qMemberTicket.ticketName, qtBaseVenueStructure.dataName, qActivityInfo.activityName, qMemberTicket.writeOffCode)\n                )\n                .fetch();\n\n        return result.totalElements(totalElements).content(ticketResponseList);\n    &#125;\n\n\n    private JPAQuery&lt;MemberTicket&gt; memberTicketPredict(String activityName,\n                                                       String gamePlayer,\n                                                       String ticketName,\n                                                       String bearerName,\n                                                       String bearerIdNum,\n                                                       String fieldName,\n                                                       String seatName,\n                                                       String ticketType,\n                                                       String buyerName) &#123;\n        BooleanBuilder predicate = new BooleanBuilder();\n\n        if (isNotBlank(activityName)) &#123;\n            predicate.and(qActivityInfo.activityName.contains(activityName.trim()));\n        &#125;\n        if (isNotBlank(gamePlayer)) &#123;\n            predicate.and(qMemberTicket.gamePlayer.contains(gamePlayer.trim()));\n        &#125;\n        if (isNotBlank(ticketName)) &#123;\n            predicate.and(qMemberTicket.ticketName.contains(ticketName.trim()));\n        &#125;\n        if (isNotBlank(bearerName)) &#123;\n            predicate.and(qMemberTicket.bearerName.contains(bearerName.trim()));\n        &#125;\n        if (isNotBlank(bearerIdNum)) &#123;\n            predicate.and(qMemberTicket.bearerIdNum.eq(bearerIdNum.trim()));\n        &#125;\n        if (isNotBlank(fieldName)) &#123;\n            predicate.and(qtBaseVenueStructure.dataName.contains(fieldName.trim()));\n        &#125;\n        if (isNotBlank(seatName)) &#123;\n            predicate.and(qMemberTicket.seatName.contains(seatName.trim()));\n        &#125;\n        if (isNotBlank(ticketType)) &#123;\n            predicate.and(qMemberTicket.ticketType.in(ticketType.split(&quot;,&quot;)));\n        &#125;\n        if (isNotBlank(buyerName)) &#123;\n            predicate.and(qMember.name.eq(buyerName.trim()));\n        &#125;\n        return query().from(qMemberTicket)\n                .leftJoin(qMember).on(qMemberTicket.buyer.eq(qMember.id))              .leftJoin(qtBaseVenueStructure).on(qMemberTicket.fieldId.eq(qtBaseVenueStructure.id))\n                .leftJoin(qActivityInfo).on(qMemberTicket.activityId.eq(qActivityInfo.id))\n                .where(predicate);\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>这段代码动态创建查询语句，并且将查询结果封装给要返回的类 MemberTicketResponse</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"在service-和-serviceImpl中定义，最后在controller中实现\"><a href=\"#在service-和-serviceImpl中定义，最后在controller中实现\" class=\"headerlink\" title=\"在service 和 serviceImpl中定义，最后在controller中实现\"></a>在service 和 serviceImpl中定义，最后在controller中实现</h3><h2 id=\"前端实现步骤\"><a href=\"#前端实现步骤\" class=\"headerlink\" title=\"前端实现步骤\"></a>前端实现步骤</h2><p>前端对api进行了封装，封装到api下的js中</p>\n<pre><code class=\"js\">import request from &#39;@/utils/request&#39;\n\nconst MemberTicket = &#123;\n  // 分页查询会员票列表\n  memberTicketList(params) &#123;\n    return request(&#123;\n      url: `http://localhost:51066/memberTicket/page`,\n      method: &#39;get&#39;,\n      params\n    &#125;)\n  &#125;\n&#125;\nexport default MemberTicket\n\n //引用\nimport MemeberTicket from ./memberTicket.js\nMemberTicker.memberTicketList(data).then(res=&gt;&#123;&#125;)\n\n//其中request是对axios的封装\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"springboot查询数据库字段实践\"><a href=\"#springboot查询数据库字段实践\" class=\"headerlink\" title=\"springboot查询数据库字段实践\"></a>springboot查询数据库字段实践</h1><h2 id=\"任务描述：\"><a href=\"#任务描述：\" class=\"headerlink\" title=\"任务描述：\"></a>任务描述：</h2><p><strong>在订单管理中增加购票信息界面、</strong></p>\n<p><strong>查询条件：赛季名称、赛事名称、票种、姓名、身份证号、购买者、区域、座位、票类型</strong></p>\n<p><strong>显示字段：赛季名称、赛事名称、票种、姓名、身份证号、购买者、区域、座位、二维码（限制显示长度20字符）、购票时间、票类型</strong></p>\n<p><strong>可效仿订单管理页。</strong></p>\n<h2 id=\"后端实现步骤：\"><a href=\"#后端实现步骤：\" class=\"headerlink\" title=\"后端实现步骤：\"></a>后端实现步骤：</h2><h3 id=\"查看需要查询的表的字段\"><a href=\"#查看需要查询的表的字段\" class=\"headerlink\" title=\"查看需要查询的表的字段\"></a>查看需要查询的表的字段</h3><ul>\n<li><p>表名为<code>t_business_member_ticket</code></p>\n</li>\n<li><p>字段分别为：</p>\n<ul>\n<li>赛季名称：通过activeId 查询t_business_activity 表的 season字段</li>\n<li>赛事名称：game_player字段</li>\n<li>票种：ticket_name字段</li>\n<li>姓名：bearer_name字段</li>\n<li>身份证号：bearer_id_num字段</li>\n<li>购买者：通过buyer字段的id 查询 t_business_member 表的name字段</li>\n<li>区域：通过 field_id 字段查询 t_base_venue_structure 表的data_name 字段</li>\n<li>座位：seat_name字段</li>\n<li>二维码：校验码（未定）write_off_code字段</li>\n<li>购票时间：buy_date 字段</li>\n<li>票类型：tickit_type 字段</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"sql\">SELECT t.id, t.ticket_name , t.bearer_id_num , t.bearer_name ,t.write_off_code,t.game_player , t.seat_name ,t.buy_date,t.tickit_type, m.name AS buyer_name , f.data_name AS field_name , a.activity_name AS activity_name \nFROM ticket.t_business_member_ticket t\nJOIN t_business_member m ON t.buyer=m.id\nJOIN t_base_venue_structure f ON t.field_id=f.id\nJOIN t_business_activity a ON t.activity_id=a.id\n</code></pre>\n<h3 id=\"后端采用的技术是-jpa\"><a href=\"#后端采用的技术是-jpa\" class=\"headerlink\" title=\"后端采用的技术是 jpa\"></a>后端采用的技术是 jpa</h3><ul>\n<li><p>首先，创建需要返回的类 MemberTicketResponse.java</p>\n</li>\n<li><p>使用jpa进行多表联查。需要在repository文件中实现查询</p>\n<ul>\n<li><pre><code class=\"java\">package com.jbrf.service.business.repository.custom;\n\nimport com.jbrf.common.model.CustomBaseQuery;\nimport com.jbrf.common.model.CustomPage;\nimport com.jbrf.entity.basedata.QTBaseVenueStructure;\nimport com.jbrf.entity.business.*;\nimport com.jbrf.service.business.model.response.MemberTicketResponse;\nimport com.querydsl.core.BooleanBuilder;\nimport com.querydsl.core.types.Projections;\nimport com.querydsl.jpa.impl.JPAQuery;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\nimport static org.apache.commons.lang3.StringUtils.isNotBlank;\n\n@Repository\npublic class MemberTicketCustomRepository extends CustomBaseQuery&lt;MemberTicket&gt; &#123;\n    JPAQuery&lt;MemberTicket&gt; query = null;\n    private QMemberTicket qMemberTicket = QMemberTicket.memberTicket;\n    private QActivityInfo qActivityInfo = QActivityInfo.activityInfo;\n    private QTBaseVenueStructure qtBaseVenueStructure = QTBaseVenueStructure.tBaseVenueStructure;\n    private QMember qMember = QMember.member;\n\n    public CustomPage&lt;MemberTicketResponse&gt; getMemberTicketByPage(\n            Pageable pageable,\n            String activityName,\n            String gamePlayer,\n            String ticketName,\n            String bearerName,\n            String bearer_id_num,\n            String fieldName,\n            String seatName,\n            String ticketType,\n            String buyerName\n    ) &#123;\n        CustomPage&lt;MemberTicketResponse&gt; result = new CustomPage&lt;MemberTicketResponse&gt;(pageable);\n\n        query = memberTicketPredict(activityName, gamePlayer, ticketName, bearerName, bearer_id_num,\n                fieldName, seatName, ticketType, buyerName);\n\n        System.out.println(query);\n        Long totalElements = query.select(qMemberTicket.id).fetchCount();\n        if (null == totalElements || totalElements == 0L) &#123;\n            return result;\n        &#125;\n        List&lt;MemberTicketResponse&gt; ticketResponseList = query\n                .orderBy(qMemberTicket.buyDate.desc())\n                .offset(pageable.getOffset())\n                .limit(pageable.getPageSize())\n                .select(\n                        Projections.constructor(MemberTicketResponse.class, qMemberTicket.id, qMemberTicket.buyDate, qMemberTicket.seatName, qMember.name, qMemberTicket.ticketType, qMemberTicket.bearerName, qMemberTicket.bearerIdNum, qMemberTicket.gamePlayer, qMemberTicket.ticketName, qtBaseVenueStructure.dataName, qActivityInfo.activityName, qMemberTicket.writeOffCode)\n                )\n                .fetch();\n\n        return result.totalElements(totalElements).content(ticketResponseList);\n    &#125;\n\n\n    private JPAQuery&lt;MemberTicket&gt; memberTicketPredict(String activityName,\n                                                       String gamePlayer,\n                                                       String ticketName,\n                                                       String bearerName,\n                                                       String bearerIdNum,\n                                                       String fieldName,\n                                                       String seatName,\n                                                       String ticketType,\n                                                       String buyerName) &#123;\n        BooleanBuilder predicate = new BooleanBuilder();\n\n        if (isNotBlank(activityName)) &#123;\n            predicate.and(qActivityInfo.activityName.contains(activityName.trim()));\n        &#125;\n        if (isNotBlank(gamePlayer)) &#123;\n            predicate.and(qMemberTicket.gamePlayer.contains(gamePlayer.trim()));\n        &#125;\n        if (isNotBlank(ticketName)) &#123;\n            predicate.and(qMemberTicket.ticketName.contains(ticketName.trim()));\n        &#125;\n        if (isNotBlank(bearerName)) &#123;\n            predicate.and(qMemberTicket.bearerName.contains(bearerName.trim()));\n        &#125;\n        if (isNotBlank(bearerIdNum)) &#123;\n            predicate.and(qMemberTicket.bearerIdNum.eq(bearerIdNum.trim()));\n        &#125;\n        if (isNotBlank(fieldName)) &#123;\n            predicate.and(qtBaseVenueStructure.dataName.contains(fieldName.trim()));\n        &#125;\n        if (isNotBlank(seatName)) &#123;\n            predicate.and(qMemberTicket.seatName.contains(seatName.trim()));\n        &#125;\n        if (isNotBlank(ticketType)) &#123;\n            predicate.and(qMemberTicket.ticketType.in(ticketType.split(&quot;,&quot;)));\n        &#125;\n        if (isNotBlank(buyerName)) &#123;\n            predicate.and(qMember.name.eq(buyerName.trim()));\n        &#125;\n        return query().from(qMemberTicket)\n                .leftJoin(qMember).on(qMemberTicket.buyer.eq(qMember.id))              .leftJoin(qtBaseVenueStructure).on(qMemberTicket.fieldId.eq(qtBaseVenueStructure.id))\n                .leftJoin(qActivityInfo).on(qMemberTicket.activityId.eq(qActivityInfo.id))\n                .where(predicate);\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p>这段代码动态创建查询语句，并且将查询结果封装给要返回的类 MemberTicketResponse</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"在service-和-serviceImpl中定义，最后在controller中实现\"><a href=\"#在service-和-serviceImpl中定义，最后在controller中实现\" class=\"headerlink\" title=\"在service 和 serviceImpl中定义，最后在controller中实现\"></a>在service 和 serviceImpl中定义，最后在controller中实现</h3><h2 id=\"前端实现步骤\"><a href=\"#前端实现步骤\" class=\"headerlink\" title=\"前端实现步骤\"></a>前端实现步骤</h2><p>前端对api进行了封装，封装到api下的js中</p>\n<pre><code class=\"js\">import request from &#39;@/utils/request&#39;\n\nconst MemberTicket = &#123;\n  // 分页查询会员票列表\n  memberTicketList(params) &#123;\n    return request(&#123;\n      url: `http://localhost:51066/memberTicket/page`,\n      method: &#39;get&#39;,\n      params\n    &#125;)\n  &#125;\n&#125;\nexport default MemberTicket\n\n //引用\nimport MemeberTicket from ./memberTicket.js\nMemberTicker.memberTicketList(data).then(res=&gt;&#123;&#125;)\n\n//其中request是对axios的封装\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cllyxpksf000514gfg2iygp8q","category_id":"cllyxpksc000214gf5ined7ji","_id":"cllyxpksi000b14gfa7nl7mma"},{"post_id":"cllyxpks5000014gf6j1b5r6j","category_id":"cllyxpksc000214gf5ined7ji","_id":"cllyxpksj000f14gf41oq6ym6"},{"post_id":"cllyxpksf000614gf4pft5uf0","category_id":"cllyxpksc000214gf5ined7ji","_id":"cllyxpksk000h14gfekdo7dpd"},{"post_id":"cllyxpksh000914gfdjctcaaa","category_id":"cllyxpksg000714gfci8aeep1","_id":"cllyxpksm000l14gf3vh55zc7"},{"post_id":"cllyxpksb000114gf2axi19fe","category_id":"cllyxpksg000714gfci8aeep1","_id":"cllyxpksn000o14gfhkci48z2"},{"post_id":"cllyxpksj000e14gf65nf48xn","category_id":"cllyxpksg000714gfci8aeep1","_id":"cllyxpkso000t14gf905x8c2d"},{"post_id":"cllyxpkse000414gf745vd6my","category_id":"cllyxpksi000c14gfde3y3qae","_id":"cllyxpkso000v14gf1bnb9mqp"},{"post_id":"cllyxpksj000g14gf6kq8fry4","category_id":"cllyxpksg000714gfci8aeep1","_id":"cllyxpksp000y14gfaqfj1nsc"},{"post_id":"cllyxpksh000a14gf8xah0ujq","category_id":"cllyxpksi000c14gfde3y3qae","_id":"cllyxpksp001114gfhfee2u2z"},{"post_id":"cllyxpksm000n14gffsszba8h","category_id":"cllyxpksg000714gfci8aeep1","_id":"cllyxpksp001214gfci6jhyz9"},{"post_id":"cllyxpksl000k14gf2yvfgf4e","category_id":"cllyxpksn000q14gf8c6xh074","_id":"cllyxpksq001414gf1jykc4xy"},{"post_id":"cllyxpkso000s14gfczrlcs18","category_id":"cllyxpksp000x14gfgwy55r3v","_id":"cllyxpksq001714gf12y5f91x"},{"post_id":"cllyxpksx002014gfelpo9vkn","category_id":"cllyxpksg000714gfci8aeep1","_id":"cllyxpksz002614gf157t2lse"},{"post_id":"cllyxpksx002114gfg9afazsc","category_id":"cllyxpksg000714gfci8aeep1","_id":"cllyxpkt0002914gfgae50xd9"},{"post_id":"cllyxpksy002314gfc5wue59g","category_id":"cllyxpksg000714gfci8aeep1","_id":"cllyxpkt0002b14gf4z4679xg"},{"post_id":"cllyxpksz002514gf0uux1lvp","category_id":"cllyxpksc000214gf5ined7ji","_id":"cllyxpkt1002d14gfhytc0maw"},{"post_id":"cllyxpkt0002814gf847k5sk6","category_id":"cllyxpkt1002c14gfffgngpu5","_id":"cllyxpkt1002j14gfeee08doi"},{"post_id":"clm4spvd50000ksgf9yw127o2","category_id":"clm4spvdc0001ksgfhtj54m8c","_id":"clm4spvdi0004ksgfcdj1dqwv"},{"post_id":"clm8tu10g0000w0gf1zm88z7u","category_id":"cllyxpkt1002c14gfffgngpu5","_id":"clm8tu10l0002w0gf4wddcf61"}],"PostTag":[{"post_id":"cllyxpks5000014gf6j1b5r6j","tag_id":"cllyxpksd000314gf6zltf3zm","_id":"cllyxpksm000m14gfay0b2jfn"},{"post_id":"cllyxpks5000014gf6j1b5r6j","tag_id":"cllyxpksg000814gfgzkna005","_id":"cllyxpksn000p14gf4boi7z9n"},{"post_id":"cllyxpks5000014gf6j1b5r6j","tag_id":"cllyxpksi000d14gf149ub78e","_id":"cllyxpkso000u14gf1ctb20se"},{"post_id":"cllyxpksb000114gf2axi19fe","tag_id":"cllyxpksk000j14gf9oet93nb","_id":"cllyxpksp000w14gf5fvngphd"},{"post_id":"cllyxpksm000n14gffsszba8h","tag_id":"cllyxpksk000j14gf9oet93nb","_id":"cllyxpksp001014gf6vji4uwx"},{"post_id":"cllyxpkse000414gf745vd6my","tag_id":"cllyxpksn000r14gfc6cn5ar5","_id":"cllyxpksq001514gfd4fxe266"},{"post_id":"cllyxpkse000414gf745vd6my","tag_id":"cllyxpksp000z14gf507552ij","_id":"cllyxpksq001614gf31fbchos"},{"post_id":"cllyxpksf000514gfg2iygp8q","tag_id":"cllyxpksg000814gfgzkna005","_id":"cllyxpksq001914gf8x2rhl02"},{"post_id":"cllyxpksf000614gf4pft5uf0","tag_id":"cllyxpksg000814gfgzkna005","_id":"cllyxpksr001c14gfg0t89j1k"},{"post_id":"cllyxpksf000614gf4pft5uf0","tag_id":"cllyxpksq001a14gffv0gdkk1","_id":"cllyxpksr001d14gfe42n7cgz"},{"post_id":"cllyxpksh000914gfdjctcaaa","tag_id":"cllyxpksk000j14gf9oet93nb","_id":"cllyxpksr001f14gf5kzvaybg"},{"post_id":"cllyxpksh000a14gf8xah0ujq","tag_id":"cllyxpksn000r14gfc6cn5ar5","_id":"cllyxpkss001i14gf1xkvhiet"},{"post_id":"cllyxpksh000a14gf8xah0ujq","tag_id":"cllyxpkss001g14gf96yz3xmc","_id":"cllyxpkss001j14gf5byq7nlj"},{"post_id":"cllyxpksj000e14gf65nf48xn","tag_id":"cllyxpksk000j14gf9oet93nb","_id":"cllyxpkst001l14gfbq937lyf"},{"post_id":"cllyxpksj000g14gf6kq8fry4","tag_id":"cllyxpksk000j14gf9oet93nb","_id":"cllyxpkst001n14gfeqaagmyy"},{"post_id":"cllyxpksl000k14gf2yvfgf4e","tag_id":"cllyxpkst001m14gf4bat86f4","_id":"cllyxpksu001r14gf5q519eay"},{"post_id":"cllyxpksl000k14gf2yvfgf4e","tag_id":"cllyxpksi000d14gf149ub78e","_id":"cllyxpksu001s14gf1l815xnt"},{"post_id":"cllyxpksl000k14gf2yvfgf4e","tag_id":"cllyxpkst001o14gf0nf02f8c","_id":"cllyxpksu001u14gfgvpvhpny"},{"post_id":"cllyxpksl000k14gf2yvfgf4e","tag_id":"cllyxpkst001p14gfa253dp8w","_id":"cllyxpksu001v14gf5tox3ik6"},{"post_id":"cllyxpkso000s14gfczrlcs18","tag_id":"cllyxpkst001q14gf23b7h93n","_id":"cllyxpksv001x14gfh6pf3hcr"},{"post_id":"cllyxpkso000s14gfczrlcs18","tag_id":"cllyxpksu001t14gfgsv5eklz","_id":"cllyxpksv001y14gfb5261hjd"},{"post_id":"cllyxpkso000s14gfczrlcs18","tag_id":"cllyxpksu001w14gf5new9d2t","_id":"cllyxpksv001z14gfbps3c2ts"},{"post_id":"cllyxpksx002014gfelpo9vkn","tag_id":"cllyxpksk000j14gf9oet93nb","_id":"cllyxpksy002214gfhg0n3a51"},{"post_id":"cllyxpksx002114gfg9afazsc","tag_id":"cllyxpksk000j14gf9oet93nb","_id":"cllyxpksz002414gfdc4day53"},{"post_id":"cllyxpksy002314gfc5wue59g","tag_id":"cllyxpksk000j14gf9oet93nb","_id":"cllyxpksz002714gf5ln7hgew"},{"post_id":"cllyxpksz002514gf0uux1lvp","tag_id":"cllyxpksg000814gfgzkna005","_id":"cllyxpkt1002f14gf21ep8ffl"},{"post_id":"cllyxpksz002514gf0uux1lvp","tag_id":"cllyxpkst001p14gfa253dp8w","_id":"cllyxpkt1002g14gf8rxohphe"},{"post_id":"cllyxpksz002514gf0uux1lvp","tag_id":"cllyxpksi000d14gf149ub78e","_id":"cllyxpkt1002i14gfdx7oaxbh"},{"post_id":"cllyxpksz002514gf0uux1lvp","tag_id":"cllyxpkt0002a14gf75o20f7e","_id":"cllyxpkt1002k14gf7wmocamg"},{"post_id":"cllyxpkt0002814gf847k5sk6","tag_id":"cllyxpkt1002e14gf6f4g15c2","_id":"cllyxpkt2002m14gfbrif7jla"},{"post_id":"cllyxpkt0002814gf847k5sk6","tag_id":"cllyxpkt1002h14gfh8sj3x80","_id":"cllyxpkt2002n14gf2xcr6cyj"},{"post_id":"cllyxpkt0002814gf847k5sk6","tag_id":"cllyxpkt2002l14gfgvgh6d4n","_id":"cllyxpkt2002o14gf9gq2a2fk"},{"post_id":"clm4spvd50000ksgf9yw127o2","tag_id":"cllyxpksi000d14gf149ub78e","_id":"clm4spvdi0005ksgfd0kg3qtu"},{"post_id":"clm4spvd50000ksgf9yw127o2","tag_id":"clm4spvde0002ksgfgo1s99l9","_id":"clm4spvdi0006ksgf8eb527hz"},{"post_id":"clm4spvd50000ksgf9yw127o2","tag_id":"clm4spvdh0003ksgf8dyuehmh","_id":"clm4spvdi0007ksgf9a339pjz"},{"post_id":"clm8tu10g0000w0gf1zm88z7u","tag_id":"cllyxpkt1002e14gf6f4g15c2","_id":"clm8tu10l0003w0gf3zya6fdq"},{"post_id":"clm8tu10g0000w0gf1zm88z7u","tag_id":"clm8tu10i0001w0gf1q6de45c","_id":"clm8tu10l0004w0gf3c0w7jkd"}],"Tag":[{"name":"Centos","_id":"cllyxpksd000314gf6zltf3zm"},{"name":"K8S","_id":"cllyxpksg000814gfgzkna005"},{"name":"教程","_id":"cllyxpksi000d14gf149ub78e"},{"name":"吉他谱","_id":"cllyxpksk000j14gf9oet93nb"},{"name":"设计文档","_id":"cllyxpksn000r14gfc6cn5ar5"},{"name":"Mydisk","_id":"cllyxpksp000z14gf507552ij"},{"name":"负载均衡","_id":"cllyxpksq001a14gffv0gdkk1"},{"name":"四子ding","_id":"cllyxpkss001g14gf96yz3xmc"},{"name":"docker","_id":"cllyxpkst001m14gf4bat86f4"},{"name":"contianer","_id":"cllyxpkst001o14gf0nf02f8c"},{"name":"openEuler","_id":"cllyxpkst001p14gfa253dp8w"},{"name":"概率论","_id":"cllyxpkst001q14gf23b7h93n"},{"name":"掷筛","_id":"cllyxpksu001t14gfgsv5eklz"},{"name":"NdS","_id":"cllyxpksu001w14gf5new9d2t"},{"name":"arm64","_id":"cllyxpkt0002a14gf75o20f7e"},{"name":"Java","_id":"cllyxpkt1002e14gf6f4g15c2"},{"name":"面经","_id":"cllyxpkt1002h14gfh8sj3x80"},{"name":"八股文","_id":"cllyxpkt2002l14gfgvgh6d4n"},{"name":"ssl","_id":"clm4spvde0002ksgfgo1s99l9"},{"name":"https","_id":"clm4spvdh0003ksgf8dyuehmh"},{"name":"springboot","_id":"clm8tu10i0001w0gf1q6de45c"}]}}